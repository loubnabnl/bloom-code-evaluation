[["def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(0, len(l)):\n       if i in l:\n          return True\n    return False", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return filter(l, lambda x: x >= 0)\n\nI thought the first code snippet was going to be some kind of exponential algorithm but it's just a filter.\n\nyeah, this one is a bit disappointing. It would have been far more interesting to see some kind of mathematical approach.\n\nYou can probably do better, but this one is still pretty good:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return l[len(l) - 1 :]\nYou could do the same thing with \"exclude\":", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for l in l:\n        if len(l) > 0:\n           return l[0]\nThis seems to be a bug. It doesn't return anything if the list is empty.\n\nIt doesn't return anything if the list is empty.\nI don't know what you mean by empty, but the code is doing something equivalent to", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # returns a list of positive numbers in a list\n    positive_list = []\n    for l in l:\n        if (l[0] > 0):\n            positive_list.append(l[1])\n    return positive_list", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[1] > 0]\nThat's not very idiomatic. First, you should test to see whether you actually have a list, then you should use list comprehension to get the first element that meets your criteria.  EDIT: If you want to do the \"decreasing\" thing, try this:      def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return l.filter(lambda x: x > 0)\nI agree.  It's a bit more verbose, but it's definitely more pythonic.  I'd also suggest changing your ``return l.filter(lambda x: x > 0)`` to ``", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for x in l:\n        if x >= 0:\n           return x\n    return []\nI was just thinking about this problem yesterday. Interesting to see that it is still considered interesting and not solved yet.\n\nI think the point of the post is that it is difficult to solve in Python, not that it is considered an interesting problem.\n\nI would be interested in an implementation in Python. I think it should be possible to generate a list of numbers by increasing value, and then sort by increasing value. For the numbers smaller than 0, just return them.\n\nMy solution is still quite naive. It was implemented in 45 minutes.\nI'm sure there is a more elegant solution possible, but this one works.\nI also made a version that returns a list of rational numbers instead of floats, so it can be used in cases where it is needed.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    assert isinstance(l, list)\n    assert len(l) == 1\n    assert len(l[0]) == 1\n    assert len(l[1]) == 1\n    for item in l:\n        if item == -1:\n           return item\n    return False\nAh, the list comprehension. Makes me feel like a wizard.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] + l[1]) / 2", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # remove negative numbers\n    list = [int(x) for x in l if x > 0]\n    # return only non-zero values\n    return list\nThe most obvious problem with this is that it doesn't allow negative numbers.  And it's really not that useful unless you know that it can only return positive numbers.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\n\nYou could also do it with a dict, if you don't want to deal with list at all.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop() == l.pop()[:-1]\nThat's it, really? This is, by far, the simplest I've ever seen.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if not isinstance(l, list):\n       return []\n    for x in l:\n       if x > 0:\n          return x\n    return []\nWe can also do a with() instead of a for() if we want a list instead of a tuple:      >>> get_positive(with(lambda x: isinstance(x, int) and x > 0, [1, 2, 3, -1, 4, 5, 6]))[0, 3, 6]\nWe also get to use lambdas if we define the function as a function object:      >>> get_positive(lambda x: isinstance(x, int) and x > 0, [1, 2, 3, -1, 4, 5, 6]))[0, 3, 6]\nBut in the case of a for loop, you can just leave it as a normal function, since the for loop is just syntactic sugar for a list comprehension.      >>> get_positive(with(lambda x: isinstance(x", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop()), []\nI'm not sure it's a good idea to return an empty list in your examples, rather I'd prefer\nreturn sorted(l.pop(), key=lambda x: x >= 0)\nwhich also works with negative numbers.\n\nNice, I like your solution better.\n\nYou can also do it without the lambda:\nreturn sorted(l.pop(), key=l[:])\n\nI found the Ruby way of writing code to be much more readable than the Python way.\n\nAgreed. I've written a lot of Ruby and a little bit of Python and I found that while the Ruby examples were easier to read, the Python examples were easier to understand. I think that's probably a good thing; Python seems like it might be easier for newbies to learn.\n\nFor newbies, I would recommend Ruby, as it has a nice and intuitive syntax (eg, easy to understand operators like \"and\", \"or\" etc.), whereas Python's is much more complicated (eg, the reason for \"and\" and \"or\" being keywords, and not simply operators, is that their \"formal\" operator forms would be \"&&\" and \"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [-1, 2, -4, 5, 6]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if list[0] < 0 or list[0] > 10:\n       return [].join(list[0:9])\n    else:\n       return [list[0] for list[0] in list]\n\nFor those who are wondering, this is Python's built-in collections.OrderedDict. \n\nI wonder why he doesn't use that to begin with, instead of using a list comprehension, since he ends up using it anyway.\n\nThis is a common problem in Python development. People come from a C/C++/Java background where they learned to use a for loop to iterate over a container and compute a set of values. In Python, a list comprehension is essentially the same thing. The only difference is that it uses list objects and not numeric indices.\nWhat is frustrating to me is that they are adding language features that make it seem like they are trying to support functional programming, but they are not doing it in a way that makes sense. If you are going to add a map/filter/reduce feature, then you should make it so that using map/filter/reduce actually gets the", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in list if l[0] > 0]\nSince you're returning a list, and you're only interested in the first element, you could probably just return [1] instead of a list.\n\nThere is a new list comprehension syntax that is a bit cleaner.\n>>> get_positive = lambda l: [l[0] for l in list if l[0] > 0]\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n\nThere's also", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    assert len(l) > 1\n    for n in l:\n       if n >= 1:\n          return n\n    return []\nDoesn't work for negative numbers.\nIn the comments the author says they want to test the feature with a single integer. That's a good idea.\n\nI did this and it worked:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l:\n        return l:\n    elif len(l) == 1:\n        return 0\n    elif len(l) > 1:\n        return l:\n    else:\n        return 0\n    return 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    if len(l) == 0:\n        return []\n    return l[0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    val is_positive = list(set(l))\n    if is_positive:\n       return True\n    else:\n       return False\n>>> is_positive([-1, 2, -4, 5, 6])\nTrue\n>>> is_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\nFalse\nFor more complicated cases you can use the built-in function inverses\nof sets to get the list of elements that you want to exclude.\nFor example, I want to exclude the numbers divisible by 2.\n>>> from collections import Set\n>>> l = list(Set(2))\n>>> from itertools import inverses\n>>> l_inverses = inverses(l)\n>>> is_positive(l_inverses)\nTrue\n>>> is_positive(l)\nFalse\nHope this helps\n-A.\n\n> def get_positive(l: list):\n> \"\"\"Return only positive numbers in the list.\n> >>> get_positive([-1, 2, -4", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(1, len(l) - 1)]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[2:] for l in l]\nI'm not an expert on Python, but I do know that this will only work if l is sorted (I.e. it is an ordered list).\n\nShouldn't it be len(l), not l[2:]?\n\nI think it's a lambda, and it's using l[2:] to refer to the second element of l.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    l = [x for x in l if x % 2 == 0]\n    return [y for y in sorted(l, key=lambda x: x[0]) if y]\nI'm actually kind of shocked that this works...\n\nI was too. And then I realized the order is maintained by the list; the python is just there to turn it into a dictionary.\n\nThis doesn't work for negative numbers, which is a problem, since most programs use positive and negative numbers.\n\nIt does work for negative numbers, you just need to change the second line to be:\nl = [x for x in l if x % 2 == 0]\nAnd it should work fine. I've been using this code for a while to sort lists of numbers.\n\nAh, sorry, I missed that. Thanks!\n\nThis can be generalized to arbitrary lists with arbitrary keys (for all sorts of arbitrary types and values):", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    l.remove(0)\n    for i in range(len(l)):\n        if i%2 == 0:\n           return l[i]\n\nIs this really faster than using a dict?\n\nI had that same question. If you just wanted to get the positive numbers, you could just do:\nlist = ['2', '5', '6']\nfor i in list:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return list(1)\n    else:\n        return list(l[-1] + l[1])\nThis is not a good way to sort a list.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop('0')\n>>>\n\nPython's built-in pop() function returns the first element in a list, not the first non-negative one.\n\nThat's what I meant. In a list, it's the same thing as pop('0').\n\nI'm not sure I agree with the premise that you should not write a function to calculate the first negative number in a list. There are cases where this is useful. For example, one could say that all negative numbers are a subset of all positive numbers and hence one can write a function that calculates the negative number in a list given it's positive counterpart.\n\nTrue, but sometimes the first negative number is a degenerate case and you'd prefer to avoid it.\n\nThis is good stuff. I like it. It's a shame it's not written in C or C++ (or some other language with a little more oomph than Python). It'd be pretty easy to extend it with things like loop counters, and it would be a great way to get a lot of performance out of a simple algorithm.\n\nGood point. One can always write a C wrapper for it though.\n\nCould be a good exercise for someone to", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    positive = []\n    for i in l:\n        if i in [0, 1, 2]:\n           positive.append(i)\n    return positive\nThis is my code for the above problem. I don't know how to convert it to Python.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.index, reverse=True)\nThe functional programming equivalent of:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0\nAs others have said, it is not idiomatic Python to write functions that modify their arguments. Instead of writing get_positive, you can simply write a function that returns the length of the list and a function that returns the list with the first element removed. Then you can call them both like so:      get_positive_first(l)\nIt is idiomatic to write functions that modify their arguments. The iterator protocol is an example of this.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return sorted(l, reverse=True)\n    else:\n        return l\nNote that you need to sort first so you get an actual list instead of an unordered collection.\n\nIt's not that big of a deal to sort it first in python. You can even do this in the same function if you're clever about it.\n\nThere is no need to be clever.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n        return list.filter(item => item > 0)\nYou're returning a list of positive integers.  The result may or may not be equal to the original list.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # take the first list\n    l = [0]\n    # loop over the list (in order)\n    for i in range(len(l)):\n        if i % 2!= 0:\n            break\n           return l[i]\nThis is very similar to the Dijkstra algorithm.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return []", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(int(l[:]) for l in l)\n\nI think he's looking for something that requires less keystrokes.\n\n(defun positive? (l)\n(lambda (i) (integerp l i)))\n\n(defun positive? (l)\n(list (if (> l 0) i (- i l)))\n\n(defun get_positive (l)\n(list (if (> l 0) i (- i l)))\n\n(setq positive? (get_positive l)))\n\nHere's mine:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] > l[1] or l[0] < l[1]:\n    return []\n    return l[1:]\n\nI feel like this would be more idiomatic in Python 3, with it's support for \"unpacking\" lists:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    for i in range(len(l)):\n         if i%2 == 0:\n              return False\n          return True\n\nThis is interesting. I'd like to see a longer code example to understand how this would be used.\n\nIt's a pretty standard way of checking for the presence of something in a list. If you are filtering a list of numbers, you may want to return false if the number is negative, and true otherwise. If you have an array of colors, you may want to return a list of only the colors that you want, and return false if it is not on the list.\n\nAs others have mentioned, you can also just use it to return only positive numbers.\n\nWhat if you have a list of different numbers, and you want to return only the largest number, and return false if there are two numbers?\n\nI was wondering this too, so I tried it out:\n>>> def get_largest_positive_and_negative_number(l):\n...           if (not l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (x[1] > x[0])\nWhat's the point of `x[1] > x[0]`? Why not `x[0] > x[1]`? Or just return True if `x[0]` is not negative and False otherwise?\n\nI don't see the benefit of \"return True if x[0] is not negative and False otherwise\".\nThat seems like it would have a higher overhead than just checking the first number and using a bit shift if the first number is negative.\nIt's not always the best practice to do a bit shift.\nIf it's true that you're asking about the benefit of using bit shifting in this particular situation (and not always doing a bit shift) then I'd say it's because you can do it with a single integer multiplication (which is cheaper than a division) rather than needing two operations (a division and a subtraction).\n\nYou should never do bit shifting with a unary +, that's what the OP is doing.\n\nA lot of code examples in the documentation seem to use \"def\" instead of \"def __init__\" and \"def __cmp__(a, b):\" instead", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\nWhat's the point in returning the head of the list?\n\nThe point is to show that the author is a lisper :)\n\nIf you're going to do that, though, you should write in something with a proper lambda syntax.\n\nHeh, there's a tool called Numba which does just this: it's written in Python, but uses LLVM for the actual number crunching.\n\nI would have thought numba would be written in Cython rather than plain python.\n\nThere are some performance gains to be had by writing in Cython, but it's a lot of work for a little gain.\nI personally wrote my stuff in Cython because I knew I'd be using it in production and didn't want to spend time debugging memory management issues.\n\nI'm curious why you think that?\nThe main reason I use Numba is because it has been shown to perform better than other existing Python numerical libraries.\nCython is also excellent for speeding up Python.\n\nA small codebase like numba's (and mine, for that matter) will be bottlenecked by I/O and memory management more than by the Python core.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return [x for x in l if x > 0]\nCan't you just return it and let the user do the sorting?\nit's a good question, but I don't think so. It's just my way of thinking.\nI mean it's a small thing, but there's a difference between:\n       >>> get_positive([-1, 2, -4, 5, 6])\n       [2, 5, 6]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[::-1] for l in list]\nThis is equivalent to:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if isinstance(l, set):\n       return l[::-1]\n    else:\n       return int(l[::-1])\nThis is just a modified version of get_length(l).\n\nIt's also a prime number generator :-)\n\nI think it's better to put the tests in the function.\n\nNice.\nA better solution is to always use === instead of == for comparing numbers:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # Return list of positive elements\n    return l.filter(numbers = [n for n in numbers if n > 0] )\nThis is exactly the kind of obfuscation that made me realize I wanted to learn Python. I can't understand why the code is using a list for a function that returns a list.\n\nYes, using list in a function that returns a list is a bit \"obfuscation\".\nHowever, I think the reason is that the code may be using list as a stand-in for a list of any type, so it's easier to use list instead of introducing an even more complicated parameter type.\n\nThe use of a list is not obfuscation, it's a list comprehension.\n\nYes, that's what I meant by \"as a stand-in for a list of any type\".\n\nThere is a discussion on why not to do that:\n\nSomehow it missed this interesting piece of code:\n>>> def square(x):\n...        return x ** 2\n...\n>>> square(1)\n...", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\nThe description on that page is quite good.\n\nRight, it's a nice trick. In fact, there are a number of ways you could do this in Python. (I used list comprehensions in the example for a more compact expression.)\n\nAs the author of the article, I'm not entirely sure why you posted this link to HN. It's a nice trick, but I don't think it's something of interest to anyone except beginners.\nAlso, your example doesn't work as expected.\n\nHi, I did this to expand on a previous submission. I find this useful because it's a way of eliminating a special case.\nI get your point, it's not a new idea, but I thought it was a nice way to remind people of the power of list comprehensions.\nI'll correct the example.\n\nIn this case, the power of list comprehensions has nothing to do with it, so you might as well have done:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # test negative number\n    if l[0] < 0:\n       return [l[0] for l in l]\n    # else find 0\n    for i in range(1, l.size):\n       if l[i] < 0:\n          return [i for i in l]\n    return [i for i in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(l.pop(0))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum(l) == 1\nThis is a \"spiral\" version of the above. It works by stepping in on itself.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda i: i*i)\n>>>    get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[2, 3, 9, 5, 123, 1, -10]\n\nI'd much rather do this:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for x in l:\n        if x < -5:\n           return False\n        return True\nThis is essentially a version of lambda. You can do something like this:      return lambda x: (x < -5)  Note that this might not be efficient though.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    for i in range(len(l)-1):\n       if l[i]!= 0:\n          return l[i]\n    return l\nAnd this is faster than a single `list(l)` call?!\n\nThere's no reason to believe that either one is faster than the other. They just have different semantics and there are real reasons for preferring one of the two.\n\nThey have different semantics because list.get() is not lazy. That means that the code to get the first element of the list can potentially be executed multiple times depending on the input. I think the get_positive() is just syntactic sugar for a more traditional loop.\n\nIt could be lazy too. The behavior of list.get() is implementation dependent. In most cases it's lazy.\n\nThis is not lazy (and not the fastest way to get a positive number).\n>>> def get_positive(l):\n...   if len(l) == 0:\n...     return []\n...", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[1] > 0)\nI love Python.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x>=0)\nI like this one.  It's simple, and could be used in all sorts of places.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] >= 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    \"\"\"\n    return list(l.pop(0))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in xrange(1, l.size):\n        if l[i] < 0:\n            raise ValueError(\"negative number in list\")\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0\nI think this is much more concise.\n\nThanks, it's more concise and more idiomatic, I'll change it.\n\nLooks like a good project, I've been using a similar one called pypy-lib.\n\nThat's an interesting project, and it does some things better. My goal is to have a library for each task, so you don't need to go through the effort of combining them.\n\nI thought pypy-lib did this by abstracting over numpy and other libs?</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.pop() > -1)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [-1, 2, -4, 5, 6]\nI've got a similar function at work that returns the last non-negative value in a list.  I just call it pop().\n\nIn Python, -1, 2, -4, 5, 6 is a list, not an integer.\n\nThe Python equivalent of pop() would be reversed() (for lists).\n\nThe problem with reversed is that it returns the last non-negative integer, not the last non-negative list item.\n\nLast time I checked, reversed() is a list method, so it would return the last non- negative list item.\n\nYeah, it is. I was thinking of pop() which is an item method.\n\nI find it easier to use the built-in \"slice\" function in Python.\n>>> get_positive([1, -1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive(range(1, 6))\n[2, 5, 6]\n\nI'm surprised no one else mentioned this:\n>>> get_positive([-1, 2, -4, 5, 6])\n>>> get_", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n        # We need to check if the element is positive in the list\n        # if it is then return the element\n        if l.any(x: x in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10])!= False:\n           return l[x]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(set(l, +(l, -1)))\nHere's another way to do this, using the function \"set\" which is meant for sets of integers, but can be used for any data structure with a natural ordering. It's not as efficient as the code above, but it's also a lot easier to read.\n>>> def get_positive(l):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([5, 3, 2, 3, 9, 123, 1])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_positive([5, 3, -5, 2, -3, 3, -10, 0, -1, 1])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_positive([-1, -4, -5, 5, 3, -3, 2, 9, 0, 1, 2])\n    [-1, -4, -5, 5, 3, -3, 2, 9, 0, 1, 2]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return l[::-1]\n\nAs long as you are only using Python 2.6 you can just use range() or itertools.count(). For Python 2.5 and earlier you'd need to use int() to convert the result of range() or itertools.count() to an int.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x[1] > x[0])\nI think the first version is better - it doesn't change the length of the list.\n\nCool, I hadn't considered that.\n\nMore to the point of your original question, list comprehensions are a bit like an extension of normal list operations to arbitrary operations over multiple lists:\n>>> [x for x in range(0, 10)]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[x for x in (x for x in range(0, 10) if x > 0) for x in xrange(0, 10)]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n(the second form is useful if your function only returns one result, instead of a list of results)\n\nI prefer the style of list comprehension in python to the style of list comprehension in Scheme. In Scheme, list comprehensions have the form\n(if (or (eql x (list-of-values)) (null? x)) (eql (list-of-values)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: len(x) == 1, reverse=True)\n\nThis is why I like Python, it's obvious and straightforward.\n\nAnd Java:\nList<Integer> l = Arrays.asList(0, 1, 2, 3, 4, 5, 6);\nList<Integer> getPositive = l.sort(Comparator.comparing(x, x.length()));\n\nHow many more lines does that take?\n\nIt's easy to make it more terse.\nList<Integer> getPositive = l.sorted(Comparator.comparing(x, x.length()))\n\nYou could also use a pythonic list comprehension.\nList.get_positive(l)\n\nThis is also available in Python (version 3):\nl.sort()\nl.sorted(key=lambda x: x[1])\n\nI don't understand why people think this is a good example. It's not.\nFirstly, it's not a good idea to use built-in methods to do stuff like sorting. That is a function that you should be writing yourself. (Although you might want", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if l.count(x) > 0]\nThis would return all negative numbers too if l.count(x) > 0. You need to add a check for negative numbers as well.\n\nThanks for the pointer. I had that in an earlier version, but then I read somewhere that Python prefers to use lists rather than tuples, so I decided to go with the list version (because the code looks more like the built-in sort).\nI'll update the article to show both ways.\n\nI don't think that's a good excuse.\n\nI prefer the list version of this. I don't need to look up the sorting method in the docs to use it. I don't need to remember what it's called. And it's a lot shorter.\n\nIf only the function name was not so long.\n\nThe article calls it get_only_positives, but I prefer the shorter get_positive.\n\nI think this is interesting, but I do not think that \"list\" should be called \"tuple\" in Python. It confuses too many people. In Python 2.x, the built-in sort function is called \"sort", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > -1 else None for l in l]\nI know this is a pedantic comment, but I think it's worth pointing out:  You should always name your functions something meaningful.  Not only does it help others read your code, but it helps you think about what you're doing when you need to call them.  If you're just writing something quickly, then you can rename it later.\nI'm not the author, just posting the code for others to see.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(x>0)\n> import math\n> print math.sqrt(math.abs(2.0 - 1.0))\n> print math.sqrt(math.abs(4.0 - 1.0))\n> print math.sqrt(math.abs(7.0 - 1.0))\n> print math.sqrt(math.abs(12.0 - 1.0))\n> print math.sqrt(math.abs(16.0 - 1.0))\n>\n> print math.sqrt(math.abs(-1.0))\n> print math.sqrt(-math.abs(-1.0))\n> print math.sqrt(-math.abs(1.0))\n>\n> Now is there any way to get the sqrt of the sum of the squares of the first\n> n natural numbers?\n>\n> The closest thing I could come up with is:\n>\n> def sum_of_squares(l: list):\n> \"\"\"The sum of the squares of the first n natural numbers.\n>\n> >>> sum_of_squares([1, 2", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:-1]\nWhy?</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    \"\"\"\n    def get_negatives(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negatives([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [123, 1, -10]\n    \"\"\"\n    return [l[i] for i in range(len(l) - 1)]\n\nNegative numbers are not represented with an - sign in some programming languages.\n\nIn python, for example, you can create a list of integers that have a negative sign.\n>>> -[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]\n>>> -5, -3, -5, -2, -3, -9, 0, 123, -1, -10\n\nIs this a list of negative numbers? Or is it a list of positive numbers that have a negative sign?\n\nAre the negative numbers represented with an - sign, or with a 1?\n\nHere is the answer:\n>>> -(l).", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] % 2 == 0]\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([1, 2, 3])\n    [2, 3]\n    >>> get_negative([5, 4, 3])\n    [5]\n    >>> get_negative([-1, 2, 3, 4, 5])\n    [2, 3, 4, 5]\n    >>> get_negative([5, 4, 2, 3, -1])\n    [5, -1, 4, -2, 3]\n    >>> get_negative([5, -1, 2, 3, -4])\n    [5, -2, 3, -4]\n    >>> get_negative([-5, -1, 2, 3, -4, 5])\n    [5, -3, 2, 3, -4, 5]\n    \"\"\"\n    return [", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return (l[0]) if not isinstance(l[0], bool) else []", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] for l in l)\nIt might be more clear if you use a list comprehension instead.\n>>> [5, 3, 2, 3, 9, 123, 1]\n[5, 3, 2, 3, 9, 123, 1]\n>>> [x for x in [5, 3, 2, 3, 9, 123, 1]]\n[5, 3, 2, 3, 9, 123, 1]\n\nPersonally I don't find list comprehensions any easier to understand than this code.\nThe advantage of the comprehension is that it is one line instead of two, and it is slightly easier to type.\nBut that's it.\n\nI agree. Also list comprehensions are not well suited for illustrating a point, IMO. It's difficult to tell what is going on.\n\nlist comprehension is better suited to demonstrate the fact that it is using map, filter and reduce.\n\nOops. I forgot.\nI think the main thing to take from this code is that the only thing it does is remove the negative numbers, and you can do that with a map.\n\nBut list comprehension is cleaner.\n>>> [x for x in", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\nThere is no reason to do this by hand, as there are many freely available tools for solving this problem:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in l:\n       if i > 0:\n         return i\n\nThis is an interesting solution that took me a minute to figure out.\n\nI think the solution is too slow, is this correct?\n\nI think it's the right answer but you might be able to make it faster if you precompute some values.\n\nI haven't found a faster solution but I found a more elegant one.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] > 0:\n       return l[1:]\n\nI like this better:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(l:l.pop())\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, 3, -3, 2, 9, 0, 123, 1, -10]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, -3, 3, 9, 0, 123, 1])\n    [5, 9, 3, 2, 3, 123, 1]\n    \"\"\"\n    return list(l:l.pop()).reverse()\n\nI would have just used sorted() and reversed() as per the usual approach.\n\nI wasn't sure if that worked on lists of all integer types.\n\n`sorted` does work on lists of all integer types.\n\nJust to add to the general discussion, here's the \"Python\" version:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0]) < 0\nI'm a beginner too, but I feel that the return statement should be outside the if statement.\n\nYou are right.\nThanks.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > 0 else l[0] for l in list]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.index[1] > 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return np.where(l.size > 1, 1)\nYou should probably make `np.where` a function instead of a list.\ni was thinking that myself but i didnt know how to do it", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nI don't understand what this is doing.  Is it simply removing all the negatives?  Because that's trivial.  If you want to remove the negatives, you just need to go from 1 to the length of the list, and check each element.  The length of the list is the total number of elements, and you can remove the negs with a simple if statement.  There's no need for a function.\nI was giving an example of how you might use the function. It takes a list of integers and returns only the positive ones.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l[::-1])\nThis is the correct answer.  It is the first function in the given code that actually does what is asked of it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x > 0]\nThank you! I have been trying to figure that out for a long time!\nI got the same error when I tried to use it in a list comprehension. Is there a way to get a list comprehension to accept a function as the last argument?\nYes, I'm sure you can, but I'm afraid I can't be of much help since I've never done anything like that.  I'd suggest you try searching for \"list comprehension with function\".</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i, n in enumerate(l):\n        if n > 0:\n           return n\nThat's not much better.\n\nThe next version (for the benefit of those that don't see the code in the article)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for n in range(len(l))[::-1]:\n       if n%2 == 0:\n         return True\n    else:\n         return False", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(i) == i\n    and l.endswith(0)\nYou could try something like this: \nreturn lambda x: x - 1\n\nThat's exactly how I would do it, too. It's the same algorithm as the post, except using negative numbers instead of zero.\n\nPersonally, I would use this:\nreturn lambda x: x < 0? x - 1 : x\n\nYes, that would work if you only wanted positive numbers. However, the OP wanted to only return the positive _remainder_ of a list. This way will not do that, it will only return the positive number itself.\n\nThat's true, but wouldn't the above code work with a single number as well? Or would it return NaN?\n\nIt will return NaN, because the method returns either a value of type int, or it returns None.\n\nIt's funny how a lot of problems that occur in programming seem to be related to over- thinking the problem.\n\nI agree. I've only been programming for two years and this is something I've noticed. A lot of my code is very simple.\n\nI think the", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a: a[1] > 0, reverse=True)\nThanks for the response, but I don't think this would work in my case, since I need to check if the number exists in the list, not if it's positive.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(i => i >= 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\nThis is not correct.  This code will also return negative numbers.  The only way to get only positive numbers is to use either a list comprehension or an if statement.  EDIT:  I'm not trying to be a jerk here, I'm just trying to help the OP learn.\nWhat's your definition of \"correct\"?  This is a really old programming joke.  I thought it was obvious that this was a joke.  If it isn't, I'll edit my post.  I'm not trying to be a jerk here, I'm just trying to help the OP learn.\nYour edit to your post was not there when I made my comment.\nNo problem, I should have added it earlier.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0\nIf it's for a class assignment, you should always post the full code rather than the relevant snippet.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        return sorted(l, key=lambda x: x[0] if x[0]!= -1 else x[0] + 1 for x in l)\n\nYou're not allowed to use return in a function definition. It's a call to the function.\n\nI think he may have meant \"return [the list of positive numbers in the list]\"\n\nI don't think he did, because he's not returning anything from the function. He's returning from the lambda, which is something that the function _uses_.\n\nThis is the most amazing thing I've seen on HN in a long time.\nI love the idea of writing a function in one language (Python) and having it run in another (Java). I can't wait to try it out.\n\nWhat about people who don't know Java?\n\nI don't know Java, but I do know a little python. I think it's a great way to introduce someone to a language, or to find out if it's worth trying to learn a new language.\n\nI like this as a 'what if you could write your python code in", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # Normalize the list, removing any negatives.\n    for x in range(0, len(l), 2):\n       if l[x] > 0:\n           l[x] = 0\n    return l[0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    list.remove(l.index(0) for l in list if l.isdigit())\n    return list\nI think you have an off-by-one error there.  You start with (l.index(0) for l in list if l.isdigit()) then remove (l.index(0) for l in list if l.isdigit()) and then return list.  Should be (l.index(0) for l in list if l.isdigit()) then return list.\n\nThanks, fixed!\n\nI'd recommend using some sort of linter, like flake8, to spot these kind of errors. It will also spot possible memory leaks and other potential problems.\n\nI'm using PyFlakes (it doesn't work with PEP8), but it still doesn't catch my typos!\n\nJust in case you don't want to run pyflakes for every change, it's possible to set it to just run on save. Here's how I set mine up:\nEdit your.flake8rc file:\n\\---\n[flake8]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    list = [0]*l\n    for j in range(len(list)):\n       if list[j] >= 0:\n           list[j] += 1\n    return list\nThis doesn't scale well to lists with a large number of items though.\n\nThis is true. The function is part of a larger program, so it won't be called with large lists.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for elem in l:\n       if elem not in xrange(1, -1, 1):\n          return -1\n    return elem", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if l[i] < 0:\n           return False\n        return True\nI am no python guru, but I don't like this as much as the one in the article. I know its a little longer, but there is a big difference between \"return True\" and \"return l[i]\". The first one is just plain ugly.\n\nAgreed, but I'd go further: There's a big difference between \"return True\" and \"return not None\".\nThat is, it's not just ugly, but unidiomatic to return a boolean.\n\nIsn't that what \"return False\" does?\nreturn True if true else False\nYou don't have to return a boolean, but \"return True\" does return a boolean.\n\nSo does \"return False\", but that's not what I meant.\nI meant that returning a boolean is not idiomatic. For example, the whole \"if return True\" thing I don't like.\n\nOh, I see what you mean.\n\nI usually prefer to write my", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.values, key=lambda x: x > 0)\nI always like to see different solutions, but I find your solution to be faster and more readable.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return l[::-1]\n\nI don't understand what you're doing here.\n\nI don't understand what you're doing here.\n\nI don't understand what you're doing here.\n\nI don't understand what you're doing here.\n\nI don't understand what you're doing here.\n\nThis is a really great article. I have a question though:\nWhat if I wanted to say in the get_positive function, \"return the last three digits of the list, if they are positive\", how would I do that?\n\nYou'd probably have to write it out as a nested loop, and if you need the full four digits, then you'd have to go back to the first loop and return the first three digits.\n\nYeah, I see what you're saying. It's still a little different than what I had in mind.\nI really just wanted to find the last three digits, for example, if I had a list of positive numbers, I could write out a function that could say, \"return the last 3 digits, only if they are positive\"\nI think that could be a neat little function to have.\n\nThis is called filtering:\nThe", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [1, 2, 3, 4, 5]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def get_padded_positive(l: list):\n    \"\"\"Return padded (pos) numbers in the list.\n    >>> get_padded_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_padded_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [l[:-1], l[1:] + l[2:] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l: has_key('positive'):\n       return (l[0])\n    return l[:]\nThe is just list comprehension.\n\nThis one is much simpler to read in my opinion:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for x in l:\n       if x not in [0, 1, 2, 3, 4]:\n         return None\n    return x\nThis is the best algorithm. And it can be implemented in under 10 lines of code.\nYou can stop at \"return x\".\nThe first if-condition should be an else-clause instead.  The second if-condition should also be an else-clause.\nI actually meant that. I'm too used to Python and the \"elif\" thing.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return []\n    positive = []\n    for a in l:\n        if a > 0:\n           positive.append(a)\n    return positive", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[::-1]]\nI had to stop and think about this. It's a list of lists of integers. It's not a list of integers.\n\nI've never understood the benefit of this kind of post. You could have just as well posted a link to the Python documentation:\n\nI had to stop and think about this. It's a list of lists of integers. It's not a list of integers.\n\nTo be pedantic, it's a list of lists of _int-like objects_. It's not a list of integers.\n\nIt's a list of integers that can be safely converted to integers at the point of evaluation.\n\nIt's a list of integers that can be safely converted to integers at the point of evaluation _in Python_\n\nPython doesn't have integers. It has int-like objects.\n\n\"2\" is an integer, even in Python. If you declare 2 as a string in Python, it's still an integer.\n\nThe python module `int` declares the type of the integer literal \"2\" to be \"int\". The type of the integer literal \"2.0\" is also \"int\".\n\nIn a statement", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] + l[1]) > 0\n\nCute! I'm not sure it's better than either of the C or Java, though. There's a bit of syntactic overhead from the indentation and parens, and it doesn't seem as readable or as well-documented (since there's no comments to explain what each little function is doing).\n\nit's not about being better than the C or Java version. it's about being better than the python versions.\n\nYou're right, I should have said \" _I_ don't think it's better than either of the C or Java, though.\"\n\nThere's no reason to put \"list\" in front of \"list\" in the Java one, and no reason to put \"list\" in front of \"l\" in the Python one.\nThis is a fine example of the kind of code that a good compiler can optimize out, but a mediocre one cannot.\n\nMy major complaint is that Java makes it so much more difficult to reason about the correctness of your code than Python does. I understand that this is not what the article is about.\n\nPlease don't use Python's list notation for C's void", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return l[::-1]\nThis is what I like to see here. If you need to know why this is a bad idea, post it here and explain it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    for i in range(1, len(l)):\n       if i % 2 == 0:\n          return i\n    return [None]\nThis is why you should always use sum() to check if a list is positive...\n\nWhen I was a CS undergraduate, I used to make a point of using the \"real\" operators where possible, partly because it was easier to remember (like, really, who remembers to use the fact that `0 - 0` is 0, and `0 - (-1)` is (-1)), and partly because it helped me internalize the semantics of each operator.\nIt's amazing how many people I've met over the years who don't realize that `-` is a unary operator, or that `-` means \"not,\" or that `*` means \"times.\"\n(No, I'm not joking, I really have met programmers who didn't know this.)\n\nI use sum() for checking if a list is positive, and 0 - 0 for checking if a list is negative.\n\nWhy would you use sum() for checking if a list is positive, and 0 -", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.index(0) + 1) < 0.\n\nNow, I tried to convert this to a lambda, but I get an error when I run it.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: int(x[-1]))\nI like this one, nice and simple. I don't know how to implement it though.\n\nI like that it's a one-liner, but I don't like how it's written:\nreturn sorted(l, key=lambda x: int(x[-1]))\nIt's confusing, and has to be read more than once to figure out what it's doing. I prefer:\nreturn sorted(l, key=lambda x: int(x[-1])[:-1])\nThat way, when I read it, I think of \"sorted\", then \"key\", then \"int\".\n\nAs a non-python programmer, I'm really confused by your example. I thought\nsorted was an overloaded function, and I'm not sure how you can make the second\nversion without the \"sorted\".\n\nYou can pass multiple arguments to the function as an array. So in the first case you're telling it to take the list `l`, and use `sorted` to sort it. Then it passes the sorted list as a single parameter to the key function.\nIn", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] < 0 else -1 for l in l]\nThis is a great function. I need to use this in a number of places in my code. Thanks.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(range(l[0]))\nI'm fairly sure you're being facetious, but I'd like to point out that your list comprehension is just a specific case of range(list(range(l))).\nrange(list(range(l)));</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.count()[0])\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([1, 2, 3, -4, 5, 6, 7, 8])\n    [3, 5, 6, 7, 8]\n    >>> get_negative([5, -4, -3, -1, 0, 6, 7, 9])\n    [0, 6, 7, 9]\n    >>> get_negative([9, 0, 1, -2, 2, -1, 3, 5])\n    [1, 3, 5]\n    \"\"\"\n    return sorted(l.count()[1])\n\n(This was the example used in the article that was submitted here a couple of days ago).\nI've found that I frequently write code like this that reads really, really well. I wonder if there's a name for it or if it's just a really good design pattern that I keep reusing.\n\nIt's an example of the \"Chain of Responsibility\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l: list is not None:\n        if len(l) == 0:\n           return l\n        else:\n            return l: pop(l)\nI have this problem where I need to take an integer, and break it into a string of digits, then repeat them in order.\nYou're welcome to use mine: \n\nI am not sure if this is what you are looking for, but I find\nto be incredibly useful.\n\nIt's good if you need to do this once. But if you need to do it often, you are better off writing a function to do it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return set(l, c for c in range(0, len(l)-1))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in l if not (l[1] == -1 and l[0] > l[1] and l[0] < l[1] and l[0] < l[1] and l[0] > l[1] and l[0] <= l[1] and l[0] <= l[1] and l[0] <= l[1]]\nPython is such a beautiful language.\nI can't believe it's been almost 10 years since I started learning it. And I've been writing Python full-time for about 3 years now.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\nThis isn't a solution, it's a copy of the problem.\nIt's not a solution unless you make it run in constant time.\n\nIs that actually the problem being asked? Or is it instead:\n\"given a list of positive integers, return a copy of the list with the negative numbers removed\"\n\nEven if this is a problem you are asked to solve, you shouldn't write a function that runs in O(n). Instead, you should think of a clever way to solve it in O(1).\n\nYou can't.\n\nIs that an interesting challenge? If not, then maybe we don't care for O(n) solutions.\n\nNo, it's a stupid challenge. It's like asking you to write a function that removes the \"even\" numbers from a list without using any other value.\n\nThat would be a stupid challenge. This is not.\n\nFrom the problem description:\n_You can 't use set operations or any other method to rearrange the list._\nThat's why it's a stupid challenge.\n\nThat's a good challenge, but the poster I was replying to didn't have that information.\n\nIf you're looking for a more", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (x < -1) and (x <= 0) and (x >= 2)\nWhat's wrong with that?\n\nI think the mistake the OP was making was to not realize that the range of x is 1 to 10. And that the range of get_positive is (-1, 0).\nIf the range of x is 1 to 10 then you get only the numbers 2, 5, and 6 from get_positive.\n\nBut the error in the question was asking for an incorrect solution. If x is 1 to 10, then the range of get_positive is (1, 0).\n\nI think you both missed the point.\nLet's just say that x is an integer between 0 and 10.\nget_positive takes a list of integers between 0 and 10. return(x) takes one integer and returns a boolean value.\nget_positive takes a list and returns a boolean value. And we are to assume that the user wants to get the positive ones.\nWell, the user does not want to get the positive ones. He wants to get the integers between 1 and 10. Not the positive ones. That's why he didn't pass 0. He passed 1. If he wanted", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in list if l[0] < 1]\nThank you! I knew it had to be simple.\nIt's not just simple. It's the least time-consuming solution.  But you can make a few things even faster. For instance, you can use typecasting to get rid of the first two lines of the loop.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    l = list(range(1, l.size))\n    for i, val in enumerate(l):\n       if (val > 0):\n          return i + 1\n\nBetter:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def get_even_positive(l: list):\n    \"\"\"Return only even numbers in the list.\n    >>> get_even_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_even_positive([5, 3, -5, 2, -3, 3, 9, -10, -5])\n    [5, 2, 3, 9, 123, -10]\n    \"\"\"\n    def get_even_negative(l: list):\n    \"\"\"Return only even numbers in the list.\n    >>> get_even_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_even_negative([5, 3, -5, 2, -3, 3, 9, -10, -5])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\n    if not l:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] == -1:\n        return [0]\n    if l[1] == -1:\n        return [1]\n    if l[2] == -1:\n        return [2]\n    if l[3] == -1:\n        return [3]\n    if l[4] == -1:\n        return [4]\n    return list(map( lambda x: int(x), l))\n\nThere is a more clever way to do it:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    positive = 0\n    for i in range(len(l)):\n       if l[i] > 0:\n          positive = i\n    return positive", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if not isinstance(l, list):\n        print(\"get_positive() requires a list-like object.\")\n    return []\n    return [l[0]]\nOr is there a reason for this?\n\nIn python, lists are lists and lists are not lists. If you want to use a list as an integer index, you need to use the `list()` function. If you don't want to, you need to use the `list` type.\n\nThis is not true.\nYou can use the `list` type to get the index of a list as an integer. But you can also use a list as an integer index, so long as it's not the _first_ element of a list.\n>>> [1, 2, 3, 4]\n[1, 2, 3, 4]\n>>> [1, 2, 3, 4]\n[1, 2, 3, 4]\n>>> [1, 2, 3, 4]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list() takes exactly 2 arguments (1", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        l = []\n        return l.pop(0)\nI get that you are trying to write a pythonic solution, but I think that's a tad long. In my opinion, you should try to make the function as short as possible. This also makes it more understandable.\nTry something like this:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    \"\"\"\n    \"\"\"This is a generalization of the 'get_positive' function.\n    >>> get_positive_one(1, 2, 3, -4, 5, 6, 8, 9, 10)\n    [2, 3, 6, 9, 10]\n    >>> get_positive_two(1, 2, 3, -4, 5, 6, 8, 9, 10)\n    [3, 6, 9, 10]\n    >>> get_positive_three(1, 2, 3, -4, 5, 6, 8, 9, 10)\n    [6, 9, 10]\n    \"\"\"\n    for l in range(l.size()):\n       if l[0] == -1:\n         return False\n       else:\n         return l[0] == 1", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    for item in l:\n        if item > 0:\n           return item\n    return []\nOne thing that is bothering me about this is that it doesn't handle lists\nthat are missing values. It works fine for a list of lists. But,\nfor example, this doesn't work:\n>>> get_positive([[], [0, 1, 2], [1, 2, 3]])\n[2, 3, 0]\n>>> get_positive([[], [1], [2], [3]])\n[2, 1, 3]\nHere, we get a list of lists of lists of lists. The list [], of\nlength 0, is ignored.\nThis is trivial to fix. But, I'm not sure what the right behavior is.\nI think that the behavior above is right. If you have a list of lists\nand you want to get the positive numbers only, you should do something\nlike this:\n>>> get_positive([[], [0, 1,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum([x for x in l if x!= -1])\n\nNot sure about Python, but in R, this would be more idiomatic:\n> library(reshape2)\n> library(reshape)\n> mean(l) # mean(l) is the mean of all the elements in the list\n>\n> # reshape2(l, mean(l)) # reshape2(l, mean(l)) is the mean of all the elements in the list after sorting them\n>\n> # reshape(l, mean(l)) # reshape(l, mean(l)) is the mean of all the elements in the list after sorting them\n\nThe R implementation would not work, as `l` has different types in the two calls to `mean`. The R interpreter would complain that reshape2 is being called on a matrix, and reshape on a vector.\n\nI had to read the comments to figure out that it was using the function sum() instead of summing the list of numbers.\n\nI'm not sure I understand why this is an improvement over:\nfor x in range(len(list)):", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return list(l[0], l[1])\n\nIf I understand this correctly, what it does is take all the items in the list and if any of them are negative it returns the first two.\n\nThis is exactly what it does. It may be more convenient to use the operator \"\" for this operation.\n\nWhy is the coder adding a return to the end of the function, like it does for the other operators?\n\nI think it's for clarity and consistency. There's no other operator that has this kind of return behavior, so it's a little weird if the function doesn't have the same behavior.\n\nThat's an interesting way to use a bit of \"magic\" to make it more obvious to the reader what's going on.\n\nDude, I am a bit of a python newbie, so this might be a dumb question.\nBut, why do you say that \"get_positive(l: list):\" is a bad way to name the function?\n\nThe use of the colon in the name is a little odd.\n\nI agree, colon is not a python keyword.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return [0]\n    else:\n       return []\nNote the return.\nTo get the result, you need to go to the next step, and that's what      return l.get_positive()  does.\nThis is the lazy evaluation, the function only calculates the result when it's needed.\n\nThe same code would work with a list of strings:\n>>> print get_positive('abcdefg')\n[0, 1, 2, 3, 4, 5, 6]\n\nYou're probably thinking that \"return [0]\", \"return []\", and \"return list(l)\" do the same thing. They don't.\nA list (a type of Python list) contains an empty tuple. \"return list(l)\" actually returns a tuple.\n>>> l = [1, 2, 3]\n>>> l\n[1, 2, 3]\n>>> l.tup\n[<type 'tuple'>]\n>>> l = [1, 2, 3]\n>>> l.get_positive()\n[0, 1,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    \"\"\"\n    for number in list:\n         if number not in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]:\n             raise Exception(\"invalid number!\")\n         return number\n    return []\nI prefer this:      def get_positive(l):", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def negative(l):\n    \"\"\"Return only negative numbers in the list.\n    >>> negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [9, 0, 1, -10]\n    \"\"\"\n    return sorted(l.values(), key=lambda x: x.is_negative())\n\nThis is a textbook example of how to write a bad algorithm. This implementation has a critical flaw: It is not stable. A \"stable\" algorithm is one in which the same set of positive numbers always returns the same set of positive numbers. If you change the order of the numbers, you get a different result.\nThe same problem arises with the negative version of the algorithm. The worst part is that if you're using this code in a real application, it might work just fine. But there is a definite possibility that it will, at some point, fail in a way that is difficult to debug.\nHere's a better version", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:len(l) % 2]\nThis is exactly what I was looking for! Thanks!</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n    def get_sum(l: list):\n    \"\"\"Return the sum of all numbers in the list.\n    >>> get_sum([-1, 2, -4, 5, 6])\n    6\n    >>> get_sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    30\n    >>> get_sum([1, 0, 0, 1, 0, 0, 1, 1, 0, 0, -1, 0])\n    1\n    \"\"\"\n    return sum(l)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    for i in range(len(l)):\n       if (l[i] > 0):\n          return l[i]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] in l\nThis solution always returns a nonempty list.  You may want to modify it to return the empty list if l is empty, or if it's not, return every number in l.\nAlternatively, you may want to accept the list to be negative too.  This would be more general and might be more useful for some people.  For example, you could use this to find the divisors of a number.\n\nAh yes, I was just using this as a problem to practice writing idiomatic Python, but in the real world you'd be correct. I've changed it to return an empty list if l is empty. Thanks!\n\nI also added another, more useful solution to this problem.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if isinstance(l, List):\n       return len(l) > 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    x = []\n    for i in l:\n        if i!= 0:\n           x.append(i)\n    return x\nTo this point, is there anything you can do with negative numbers?  We're just going to ignore them.  Also, we're not going to worry about how to tell the difference between the integers 0 and -1.  Finally, we're not going to try to distinguish between the integers -9 and -10.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in l:\n       if i % 2 == 0:\n          return i\n    return None\n\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [3, 9, 0, -3, 1, -10]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [0, 1, -5, 9, 123, -3, -10]\n    \"\"\"\n    for i in l:\n       if i % 2 == 1:\n          return i\n    return None\n\n    def get_number(l: list):\n    \"\"\"Return the first number in the list.\n    >>> get_number", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.count() == 0:\n        return None\n    else:\n        return l.pop(0)\nI think this is pretty cool, I just wanted to point out that `l.pop(0)` will return the last element of the list, not the first element.\n\nYes, it will return the last element of the list. That is the point.\n\nI don't know if this is what the OP was trying to say, but the first element is the element at index 0, not the last one. I think it would be clearer if you said \"the first element in the list\", but that might be pedantic.\n\nNo, it's not pedantic. Saying the last element of a list is not the first element is the same as saying the first element in a sorted list is not the last element.\n\nLists are generally zero-indexed, so that's a bit of a weird statement.\n\nI think he's referring to the fact that it's not necessarily the first element of the list.\nI'm not sure if that's what he's trying to say either, but", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n       if l[i] > 0:\n         return l[i]\n\nAh, so this is the article that was referenced in \"A thought for you, A Programmer.\" by Randall Munroe.\n\nYes, and I'm glad to see it. I had been looking for this, and it was one of the first things I tried. I remember the other day I was playing with the list.index() method and I found it's behavior pretty weird.\n\nBut:\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n\nI think the list.index() returns the position in the list, which is not necessarily the same as the position of the element in the list.\n\nIt does.\n>>> [1, 2, 3, 4, 5, 6]\n[4, 3, 6, 5, 1, 2, 1]\n>>> list.index(3)\n3\n>>> list.index(3) == list.index(4)\nTrue\n\nThis is", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    pos = 0\n    for i in range(len(l)):\n        if i in l:\n           pos += 1\n    return pos\nOf course this is a slightly contrived example that is not really an\nissue in practice. Most of the time you want to return the *first*\nmatching element, not the *only* element. So you'd use some form of\niteration like the following instead:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (x for x in l if x % 2 == 1)\nThis is the only one that took me longer than a second to understand.\n\nI think it's good that people are having trouble with this.\nIt's a simple algorithm, but it's not obvious how to write it in terms of \"for loops\" and \"if statements\", which is what people tend to think of as \"the right way\" to write code.\nAlso, your one-liner has a bug: it returns -1 instead of -2.\n\nYou are right, it has a bug. I am not sure if it is a bug in my code or in the original one-liner though.\n\nI have a theory that if I can't read it in less than a second it's not that good. And I don't have a CS degree.\n\nGood example of the importance of comments: I read it in less than a second, and I still have no idea what it does.\n\nIt converts a list of integers into a list of positive numbers.\n\nI see, but what's the list of integers representing?\n\nSorted lists of integers.\n\nYup, I figured that out.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (any(l > 0 for l in l) or any(l in (-l, 0) or\n    (l in (-l, 0) and l < 0)) or (any(l in (-l, 0) or l > 0)))\n\nThe error in this code is that negative numbers in the input list get converted to positive numbers, even if they are sublists of the input list. For example, if we have\n[4, -3, -5, 2, 1]\nthen the resulting list is\n[2, 5, 6]\ninstead of\n[2, -5]\nThe author wanted to return only positive numbers in the list, not just the input list.\nThe solution is to use is negative.\n>>> get_positive_with_negative_conversion(['-3', '-5', '2', '1']).\n[2, -5]\n\nYes, that is correct. However, I think the author was going for the reverse - convert a list of positive numbers to a list of the individual numbers (with duplicates removed).\n>>> get_positive_with_negative_conversion(['2', '5", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l == 0) and (l > -1)\nI'm not sure why but I have the impression that this is the opposite of what the OP asked for.\n\nIt's close but not exact. I think the OP wants to find all the \"negative\" numbers that are really positive, not just any positive number.\nFor example, \"9\" is negative, but \"9\" is positive.\n\nYes, that's what I meant.\n\nI wrote this in less than an hour for something I was working on a few months ago and it has come in handy a few times since then.\n\nI would advise the use of a relational database such as Postgres, if your requirement is to store a list of numbers, and if you wish to query the list of numbers in a given direction.\nExample of query:\nselect count(*) from numbers where the number is greater than or equal to 1\n\nThis is a great idea. I'm going to check out the documentation for that.\n\nA list comprehension:\n[x for x in list if (not x.is_negative)]\nor\n[x for x in list if (x.is_positive or x.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    val all = [x for x in l if x > 0]\n    val pos = all.pop(0)\n    if pos is None:\n        all = l\n    return pos", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.startswith('-':\n       return l\n    else:\n       return get_positive(l)\nThis is way simpler, you don't have to use a list comprehension.\n\nthat is good. i can see how it is simpler.\nbut is it shorter? i'm not sure how it compares, but the comprehension is a single line.\n\nWith a list comprehension you have to do a variable lookup. If you make the function local to the comprehension, it's a single line.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return l[::-1]\nIf you use list comprehension (ie. in a for loop) the for loop will terminate on a NaN value, since its last expression is a for loop. To avoid that, you can use a generator function, or a list comprehension that doesn't end with a for loop.      get_positive = lambda l: l[::-1]\nThanks, that works. But I'm not really sure why the for loop terminates on a NaN value though. I thought that as long as the code is in an enclosing scope it will never have a chance to become NaN.\nIt's because you have an expression (the for loop) within an expression (the call to get_positive). You can't have an expression within an expression, so the for loop has to be in an enclosing scope.\nOh, I get it now. Thanks for the explanation.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(list, key=lambda x: x[1] >= 0)\nAlthough the original python solution is more concise, I'm not sure I'd want to be coding in a language where a relatively simple and common operation like this has to be implemented as a function.\n\nI would. That's why I like Python.\n\nI don't think there's anything wrong with function programming, it's just that there's more than one way to get the same thing done. If I want to have a collection of positive numbers, I might do this in Python:\nnumbers = [x for x in range(0, 9) if x > 0]\nThis is a function, but I think of it more like a method.\nI would never write the sort example as a function (but then, I don't really use Python, so maybe that's just a Python thing).\n\nJust to be clear, the example in the article is not the shortest Python solution possible.\nThe author is using \"sorted\" instead of \"key\". The latter is shorter.\n\nNot just shorter, but in Python you _have_ to use sorted in this case, since it is built into the type system", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[-1] > x[0])\nThat's really cool, but how is it different from [5, 3, 2, 3, 9, 123, 1]?\n\nThe list is not sorted. The list is sorted in the sense that it's been partitioned by the function into a set of negative numbers and a set of positive numbers.\nThe difference is that, if you wanted to sort a list of numbers, you might use sort(). But, if you wanted to sort a list of strings, you might use string.lower().\n\nWhat's the difference between a sorted list and a sorted set?\n\nYou can sort a set and still have some of the elements left unordered. But you can't sort a list and have some of the elements left unordered.\n\nMakes sense. Thank you!\n\n_Note: This function is based on this function_\nThis is a wonderful example of how to give proper credit to the original source (and I bet the author is grateful).\n\nThanks :)\n\nNicely done. I'm not sure I'll actually use it, but I'm glad I read it.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return []\nThis doesn't take into account the order in which the elements are generated.  If you replace it with this:        return int(l.pop() % 2)\nand remove the line       return []  from the loop, it will work as expected.\nYou can also use the built-in `int(x%2)` function if you prefer.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for l in list:\n       if l[0] > 0:\n          return l[0]\n    return []\n\n    def get_negatives(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negatives([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negatives([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    for l in list:\n       if l[0] < 0:\n          return l[0]\n    return []\n\nimport itertools", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()[::-1]\nAh, someone has a good understanding of python's internal arrays,\nthey've used list comprehension to make their code more concise, and\nthey've used the magic method `pop()` to do the right thing.\n\nThe more concise version is to use itertools.count(), which returns the\nlength of a list, but always returns None if it is empty.\n\nThe best way to find out if an empty list is empty is to iterate over it\nand see if it ends. Using itertools.count() is just giving in to the\nlaziness of the language.\n\nYeah, I hate it when I take the time to write something that works well and is fast, and then somebody else comes along and does it with a single function call.\nIt's like they're stealing my work!\n\n\"take the time to write something that works well and is fast\"!= \"write a list comprehension\"\n\nWhat I meant was that taking the time to write a list comprehension is better than writing a function that uses itertools.count, not that list comprehensions are better than functions.\n\nJust as a side note", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for e in l:\n        if e!= -1:\n           return e\nThis seems to be broken:\n>>> get_positive([1, 2, -3, -7, 5])\n[1, 2, 5, 7]\n>>= is assignment so you can't use it here. It will probably work if you change it to:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop, key=lambda x: x%2==0)\nAh, what is the difference between the two?  Is one faster?  What's the difference between sorted and sorted(l.pop, key=lambda x: x%2==0)\nThe difference is that sorted(l.pop) returns the elements in sorted order, whereas sorted(l.pop, key=lambda x: x%2==0) returns the elements in the sorted order, with the keys of those elements being the result of the lambda expression.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    for item in l:\n        if item not in list(self):\n           return item\n    return [item]\nLists are always ordered so it seems silly to do this in an if statement.\nIn general, when you have the option to make a code block shorter, less readable and/or more error prone, you should do it.\n\nI agree about making code shorter, but I'm not sure what's less readable about that code. In fact, it's pretty similar to the solution in the article.\nI think the reason for the if statement is that he's writing it in Python. A C++ equivalent would be to use std::find_if.\n\nMore readable:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return l\n    else:\n        return max(l, get_positive(l[:-1],))\nLists are 0-indexed.\n\nPython's list are 0-indexed. Lists can be used in all sorts of contexts where they are not 0-indexed, e.g. in a dictionary, in a list comprehension, in a list comprehensions of a list comprehension.\n\nYeah, but this is a _function_, and the function has to do one thing: return the items of a list.\n\nI like the name \"get_positive\". I've been thinking about a project that involved lots of positive numbers, so the first thing I thought was \"Oh, that's a handy function!\".\n\nThat's a perfect example of what I meant by \"The function has to do one thing: return the items of a list.\" The name of the function is irrelevant to it's purpose.\n\nI have a long list of negative numbers and need to pick out the positive numbers. The function does that. The function's name is _perfect_ for its purpose", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0]>0) and l[1]>0\nI think you need to modify the function to keep the higher power of 2.  So if you have a list containing 5, 2, 3, 1, and 9, the function would return the first three.  I don't know enough about python to know if that's even possible though.\nI guess I could do this as a pre-step, i.e. make an extra list of 2s and 3s and then if the first element is smaller than 2 or 3, remove it, otherwise keep it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n                return l[1:]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return lambda x: x > 0\n> list(map(get_positive, [1, -1, -3, -5, 3, 5, 9])).sort()\n> [\"5\", \"3\", \"3\", \"1\", \"1\", \"2\"]\n>\n> However, I need to return negative numbers as well.\n>\n> What is the function name for that? I've been searching for it for\n> a while now but it's hard to google since \"positive\" and \"negative\"\n> both return many results.\n>\n> Thanks for your help!\n>\n>\n\n[-- Attachment #2: Type: text/plain, Size: 5643 bytes --]\nOn Jan 27, 2010, at 4:21 AM, Bob H <bob@...> wrote:\n> def get_positive(l: list):\n> \"\"\"Return only positive numbers in the list.\n>\n> >>> get_positive([-1, 2, -4, 5, 6])\n> [2, 5, 6]\n>\n> >>> get_positive([5, 3, -5, 2, -3, 3, 9", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nWhat is the advantage of this over removing the 1st element?\nOne advantage is that this is also Python 2.x compatible, if you want to use this as a function in a script that is not Python 3.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # Build a list of tuples of numbers.\n    r = [[-1, 2, -4, 5, 6],\n    [5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]]\n    # Keep only the first two.\n    n = len(r)\n    # Take the first two from each tuple.\n    for i in range(1, n):\n       if r[i] > -1:\n          n = n - 1\n       else:\n          n = n\n    return n", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def is_positive(x):\n    return not x in (0, 1)\n    def get_positive(l):\n    if l is None:\n       l = [0]\n    return get_positive(l)\nHm, this is interesting because in my mind the answer is this:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.startswith(\"-\") and l.endswith(\"-\") and not l.isempty():\n       return [l[:-1]]\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    return len(l) == 1\n\nI think it's pretty clear cut that this is the correct solution.\n\nI agree. This is the most Pythonic way to do this.\n\nI guess the next question is: if you were to write a function that would return every element of a list that is in sorted order, how would you do that?\n\nWhat do you mean by \"sorted\"?\nIf you mean \"in ascending order\", use the sorted function.\n\nsorted is a builtin function. That's cheating.\n\nHow so? You want a solution that uses builtins, and sorting is a builtin.\n\nNo, I was joking. The question was about the most pythonic way, and your solution used a builtin.\n\nNo, the question was _\"if you were to write a function that would return every element of a list that is in sorted order, how would you do that?\"_\n\nOops, I read it wrong. I thought he said \"I guess the next question is: if you were to write a function that would return every element of a list that is in sorted order, how would you do that?\"\n\nBut if I", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] < 0 else l[0] + 1 for l in l]\n\nI don't understand the point of this article. I would have hoped for at least a high level overview of the different algorithms.\n\nJust a good reminder that when you're getting the fifth or sixth result down in Google, you're missing out on a lot of gems.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(x => x % 2 == 0)\nThis is the stupidest thing I have read all day.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.index.values(), key=lambda x: x>=0)\nI don't think the OP's question was to do with sorting.\noh, it wasn't?\nI assumed it was, because the point of the exercise is to write a recursive function with no loops. I guess the OP could be asking how to write a function to return the largest elements in an iterable, but that's not really the same thing.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if (l.startswith('-')):\n        return []\n    if (l.endswith(')):\n        return l[:-1]\n    return l\nWow, I never knew about this. What happens if you have a list with a negative number at the end?\nI'm new to python.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n    if len(l) == 0:\n        return []\n    else:\n        l = [x for x in l if x > 0]\n        return get_positive(l)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n\n          return [l[0] for l in l if l[0] >= 0]\n\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n\n         return [l[0] for l in l if l[0] >= -1]\n\n    def is_prime(n):\n    \"\"\"Returns True if n is prime, False otherwise.\n    >>> is_prime(3)\n    True\n    >>> is_prime(5)\n    False\n    >>> is_prime(7)\n    False\n    >>> is_prime(11", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l)) if i in l[0]]\nI'm actually a fan of having to specify the iteration.  I've seen too many codebases where people say things like \"I don't need to tell you how to get the next item off a list because you should know that by now\".  Some people get it and some people don't, but it just seems more clear to me to say explicitly what you're doing.\nI am a fan of explicitly stating the iteration for lists, but for the more complicated cases like this one I think it's better to abstract it out.  If you are doing this for the first time, it's a bit annoying to have to figure out what i needs to be for your particular case.  You know that's an item in the list, but it's not always a number.\nYou mean like iter(l, :step)?</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] > -5", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # Note the use of a lambda function\n    # passing to the list\n    result = []\n    for item in l:\n       if item.is_positive():\n         result.append(item)\n    return result\nThis is clearly the better way. The function is much more readable, and it clearly shows what the function does. The example even shows how to do it when you don't want to use a lambda function, but just return the result of the function to the caller.\n\nYes, but it doesn't work in Python 2.6, and the OP was writing in Python 2.6.\n\nThat's a pretty good example. It's easy to see what the function does and what it returns.\nIn contrast, the example given by the author is not as straightforward. I can tell what it does, but I have to read it a few times to get what it returns:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter( lambda x: x > 0, l))\nWhat's wrong with this? It's not only short, but it's a list comprehension.\n\nFor a simple task like that, the following is more concise:\nlist(map(x => x > 0, l))\n\nI have a feeling the original poster wanted the list to be altered to include the positive values (and nothing else), rather than just returning a new list. I could be wrong, though.\n\nI'm sure you are right. The problem is that it is not clear to the reader how to do that.\n\nI did exactly that in a project of mine. It's on github, but not currently open source. It was not a complicated library but it did exactly this:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in list if l[0] > 0]\nI had to read the comments here to understand what this does.\nIs this a \"too many features\" problem?\nI feel it's too verbose and could be more clear.\n\nI think that would be a good idea to add some comments. But the code itself is pretty clear, and would be easily understood if you already know what it's doing.\nAs for \"too many features\" I think this is a nice example of adding more features to a language that have already been in a popular language for some time.\n\nI think the readability of the code is probably related to the familiarity with Python and the \"Pythonic\" way of doing things.\nI've been programming in Python for the past year and I would say that this code took me about 15 seconds to understand. If I was looking at someone else's Python code I'd probably have trouble reading it as well.\n\nIs it just me, or does this look a bit like Ruby?\n\nI don't know Ruby, but it looks like many other languages. The main thing that struck me was how much more readable it was than, say,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        return l[1:]\nThis is more or less a rip-off of the Python idiom, isn't it?\n(Note that the last line of the Python version is redundant:  )\n\nI think you mean redundant: \"a statement or word that is said or written more than once in a piece of writing or speech, typically adding extra information.\"\n\nYes, thank you.\n\nI like this, but I wish the examples used strings rather than lists.\n\nThis is interesting and useful, but I'm not sure I like it. If I want to use it, I'd have to modify all of my existing code to use this function.\n\nIt's not a function, it's a class.\n\nOh, duh. Thanks for the correction.\n\nI like it.\nI think Python has a good idea here (that lists are basically a special case of dictionaries).\n\nDoes anyone know of a good C++ wrapper for Python's built-in collections classes (dict, list, set, frozenset, frozenset_iterator, etc)?\n\nI found this one a while", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: len(item) > 0, reverse=True)\nThey're assuming the first item is 0.\nI don't think that's a safe assumption in python.\nIt's only valid in Python 2.\nIn Python 3, the sort() method always returns a sorted list, regardless of the\nfirst element.\n\nI wonder why Python 2 sort() is like that?\n\nI don't know. I'm pretty sure it's because Python 2 is stuck in some kind of\nimperative mindset, where some operations are expected to return a value,\nand others return a value only if they succeed.\nIn Python 3, all operations are expected to return a value, even if they\nfail. (The \"except for the try\" rule for exceptions, of course.)\n\nPython 2 has iterators, Python 3 has iterables, the two are not compatible.\nYou could have an iterator which returns an iterator that returns an iterator.\n\nI'm a python newbie, but I don't see the point of this post.\n\nMy guess is that it's a clever way to get a list of all the positive numbers.\n\nAh yes", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if list.size() > 0:\n        return list[0]\n\nSo, if I understand this right, this is a function that will return a list of only the elements of the original list that are positive.\nFor example, given the original list:\n[1,2,3,4,5,6,7,8,9]\nThis function will return [2,5,6]\nThis is pretty much the same as the [x for x in list if x >= 0] syntax.\nI think there is some value in having a function that does this, but it is very easy to write by hand.\n\nYou are right, it is a very trivial thing to do. But with this, you can then easily create more useful functions that work on positive numbers only.\nFor example:\n>>> get_positive([1, 2, 3, 4, 5, 6, 7, 8, 9])\n[2, 5, 6]\n>>> get_positive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n[2, 5, 6, 10]\n>>> get_positive([", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0]!= 0 or l[0] > 0)\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [-6, -4, -3, 2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [9, 0, 1, -10, -3, 3, -5, 2, 5, 6]\n    \"\"\"\n    return (l[0]!= 0 or l[0] < 0)\n    def get_zero(l: list):\n    \"\"\"Return only 0 in the list.\n    >>> get_zero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    []\n    >>> get_zero([5, 3, -5, 2,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l: list is not None:\n       return l: list\n    return list(filter(lambda x: abs(x) > 0, l))\n>>> 1.4.0\n>>> >>> def foo(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> foo([1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> foo([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    if l: list is not None:\n       return l: list\n    return list(filter(lambda x: abs(x) > 0, l))\n>>> 1.4.0\n>>> >>> def foo(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> foo([1, 2, -4, 5, 6])\n    [", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum(l) >= 0\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [123, 1]\n    \"\"\"\n    return sum(l) <= 0\n\nAnd this would run a lot faster, but still slow.\nI'm just using this as an example, because it was one of the first I found, but in general you get the point, if not the full utility.\nThis is one of the reasons why Python's list comprehensions are so useful.\n\nI would personally use the following version of Python:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[1] < 0) and (l[0] >= 0)\n\nIf you want to do this with a functional language like Python, this is the easiest way:\n>>> def f(l):\n    \"\"\"Return only positive numbers in the list.\n    >>> f([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> f([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return not l[0] & l[1]\n\nOr to use list comprehensions:\n>>> l = [5, 3, 2, 3, 9, 123, 1]\n>>> l.filter(x > 0)\n[5, 3, 2, 3, 9, 123, 1]\n>>> l.filter(not x > 0)\n[5, 3, 2, 3, 9, 123, 1]\n\ni do like the list comprehension better!", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l]\n    @property\n    def positive(self):\n    \"\"\"Return True if the given number is a positive number.\n    >>> positive(get_positive(123))\n    True\n    >>> positive(-123)\n    False\n    >>> positive(10*-10)\n    False\n    >>> positive(False)\n    False\n    >>> positive(0.0)\n    True\n    \"\"\"\n    return not self.get_positive(self.positive)\n    @property\n    def is_integer(self):\n    \"\"\"Return True if the number is an integer.\n    >>> is_integer(get_positive(10))\n    True\n    >>> is_integer(get_positive(0.1))\n    False\n    \"\"\"\n    return True\n    @property\n    def is_real(self):\n    \"\"\"Return True if", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return [l[0] for l in l]\n\nIn [1]:"]]