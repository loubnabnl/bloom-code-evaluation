[["def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in range(0, shift):\n        return string.characters(i, '0') + string.characters(i, '1')\nI wish someone would do this in real life.\n\nDoesn't Python have this already?\n>>> print circular_shift(12, 1)\n'21'\n>>> print circular_shift(12, 2)\n'12'\n\nOf course. My point was that I wanted to see someone in real life actually write that.\n\nYou can probably do that in SQL...\n\nActually, I've done it in SQL. More than once.\n\nOh yes, it's one of the first things I learned in SQL. It's actually quite useful, to save on round trips.\n\nYou could do this with regexes. But it would take quite a bit of work to get it right.\n\nCan you post the regexes? I was just about to write a class to do this but this seems like it could be faster.\n\nFor a single digit, you could just use something like (?<= (?<= \\d\\d) \\d\\d)\n\nIn", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\" + digits_reversed(x) + digits_reversed(shift - digits_reversed(x))\nThis is really cool. It reminds me of a one-liner I wrote for my phone's keypad. For me, the easy part was writing the reverse function. The harder part was finding the perfect candidates for my keypad.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\";\nThis works, but you might want to make it clear what happens if shift > number of digits.   Just a thought.\nI agree, although I think this would be better covered in a library rather than a language.\nThat would be great, but I think the OP is asking about basic features in the language which are necessary to achieve something useful.  If you only have the basic features and you don't have a library which has a module for a particular task, you don't get very far!</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join(map(str, range(0, -shift, -1)))\nYou can do that in Python?\nIf you mean \"Can you write Python code that looks like pseudocode?\", then yes, yes you can.\n\nWhat's next? Python code that looks like C?\n\nThis is a C extension, so, yes. \n\nYes, but this is a joke.\n\nI was expecting a post about the classic C mistake of returning pointers to strings, but this is a nice read.\n\nIt's hardly a classic C mistake. It's perfectly valid C.\n\nreturning a pointer to a string is valid C, but it's generally a bad idea because it's hard to tell whether the string is empty or not (and you're not allowed to use strlen to find out).\n\nThanks for posting that. I just assumed that when I see\nint x;\nx = \"Hello World!\";\nthat \"Hello World!\" was being returned as a pointer to a char, which it is.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join([str(x) for x in range(shift) if str(x) == x])\nThat's a good point.  I was trying to keep it simple, but it's probably good to make it a little more explicit.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n       for i in range(shift):\n           if digit[i]!= 0:\n               digit[i] = digit[i] ^ shift\n                return str(x)\n\nYou can also do it using only for loops:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(x.split() for x in x if x[-1] == '.' else x[-1])\nThis is great. It's not a common operation that I need to do, but when I do it's easier to remember the name of the function than to remember the logic.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return '0' * x.ljust(shift) + x[::-1]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # Convert to string, then call the appropriate sub\n    # depending on the number of digits and the value of shift\n    return round(str(x)) + \" shifted right by \" + shift", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n         digits = str(x)\n         while digits > 0:\n             digits = digits[(digits + 1) % shift]\n               digits = digits[(digits + 1) % shift]\n               if digits!= '0':\n                   break\n                return string.join(digits)\nThis is almost the same as the OP's, but does not work with negative numbers.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # NumDigits = num_digits_in_integer\n    #\n    # number_of_digits = num_digits_in_integer - shift\n    #\n    result = \"\"\n    for i in range(num_digits):\n        result += '0' if shift == 1 else '1' if shift == 2 else '2'\n    return result", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = str(x)\n    return round(abs(x - shift), digits) + \"0\" + digits.rjust(0)\n\nThere is also the faster round function, which does not require calculating the modulo.\n\nIt's not faster, it's the same as abs. modulo and round are both O(n) and abs is O(1).\n\nOh, right. I'd forgotten about the speed of division.\n\nThere's also another O(1) version I've used in the past:\n>>> circular_shift = lambda x: int(x[::3]) + '0' + int(x[::-3])\n\nthis version doesn't work with \"negative\" numbers though (or NaN, or other special numbers).</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n       return x[-shift:]  # return x backwards\n    return '\\x{100}' % x[::-1]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return int(x, digits=[x[-shift:]], reversed=True)\nWhat I'm getting at is that the only use-case I can see for this function is to reverse the digits of a string.    This could have been done with \"s.reverse()\"\nThere is an instance where this would be handy: If you want to display your numbers in a circular format but still want the number to be decidable. If you reverse them, then they aren't decidable anymore.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    out = \"\"\n\n    for i in xrange(number of digits):\n        out += ord(i) + \".\"\n    return out</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return [x[::-1] for x in xrange(len(x), shift)]\nIf the shift is negative, this gives you the original string.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return '' + str(int(x)) + int(x[shift:])\nI guess the answer is 42.\n\nYup, I suppose it would be best to use a fixed (default) shift value in the function. Thanks for the bug report!\n\nVery nice. You could generate the url dynamically and store the answer in a cookie, so the user could see the answer in the address bar.\n\nThanks for the idea. I'll implement it in a near future.\n\nMaybe use a string for the response so you can do something like\ncircular_shift(\"hello\", 2) # to get \"hell\"\n\nOr even easier, just have a function that takes a string and a number and does a circular shift.\n\nDone. The new version uses the string format for the result.\n\nAlso, a string format for the input.\n\nA good solution. It's interesting to see how many different ways there are to do the same thing.\n\nI love it when you can read the \"Hello World\" page and understand immediately what it does.\n\nnice. what if we want to shift only some digits?\n\nThat's a good question. I've just", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    result = \"\"\n    while x!= 0:\n       if x == 0:\n          result += x\n       elif x == 1:\n          result += 1\n       elif x == 2:\n          result += 2\n       elif x == 3:\n          result += 3\n       elif x == 4:\n          result += 4\n       elif x == 5:\n          result += 5\n       elif x == 6:\n          result += 6\n       elif x == 7:\n          result += 7\n       elif x == 8:\n          result += 8", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    x = int(x)\n    r = 0\n    for i in range(x.digits):\n        r = r + x.digits[i] % shift\n    return r", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n       return \"\".join(x, reversed=True)\n    return \"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # Generate a new string with the shifted digits\n    return str(ord(x)[::-1])[::-1]+'0'+str(ord(x)[::-1])[::-1]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join([x[i] for i in x if i % shift == 0] + \".\")\nNo one cares what language you used to write your program, but you used the wrong one for this.\nIn python\n>>> circular_shift(12, 2)\n'12'\n>>> circular_shift(12, 0)\n'1'\n>>> circular_shift(12, 2)\n'12'\n>>> circular_shift(12, 0)\n'1'\nThere is a big difference between what you wrote and what you claim that python does.\n\nYou can get the same thing with python. It's just done differently. This is what I used, and it works for me:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return tuple(\n        reverse(x) + shift,\n        (x[0] - shift) + shift,\n        x[1:]\n    )\nI prefer this one:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    number_of_digits = len(x)\n    return ''.join([str(i) * shift + i for i in x])</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = str(x)\n    for i in range(0, len(digits)):\n        digits[i] = digits[i] % shift\n    return \" \".join(chr(digits[-1]) for i in range(0, len(digits) - 1))\n\nI was going to say this - I love languages with a concise syntax. In this case I would just write \"return digits[:-1] for i in range(0, len(digits) - 1)\".</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    x = int(input(\"Enter number (10 or more) to circular shift\")\n    )\n    if x < 0:\n       return \"0\"\n    else:\n       return \"\".join(circular_shift(x, shift))\n    #print(circular_shift(12, 4))\n\nAnd here's how to use it:\n\n>>> numbers = ['1', '2', '3']\n>>> circular_shift(numbers)\n'1 2 3'\n>>>\n>>> numbers = ['1', '2', '3', '4', '5']\n>>> circular_shift(numbers)\n'1 2 3 4 5'</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return reversed(int(x))\nI think it's clear, but if someone has a better way to explain this concept, please share!</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    n = len(x)\n    s = \"0\"\n    while n > 0:\n        x = int(x)\n        if shift > 0:\n             x = x>>shift\n             x = circular_shift(x, shift)\n             s = s + str(x)\n             n = n - len(x)\n    return s\n\nThis one is also pretty interesting:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.ascii_uppercase(x[:shift], 1) + '0' + x[shift]\nThis is the correct answer.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits + \".\" + string.punctuation + \".\" + string.digits", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    n = int(x)\n    for d in x:\n       n += shift\n       n -= d\n\n    return \" \".join(chr(int(n)) for n in x)\n    @staticmethod\n    def circular_shift_right(shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift_right(12, 1)\n    \"21\"\n    >>> circular_shift_right(12, 2)\n    \"12\"\n    \"\"\"\n    n = int(x)\n    for d in x:\n       n += shift\n       n -= d\n\n    return \" \".join(chr(int(n)) for n in x)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return u''.join(chr(int(x)) for x in range(x))\nThis is a simple example, but the real use for this function is in cryptosystems, where it is used to change a plaintext into a cyphertext.\n\nHere is another example, more complex:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join([str(x[i:i+shift], 10) for i in range(x.digits)])\nSo it's not the same thing.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(x.split())\nI'm sure you're right about the correct Pythonic way to do this, but the example in the OP's question doesn't seem like the type of thing that should be a top-level comment.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    shift = 1\n    while len(x) > shift:\n        # if shift is greater than the number of digits, return reversed digits.\n        if shift > number_of_digits(x):\n           x = x[-shift:]\n            return \"\", x[:shift]\n        else:\n           x = x[shift:]\n            return x[:shift] + \"0\"\n    return \"\", x", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join([x[0]*shift for x in range(0, x.length)])\n\nI've always liked the style of Python, and when I first saw Ruby I was like:\n\"Holy shit, I love this language!\".\n\nSince I started playing with Ruby a couple of months ago, I've been coding\nin Python only a few times. That's probably because I still think that\nPython is the best language for beginners. In my opinion, Ruby is a little\ntoo complex, and requires an extensive learning curve.\n\nHere is how to print the numbers from 1 to 10 with Ruby:\n\np = puts(\"Hello!\")\nwhile p == \"h\" and p == \"e\"\np = p.chop!\np = \"0\".chop!\np = \"1\".chop!\np = \"2\".chop!\np = \"3\".chop!\np = \"4\".chop!\np = \"5\".chop!\np = \"6\".chop!\np = \"7\".chop!\np = \"8\".chop!\np = \"9\".chop!", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n        n = len(x)\n        shift_right = int(math.floor(n/shift))\n        return \"<DIGITS>{0}\".format(int(x[:shift_right]))", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(map(str, circular_shift(x, shift)))\nFor some reason I thought this was going to be a palindrome.\n\nFor some reason I thought this was going to be another link to the PEP.\n\nFor some reason, I thought this was going to be a ternary operator.\n\nI wrote that code for fun a couple years ago, because the assignment was\nto write a function to reverse a string. I decided to see if I could do\nsomething that would reverse the string without requiring any copying\nor rearranging of the bits.\nIt was just the right amount of cleverness to impress the teacher, but I\ndon't think he ever realized what I had done.\n\nYes, this is one of the best exercises for a Python programmer.\n\nJust be sure not to use it as a general purpose reversing function.\n\nIt works for binary numbers as well.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.characters(x, shift)\nShouldn't this be written as:\nreturn string.characters(x, 0) + string.characters(x, shift - 1)\nThis is just an easier to understand version of the OP's code, and is easier to debug.\n\nNo, that's equivalent to the 'digits' method that is already in the standard library.\n\nDidn't know that, sorry!\n\nI feel like this post is coming from the perspective of someone who isn't very familiar with Python.\nThe first example is a bit weird, but the second example is perfectly fine. The author is demonstrating that Python's string formatting syntax has this nice property that it doesn't add any whitespace, unlike C-like languages.\nIn fact, Python is famous for not adding superfluous whitespace like C, Objective-C, and Java do.\n\nI'm very familiar with Python, in fact I was the original author of the circular_shift() function. I can't remember why I made this post though.\n\nWasn't this post made because you were trying to find the most concise way to add whitespace to a string?\nIf so", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = map(int, range(1, number of digits))\n    result = \"\"\n    for i in range(1, number of digits):\n        if i % shift == 0:\n           result += digits[i]\n          result += digits[i]  # shift-left\n    return result\nThis is a good example of the fact that a lot of people here don't know how to write a decent function.\nI can guarantee you that this is not a good algorithm and will not work.\n\nThis algorithm is not what I would use for dealing with arbitrary integer values, but it's an interesting illustration of how the amount of digit-shifting performed in a number can be visualized as a \"circular shift\". In fact, the algorithm works fine if you change \"1\" to \"1.0\", \"2\" to \"2.0\", etc. The inner loop becomes\nfor i in range(1, number of digits):", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x[shift] > 0:\n       return x[shift:-1]\n    else:\n       return \"\".join(x[shift:])</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return re.sub('+', '-', x.upper()).join(' ')\n\nOh, and it's not exactly a _Python_ trick; it's just a neat trick in general.\n\nthis is better:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(str(x[shift:], end=' '), reverse=False)\n`\nI think you mean \"Right\".</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join([x[i:i+shift] % i for i in x[:shift]])\nNow that's what I call a short and sweet answer. Thank you.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(sorted(map(str, reversed(x)))\n   .map(str, reversed(x)))\nI like the elegance of this one.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n       return '0'*x\n    else:\n       return '1'*x\nDoes that really make a difference?\n\nGood point.\n\nAlso, the second line should have\nreturn '0'*x\nand not\nreturn '0'*x\n\nIf you're going to use it, you should put it up on PyPI.\n\nThanks, I will do that.\n\nHere's the link: \n\nThis is great, but it's also in C, not Python.\n\nTo clarify, it's C code that gets compiled into Python, not C code that you can just run.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = str(x)\n    for digit in range(10):\n        if digit % 2 == 0:\n            shift = (digit + 1) / 2\n        else:\n              shift = (digit - 1) / 2\n    return digits[:shift]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n        digits = []\n        for i in xrange(shift):\n             digit = x[i]\n             if digit > 0:\n                digits.append(digit)\n    return str(digits)\nI don't like having to explicitly specify that if shift is negative,\nI'm shifting right, and if it's positive, I'm shifting left. It'd be\nnicer to be able to do the following instead:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    \"\"\"\n    return''.join(ord(x) for x in [x[0:shift], x[shift+1:])</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    shift = 1\n    if shift == 0 or shift == 1:\n        return digits[shift]\n    for i in range(0, number_of_digits):\n        shift = shift + 1\n        if shift == shift * number_of_digits:\n        return digits[shift]\n    return ''.join(digits)\n\nAlso, note that the rightmost digit of the string is always the same as the first digit of the original.\n\nThere's a simple implementation of this using a regular expression.\nReplace digits with [0-9].\nReplace shift with [^0-9].\nAnd replace join with [a-zA-Z_][a-zA-Z0-9_].\n\nThe main difference is that the traditional method only uses one character set, and so you can't reverse the digits.\nAlso, you can't have a leading 0", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # Reverse the string\n    return ''.join([x[i%shift] for i in x.split('.')[1] if i] +\n    '0' * (i+shift))</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n       return \" \".join(x.split() for x in x if x[0] == '0')\n    else:\n       return \" \".join(x.split() for x in x if x[0]!= '0' if x[1:shift] == '0' else x[1:shift])\n\nHere's another version, more compact and without the \"if shift > 0\" check. It only handles 2 arguments:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    \"\"\"\n    for x in range(0, number_of_digits):\n        if shift > 0:\n            x = round(x, shift)\n             return x\n         else:\n             x = x[shift:]\n             return x[::-1] + '0' + str(x[::-1])\n    # we need to do this because \"x\" is a tuple, not a string\n    return''.join(round(x, number_of_digits) for x in x)\n\nI had to dig into the docs for this, as I was confused by the syntax and the example:\n>>> circular_shift(12, 1)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"\", line 2, in circular_shift\nreturn x\nValueError: circular", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return lambda x: x.__reversed__(x.split(\" \")[-1])\n\nThat's an example of why whitespace and indentation are important.\n\nNot to be confused with the (slightly more) widely known \"modular arithmetic\".\n\nModular arithmetic can be thought of as a generalisation of this algorithm for any number n.\n\nReminds me of a code golf challenge I saw a few years ago that used this idea: https://golf.codegolf.stackexchange.com/a/17187\n\nA somewhat more useful variant of this is the quine - a program that prints out a specific text.\nIn this case, we want a quine that prints a certain number of digits of pi.\n\nSo, it's like a quine.\n\nThanks for this. That's a good introduction into the problem.\n\nReminds me of my first Perl job. The boss wrote this script for a project to convert a string into an integer with a function like this. It took a couple of minutes to run and it was exactly what we needed for the application. I was like, wow, Perl is cool.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(ord(x), x[shift:])\nIn python 2.x this gives the following output:\n>>> circular_shift(12, 1)\n'21'\n>>> circular_shift(12, 2)\n'12'\n\nI'm curious what the performance of this is.\n\nIt's probably fairly good - the only thing it does is string manipulation, which is something the Python interpreter is pretty good at.\n\nI'm not sure about this, it seems like it is doing a lot of string manipulations, then again, I don't know much about python internals.\n\nPython supports tail-call optimization, so this should be reasonably fast.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    letters = [0]*10\n    while len(letters) <= number_of_digits(x):\n         letters[(x&1)%letters.size()-1] = x\n    return letter + string.punctuation + letters[-1:]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return '\\0'.join(str(x[::-1] * shift, x[::0]) for x in xrange(len(x)))\nHmm, I guess I like the intuition behind this, but the actual implementation seems to require an infinite number of operations.\nI'm pretty sure it's not O(n), so what is it?\nIt's O(n!) when shift > n (which is pretty much the only case).</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = str(x)\n    return digits.ljust(shift)\nThe OP's function is more general than this. It works with any iterable, not just strings.\n\nx, shift = iterable()\n\nBetter, but still not general enough.\n\nx, shift = range(1, 10)\n\nStill not general enough.\n\nx, shift = xrange(1, 10)\n\nNow we're talking.\n\nx, shift = set(range(1, 10))\n\nAt which point we might as well just use Python's built-in set function.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return int(x ** shift)\nThis doesn't work, because x can't be negative.\n\nThis is a good point. I've updated the post to use absolute value rather than x.\n\nI'd suggest using math.sin and math.cos to check if the user typed in a number, then call circular_shift on the correct number:\n>>> def is_number(x):\n...", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in x:\n       x[i:i+shift] = x[i:i+shift] ^ shift\n    return \"\".join([x[i:i+shift] for i in x])\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n   \nI just used Python for the first time in years yesterday.  I forgot how much I love the language.\nI use a language called R for my work, and I was looking for a way to automate some of the grunt work I have to do in R, so I'm starting to learn Python to do just that.  My first idea was to write a script to import R dataframes into Python dataframes, but I didn't want to put in the time it would take to figure out how to do that.  Then I remembered I could just write a script that does the same thing but in reverse.  :-)\nThe thing I love about Python is that it's just so easy to prototype things.  I just threw together the above code in", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    letters = [x.split(0, \".\") for x in range(x.length-1)]\n    return letters[x.index(shift)]\nHow did you know how many digits there are in the original number?\nSince the original number is a string, it probably had a format like \"1234-567890\". It's pretty easy to get the length of that string using the `rstrip` function from the standard library.\nWhat if the original string was \"1234\", and you wanted to circular-shift it?\nThat's the case where `circular_shift` uses `reversed` instead of `shift`.\nYou probably want to mention this in the code.  In fact, you probably want to put in some sort of check that the input is a number.  Even if it's an error, it's still useful information.  Also, what is the reason for using the `reversed` method?  Does it have a mathematical reason, or is it a \"real world\" thing?</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    n = int(x)\n    return str(x, int(shift) - n) + '0' + n", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x % shift)\nI like this one better because it looks like it's a function to reverse strings.  Thanks.\nHaha. I almost did that at first, but I thought it would be too confusing.  This is the correct answer.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x == 0:\n       return \"0\"\n    else:\n       return \"\" + x + \".\" * shift", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    def get_digits(x):\n       x = x.split()\n       return [x[i] for i in x]\n    return (str(circular_shift(x, 0))) + str(circular_shift(x, shift))\n\nCircular shifts could be implemented with a right-shift and a left-shift, but this is the same as a double shift, so the code could be simplified with the following:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return String(int(x), int(shift) % 10, \"\")\nI think this is what you're looking for.\n\nThanks! Just what I was looking for.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x, shift)\nThat's good for easy tests, but it's slow for actual production use.\n\nYeah, I thought it might be. I just liked the idea of having a module that looks like it might actually be useful.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in x:\n         for j in x:\n             if (i!= j and shift > i):\n                     j = i\n                       return j\n\nSee also:\n\n>>> '21' + '1'\n'212'\n>>> '212' + '1'\n'123'\n>>> '123' + '2'\n'123'", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ('0' + ord(x[0]), x[1:] + ord(x[1])) + '0'\nI really like the elegance of this solution.\nHow would you go about implementing it?\nI'm a beginner to Python.\n\nPython has list comprehensions, which are usually useful for cases like this.\n[0, x[1:] + ord(x[1])) + '0']\n\nThat's pretty sweet, thanks.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(x):\n        if x[i] == 0:\n           i = i + 1\n         else:\n            i = i - shift\n            x[i] = x[i] + shift\n    return x\nPython2.7\n> circular_shift(12, 1)\n> 21\n> circular_shift(12, 2)\n> 12\nIt should be possible to add, but not subtract, the shift from the\nresult.\nIt is also possible to subtract one number from another, but I've never\nused it, and don't understand it:\n> circular_shift(12, 1) - 1\n> 21\n> circular_shift(12, 2) - 2\n> 12\nThis would be useful, if I could understand it.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift == 0:\n        return x\n    else:\n        return x + (x / shift) * shift\n    # Reverse if less than number of digits\n    return reverse(circular_shift(x, shift))", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    x = int(x)\n    digits = range(x)\n    return \"%s %s\" % (x, digits)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.ascii_uppercase + digits[shift]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return lambda x: x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.ascii_uppercase(digits[0], digits[2:], digits[-1:] + \".\")\n    + \"0\"\n\nwhat does this return?\n\nIt returns \"21\". It reverses the digits and adds the \"0\".\n\ndigits is an array of 3 numbers, each of which is the digits of 12. so the return is string \"21\" plus a 0.\n\nThere is no reason to do this by hand, as any programming language (Perl, Python, Java, C#) has functions to do this.\n\nActually, the same can be achieved in any programming language without using any library.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join([str(x) for x in range(0, shift)])\nThis would be a good place for a comparison with `str(x)`.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(str(x), '0x')\nYou can also use a list comprehension here, which has the nice property of being more readable:      circular_shift = [str(x), x[::-1] for x in range(shift)]</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(number_format(x, \"%d\")) + circular_shift(x, shift) + \".\"\nDoes it return the original string for a negative shift, or something else?\nFor negative shift it returns the string reversed (returns the string with the rightmost digit in front)</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x) + str(x % shift)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join([chr(x) for x in xrange(shift)]).replace('0', '_')\nThis is a nice and concise solution. It's a bit weird that it doesn't have a \"3\" in the output.\nThanks for the feedback, fixed.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    while shift > 0:\n        x = x[shift]\n        shift = shift - 1\n    return chr(ord(x)) + '0' + ord(x[shift])", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # we can't just call `str` on the result, since we might get\n    # a negative number, so we have to do the math ourselves\n    return ''.join(str(x**shift), -(x**shift))\n\nWhy is this the top voted comment? This code is horrible.\nHere is a better version:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return 'x'.join(str(x[:-shift], x[shift:]) + '0')\nA simple way to test if something is left-shifted or right-shifted is to use isinstance(x, str)\n>>> isinstance(x, str)\nTrue\n>>> isinstance(circular_shift(x), str)\nFalse\nThis code will return True for left shift and False for right shift.\n\nCircular shift is useful for implementing autonumbering.\n\nThanks for that, that's a great way to test.\n\nI think the real question is why should you ever want to do this?</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(chr(ord(x[0] + shift)))</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return list(map(str, list(range(x))), \"\")\nI'll give you a hint:\n>>> circular_shift(12, 2)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/me/hacking/python/trunk/subprocess.py\", line 844, in __call__\nreturn self.do_call()\nFile \"/home/me/hacking/python/trunk/subprocess.py\", line 878, in do_call\nreturn subprocess.call(cmd, args, **kw)\nFile \"/home/me/hacking/python/trunk/subprocess.py\", line 928, in subprocess.call\nreturn subprocess.Popen2(cmd, args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, stdout_pending=False)\nFile \"/home/me/hacking/python/trunk/subprocess.py\", line 692, in Popen2\nself.stdout = subprocess.PIPE", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join([str(x) for x in range(shift)] + '0')\n>\tThe next line is the magic.\n>\tfor i in range(len(x)):\n>\t        return x[i] + shift\n>\tThis is a for loop with the variable i that iterates through all the elements\n>\tof the range x, and each time it runs the operation x[i] + shift it\n>\tadds the result to the result list.\n>\tSo this line of code will keep adding the numbers 1 through shift to the\n>\tresult list, starting at index 0 of the result list, and when the result\n>\tlist is full (or the for loop runs out of iterations), the last value\n>\twill be the result.\n>\n>How is it possible to use a for loop in the generator expression? I thought\n>the only things that were allowed were yield and return, and that for loops\n>were only available in the context of for-loops (i.e., for statement).\n>\n>\n>\n>\n>\n>\n>\n>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x == \"\" or x == '\"' or x == '':\n       return \"\".join([x.strip() for x in range(x.length)])\n\nThis is a really good example of how to make things more complicated than they need to be.\nThe more complicated example is from python, but the article is from ruby. I've only ever done one project in ruby, but I never used any of this crazy stuff. It's all gotchas and special cases.\nAnd I'm pretty sure that the C solution is going to be the fastest (after some rough benchmarking). The C solution has just the right amount of smarts.\n\nWhy would it be faster? I think you'd still have to check the sign of the number, and then check the length of the string to see if you should reverse the string, and then convert the string to an int.\nPython is also doing a check for the length of the string, and is doing some reverse engineering of the numbers.\n\nWell, you don't need to check the sign because C will let you perform an arithmetic operation with two negative numbers.\nIt would be faster because it's a simple for loop", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(ord(x)) + str(ord(x) + shift)\nAn additional note for the uninitiated, it's good to remember that `ord` is the C equivalent of `ordinal_notation`. In other words, it's the order of the digits of the input number in binary.  So, `ord(12)` is 12 in binary, or `01111111` in ASCII.\n\nWouldn't it be easier to just use modular arithmetic?\n\nNo, for the following reasons:\n1\\. The syntax is different:\nx = 12\n12 = 2 * 3 * 2\n2\\. The performance is different:\n>>> 2**(12 - 1)\nOut[2]: 12\n>>> 12\nOut[1]: 12\n>>> 12 * 2**(12 - 1)\nOut[2]: 24\n>>> 24\nOut[1]: 24\nThe reason is because `mod` is implemented using a stack whereas `2**` is implemented using the multiplication operator.\n\nSure, if you want to use base 2. But if you use base 10, it's more work, but less error prone.\n\nI'm not sure what you mean", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x)[::-1]\n    >>> circular_shift(12, 1)\n    '21'\n\nAnd yet the number of people who would really do that is still tiny. The number of people who would really write\n>def circular_shift(x, shift):\n>    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n>    and return the result as a string.\n>    If shift > number of digits, return digits reversed.\n>    >>> circular_shift(12, 1)\n>    \"21\"\n>    >>> circular_shift(12, 2)\n>    \"12\"\n>    \"\"\"\n>    return str(x)[::-1]\n>    >>> circular_shift(12, 1)\n>    '21'\n>    >>> circular_shift(12, 2)\n>    RuntimeError: maximum recursion depth exceeded\n>    >>> circular_shift(12, 3)\n>    RuntimeError: maximum", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > len(x):\n        return x[:shift]\n    else:\n        return x[shift:]\nWhat I don't get is the \"return x[shift:]\".  The shift argument is supposed to be a number, not a string.  How can it be a string in this context?  Isn't it supposed to be a number?  How does that get turned into a string?  The string in question is the \"21\" in the example.\n\nThis is one of those things that I could easily look up, but I'm in the middle of writing a novel and learning a new programming language at the same time.  I've got to get my priorities straight!\n\nOk, I've got to get my priorities straight.\n\nI'm going to look it up.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # create a list of digits\n    n = list(range(x))\n    # shift the digits\n    while n:\n        digits = list(ord(n))\n        for i in range(n):\n            digits.append(i >> shift)\n            n.append(digits)\n    return list(range(x))\nI don't understand why this should be faster.  Don't you have to load and loop through the list of digits and keep track of where you are in the list?  That seems more expensive than the simple loop you wrote.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join(reversed(int(x % shift), x))\n    def char_to_string(x):\n    \"\"\"Return a string of the character at position x in the string, or None\n    if that position is not occupied by a character.\"\"\"\n    if not x in string:\n        return None\n    return x.replace(\"-\",\"-\").rjust(2).rjust(0)\nWhat's the point of this?\n\nSeems to me to be an exercise in implementation of the \"trick\" that is described in the question.\nThe code's not doing anything useful.\n\nBut the question's not asking you to do anything useful.\n\nThe question is asking you to implement the answer. You are correct in that the exercise is not _intended_ to be useful, but that doesn't change the fact that it is.\n\nI see. So what's the point of the question then? Is it just to exercise implementation of the trick?\n\nThe question is to see how far you can get in an hour and is therefore probably only really suitable for", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(chr(x) for x in range(shift))\nThis is faster and more readable", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join(reversed(x[::-1]))\nThis seems a bit too simple for a TIL. Did I miss something?\nEdit: added a missing space.\n\nYeah, the purpose of a TIL is to make you feel stupid because you didn't know something that seems obvious.\n\"Well, duh, how could you not know this?\"\n\nI have the opposite feeling, so many \"TIL\"s I feel are just basic programming knowledge that I would expect a programmer to know.\n\nThe keyword in your reply is \"expect\". In my experience, the people who know the most about programming are the ones who are most aware of what they _don 't_ know.\n\nAnd yet the largest demographic of programmers are those who don't know what they don't know.\n\nThe largest demographic of programmers are actually the ones who think they are programmers, but only because they write one-line scripts in python.\n\nOr do things like write macros or make ad hoc modifications to programs.\n\nI find that most of the time, the first solution to a problem (especially in programming) is the correct one, and you just need to be told", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n\nThis is called `circular_shift` but there is no `circular_shift` function in the module. You need to add it:\n\n>>> import math\n>>> import string\n>>> import operator\n>>>\n\n>>> def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    return x[0:shift]\n    return \" \".join(x[shift:] - x[0:shift] for x in x[shift:] if x > 0 else x[0:shift])\n\n>>> x = 12\n>>> y = circular_shift(x, 1)\n>>> print y\n    \"21\"\n\n>>> x = 12\n>>> y = circular_shift(x, 2)\n>>> print y", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    print '', x\n    while x[-shift]!= '\\0':\n        x[shift] = x[-shift]\n        print x\n    return x", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return r' '.join(ord(x) for x in reversed(x))\nAh, good old C Python.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return round(reversed(shifted(x, shift))))\n\n>>>\n>>> import string\n>>>\n>>> circular_shift(12, 1)\n>>> '21'\n>>> circular_shift(12, 2)\n>>> '12'", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # Split the string into digits and pad with spaces\n    n = len(x)\n    d = x.split()\n    return''.join(d) +''.join('' + n)\n\nCode Golf\n\nPython doesn't have a standard library for validating email addresses. If you want to do it right, you have to roll your own.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\"\n    def shift_right(x):\n    \"\"\"Shift the digits right by shift.\n    >>> shift_right(12)\n    \"21\"\n    >>> shift_right(12, 2)\n    \"12\"\n    \"\"\"\n    return shift\n    def reverse_digit(digit):\n    \"\"\"Reverse the given digit of the integer x and return the result as a string.\n    >>> reverse_digit(12)\n    \"2\"\n    >>> reverse_digit(12, 2)\n    \"12\"\n    \"\"\"\n    return digit", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > len(x):\n       return '0'\n    return f'%d' % x", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    a = len(x)\n    return a[x[i] - shift]: x[i] + a[i]\nI'm guessing the person that downvoted me has never tried to implement a string representation of a binary number.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return x[x.index(':') + shift:]\nLol no.\nI see a lot of these \"python in under 100 lines\" blog posts and they always seem to have a focus on over-engineering.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.format('%d %d %d', x, x, x)\nSo, you're completely missing the point that this is a string formatting issue.\n\nYeah, I was coming here to say \"well... this is just a string formatting issue\", but I think you've beaten me to it.\n\nGreat explanation, but what if you want to leave the original string as is?</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = []\n    for i in x:\n         digits.append(int(x[i-1]+x[i])+x[i])\n    return \" \".join(digits)\nThe code above is faster than the popular method of doing the same thing, by converting to a string, shuffling, and then converting back to a number.\n\nThis is a big question, but I'll try to give you a short answer.\nYou don't.\nIf you need to do something like that often, you build a function. The main reason for that is that you don't have to keep re-writing it every time you have to do the same thing, but you also don't have to keep re-writing it every time you find a new way of doing it.\nIt's very difficult to say what a \"good\" function should look like without more information about the problem you are trying to solve. If you don't know how to write a good function, you can just copy and paste one from a library that already exists for a different problem.\nGood luck!\n\nPlease don't write code like that!\nHere's", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(reversed(x.split()), '.')\n\nIs there any particular reason why the author chose to code it like that instead of just returning a tuple?\n\nHe wanted to be able to loop over the elements of a list and apply a function to each one.\n\nI know that, but the choice of return type is inconsistent.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n       return re.findall(re.compile(\"[^0-9]*\", x))[::-1]\n\nThis is a really cool idea!\n\nYou can also use \"decimal\" type, and use the str() function to convert it to a string.\n\nThere's also decimal.fromhex()\n\nNote that the exponent has to be a string, too.\n\nThis is fantastic. How can I get a dump of all of the built in functions?\n\nSee\n\nThanks\n\nThe code is pretty, but it looks like it may be very inefficient and memory hungry. A quick experiment shows that it uses about 8MB to print the number pi with 100 digits.\n\nIn that case, I'm not sure it's particularly fair to characterize it as \"incredibly slow\". It's using a bit of memory, but it's printing a lot of digits.\n\nWell, it takes a lot of memory and uses a lot of time. It's not just a little bit slow.\n\nA lot of time?\n\nIt took about a minute to complete for me on a quad core i7 with", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \" \".join(map(str, range(x))[:shift])\nThe problem with this is that it's not tail recursive, which is a more efficient way of doing it. The author should know this, because he's posted other code on HN before.\n\nI think it's fine to write a recursive function that's not tail recursive. This is because tail recursion requires a compiler to be able to tell that the tail call will not call itself. Python does not allow the use of tail recursion.\nIf you want to argue that a non-tail recursive function is bad, then I'm afraid you'll be wrong. For example, in python:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.punctuate('%', round(int(x), shift))\nThat's very interesting. I haven't yet heard of round, and it's apparently part of the stdlib, but is it on python 3?</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return (x[shift:shift+1] << shift)\nThis is not a very good code snippet. This snippet introduces a bunch of new language features that you have to wrap your head around.\nI'd instead recommend  which I think is a lot easier to understand.\n\nYou're right, that one looks much better. I'll update the post with that snippet.\n\nAnother way of doing it, slightly more complicated, but one less function to write (and maintain)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = str(x)\n    c = \"\"\n    for i in range(1, shift):\n        c += str(digits[i])\n    return str(c)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x)\nYou could also do that without the function by just using       print(x)  and       print(x[::-1])  respectively.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(map(str, range(x.digits)))\nWhat if the input is not an integer?\n>>> circular_shift(\"hey\")\n\"yhey\"\n>>> circular_shift(\"hey\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"../main.py\", line 3, in circular_shift\nreturn ''.join(map(str, range(x.digits)))\nTypeError: circular_shift() takes integer and string, not list of integers\n\nHow do I make it so that if the input is not an integer, it takes the string and then it returns a string?\n\nJust a guess, but:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = x.decode(\"ascii\")\n    result = []\n    for i in range(len(digits)):\n        result.append(digits[i].split())\n    return result.join(\"\")", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"x\"  + str(x % shift)  + \" \"\nI don't quite get why you wouldn't just use a `sum`:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(reversed(ord(x[shift:])), x[shift])\nIt'd be more correct to use something like this (which is what you probably actually meant):\nreturn ''.join(reversed(ord(x[shift:])), x[shift:shift])\n\nI'll have to try that.\n\nWhy?</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    i = int(x)\n    while i > 0:\n       i -= shift\n    return str(i).encode('ascii')\n(the above is a lazy functional language version of the C++ version below).\n\nint circular_shift(int x, int shift) {\n    int i = x;\n    while (i > 0) {\n       i -= shift;\n       i += x % shift;\n    }\n    return i;\n}\n\nThis should be the C++ version, by the way:\n\ntemplate <class T>\nT circular_shift(T x, int shift) {\n    return std::circular_shift(x, shift);\n}\n\nI feel like there must be a smarter way to do this in C++.\n\nIf I understand correctly, the C version does not correctly round the result.\n\nWhat's the correct rounding?\n\nI think the correct rounding depends on the type of x (and the type of shift, if it's signed).", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return''.join(reverse(str(x)+shift))\nWhy not just:      return x[::-1]  EDIT: Reddit's markdown interprets \".\" as an actual character instead of an end-of-line thing. I meant to make it a \"dot\".\nThe str() function uses the Python Unicode string type.   The.join method joins Python Unicode strings, which includes the possibility of combining adjacent characters into one.   The result is that the same string object is returned when str() is used and the.join method is called.   The result of a call to circular_shift() is a string, not a Python Unicode string.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    start = int(input(\"Start position to shift by? \"))\n    shifted = 0\n    for i in range(start + 1):\n        if i == 1:\n           shifted = 1\n           start = i + 1\n        else:\n           if i == 0:\n               shifted = 2\n               start = i + 2\n        else:\n               if i == 1:\n                   shifted = 0\n                  start = i - 1\n         else:\n                 if i == 2:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    # no-op - no shift\n    return \"\";\n\nx = circular_shift(12, 2);", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return reverse(x) + int(x / shift)\nI like this.  It is more readable than mine, and only two lines.  However, it will not handle negative shifts.\nTo make mine work for negative shifts, I added another line.  It reads:\n\n    if shift > 1:\n        return''\n    else:\n        return circular_shift(x, shift)\nI had to change \"if shift > 0\" to \"if shift > 1\" because it seems that Python allows positive integer shifts, but not negative integer shifts.  So the \"if\" is really an \"if and only if\" statement.\n\nI did not know that Python allowed positive integer shifts.  Thanks for the correction.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in x:\n        if i == 0:\n            return \"\"\n         else:\n             i = i + shift\n    return \"\" + str(i) + chr(ord(i))\n\nThe following:\n>>> circular_shift(12, 2)\n\"12\"\n>>> circular_shift(12, 5)\n\"01\"\n>>> circular_shift(12, 3)\n\"21\"\n>>> circular_shift(12, 0)\n\"12\"\n\nIs a better example.\n\nI disagree, since that example does not show what the function does, and if the function is used wrong, the results will be wrong. I believe the original example is a much better one.\n\nIt's a simple function. It can be used right or wrong.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.join(chr(x[1:]) + '0', chr(x[2:]) + '0', x[3:])", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(str(x**shift), '0')\nNow I'm confused. I don't know if the author intended to use shift as the multiplier (I'm assuming it's the number of digits to shift, not a shift operator) or as a modulus.\n\nI think the answer depends on whether you're using Python 2 or 3. In Python 2, `shift` is a unary operator, so it doesn't have to be in parentheses, while in Python 3, it's a binary operator and so the parentheses are mandatory.\n\nIf you're in Python 2, you need to use the unary operator, which is available in Python 3 as well:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join([chr(x) for x in [x, x+shift]])\nIsn't that just shift?\nYes.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.format(\"%s: %s\", x[:shift], x[shift:])\nI really like this solution, and this one too. I think the first one is a bit cleaner, but this one is shorter.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join([x[-shift] for x in range(shift)])\nNote that the reversed result of the above function doesn't match the one of the OP.\n\nThis is why I like a language with a proper type system. It prevents problems like this.\nIn Haskell, this sort of thing would be a compile error (I'd expect), but in Python it's a runtime error (although I'd expect there to be warnings along the way).\n\n_Python_ has a proper type system.\n\n\"Proper\" is not something to be taken lightly. Python's type system is _worse_ than most other languages' type systems.\n\nWhich ones are better? I'm not familiar with them.\n\nC++, C, Java, Ruby, Javascript, and so on are all better. This is because in Python, a function can be passed any number of arguments, of any type. You can even do this in Java (and C++, C, and Javascript, though in Java you have to write an implementation for every possible type).\nIn Python, on the other hand, if you pass a string to a function that expects an integer, it silently converts it to an", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return re.sub(r\"[\\x{12}\", x, shift)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.punctuation.replace(char(x), '*', '.')\nAesthetics matter.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in range(1, number_of_digits(x)):\n        return '%02x' % (i, x[i])", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return (str(x) + str(x.charAt(shift))) % shift", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x == 0:\n       return '0'\n    return ''.join(str(x * shift for x in range(0, number_of_digits - 1)) for x in range(number_of_digits, -1))\n\nOn Friday night I got into an argument with a friend of mine about why it is (or why it isn't) better to use this form:\n>>> circular_shift(12, 2)\n'12'\nversus the \"more Pythonic\" form:\n>>> circular_shift(12, 2)\n's12'\nI'm curious what the Hacker News community thinks about this. Which form is more readable and more maintainable?\n\n_I'm curious what the Hacker News community thinks about this._\nI would say that the latter is more readable, but the former is more maintainable (provided you're using a language with a strong type system).\nIn a language like Python, the chances of \"12\" being an int are much greater than the chances of \"12\" being a float. So having to test for an int rather than a float is not a big deal.\n\nI would", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    for i in x:\n        value = round(i)\n        while value > 0:\n            if i % shift == 0:\n                 value = i / shift\n                 shift = (i + 1) / shift\n                 value = value/shift\n                 return str(i)\n    return str(value)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n        return x[-shift:], x[shift:]", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > len(x):\n        return x[shift:]\n    return chr(ord(x[shift:]))\nThis doesn't handle negative shifts or shift == 0.\nreturn x[shift:]\nwith the added benefit of preserving negative and zero values.\nYou can also use this trick to do simple integer division (i.e. doing the division by hand) in Python:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return digits.characters.join('') + \" \" + digits.characters.reverse().join('')", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(map(chr, digits, x)) + '0' + '0' + '0' + '0'\n\nThis is not a solution to the question posted.\n\nHow so? The question was, \"What is the best way to reverse a string without using a for loop?\". The solution provided takes a string, reverses the characters in the string, and then prints the resulting string.\n\nIt is not a solution because it does not reverse the characters in the string. The original problem was to reverse a string such that if you take the first character of the string and compare it to the last character of the string, it is the same character. The solution does not do that.\n\nThe problem isn't specific enough. The solution does do that.\n\nNo, it does not. The first character in the string is the last character in the string plus one.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    from itertools import permutations\n    def reverse(sequence):\n    \"\"\"Reverse sequence.\n    If last element in sequence is True, then reverse to last element and\n    return it.\n    >>> reverse([True, True, True])\n    [True, True, False]\n    >>> reverse([True, True, False, True, True])\n    [False, True, True, True]\n    >>> reverse([True, True, False])\n    [False, False, True]\n    \"\"\"\n    return permutations.reverse(sequence)\n\nCircular shift is one of the non-trivial application of permutations.\nPermutations is a set of functions that are used to generate a sequence of random numbers from a starting element and a specified function.  In the case of circular shift, permutations generates a sequence of random digits.\n\nThe circular shift function can be implemented in three ways:\n\nPython\n\n>>> from itertools import permutations\n>>> def circular_shift(x, shift):\n    \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x[0] == '0':\n       return '0'+x[1:]+'0'+x[2:]\n    else:\n       return '0'+x[1:]+'1'+x[2:]\nSimple and elegant.\nI think it would be better to return \"0\".+x[1:]+'1'.+x[2:]  so that the outer + can be optimized as a string concatenation.\n\n\"0\".+x[1:]+'1'.+x[2:]\nI think this is undefined behavior, and this code might not work the same on all systems.\n\nI don't think so. For example, on Windows it should work the same way as the equivalent C# code.\n\nYou are right. I was thinking of x86 assembly.\n\nIf you're looking for a cleaner syntax, Python has two functions for this:\n>>> round(123, 4) '123.456'\n>>> round(123) '123.4'\n\nIs the string conversion of 123 to 123.4 intended?\n\nIt's not", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.join(map(str, x))\nDoes it work as expected?\n\n>> Does it work as expected?\nYes it does. Thanks for your response.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n        return \"\".join(map(int, digits(x), reversed=True))\n    digits = int(x)\n    return x[0], digits\n\nOutput:\n\n>>> circular_shift(12, 1)\n'21'\n>>> circular_shift(12, 2)\n'12'\n\nSee also\nReverse string\n\nExternal links\n circular_shift in Python's standard library\n circular_shift in Python 2\n circular_shift in Python 3</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join([chr(x) for x in xrange(shift)])\nThis is a common problem I've run into, and I've never been sure what the best way to handle it is. What's the right way to handle this?\n\n_What's the right way to handle this?_\nI like to think about what I'd do if I were going to write this code by hand. If I were to write it by hand I wouldn't write a function that returns a string, I would just write \"21\" or \"12\".\n\nThe more I think about it, the more I feel like I'd do the same thing. I think in this case, the \"shifting\" is such a trivial operation that it would make sense to just make it a method of the str object.\n\nI agree. I think I would rather write \"shifting\" as a method of the str object than to write a new function. The new function can be added to the library, but I wouldn't have used it.\n\nI'm not sure if you're being sarcastic, but yes, that's what I'd do if I were writing this by hand.\n\nNo sarcasm", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 1 and shift > number_of_digits(x):\n       return string.join(str(x[i:i+shift], '0'))\n    return string.join(str(x[i], '0'))", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    x = int(x)\n    if x >= 0:\n        # if not zero, shift right to the rightmost digit\n           x -= shift\n         # shift by 1\n        return \"\".join(x if x > 0 else \"\")\n\nSurely it would be better to use:\n>>> circular_shift(12, 1)\n'21'\n>>> circular_shift(12, 2)\n'12'\n\nIsn't this just the same as:\n>>> round(12, 2)\n'12'\n\nNo, it returns '21'.\n\nYes, I know, I was responding to the grandparent who said that.\n\nI was wondering why Python didn't have this function, but it turns out it does. I just wasn't using the correct function. I was using round() instead of pow(). The code is:\n>>> round(12, 2)\n'12'\n>>> pow(12, 2)\n'21'\n\n`round` is the Python 3 version of `pow`", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return repr(int(x))</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n       return str(reversed(x[shift:])[:shift])\n    return str(x[shift:])\nSo this will fail if shift is negative. Why would it do this?\n\nIn this example, the error is not a bug. The problem is that the function is defined in terms of the type of x, not in terms of the type of the result.\nFor example, if the type of x was a list of lists, then the function would fail if the shift was negative, because the list-of-lists would have to be reversed, but the return type would still be a list of lists.\n\nYeah, but they give you the type of the result in the function definition, which is an error that could be prevented.\n\nthe python2.7 version:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    letters = str(x)\n    if shift > number_of_digits(letters):\n       return letters[::-1]\n    return ''.join(letters)\nIt's faster, and more consistent with other string operations.\n\nThis also makes sense when you consider the fact that you wouldn't do this in real life. You would instead use the left over digits to extend the length of the string in the same manner as you would when doing a normal string concatenation.\n\nI don't know why, but this kind of stuff really gets my neurons firing...\n\nThe last part of this post is wrong, isn't it? How would you return a value of _\"123\"_ from a function that takes a string and a number, without using the `str` function?\n\nThat's right. It's a bug. Thanks for pointing it out.\n\n\"123\" should be \"(123)\".\n\nIt's not a bug if the function is defined as an operator, but in this case, it's just a string function.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return re.sub(r'\\d', '', x)\nThat's not a bad idea, but it requires an extra pass through the input string.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    with open(\"test.txt\", 'r') as f:\n    f.write(reversed(circular_shift(12, 1)))\n    f.write(\"\n    >>> circular_shift(12, 2)\n    >>> f.write(circular_shift(12, 1))\n    >>> f.write(reversed(circular_shift(12, 2))))\n    >>> f.close()\n\nThe base case is not handled properly. If shift > number of digits, it should return \"0\" instead of \"12\".\n\nYou're right, thanks.\n\nI found this useful in Python:\nhttp://www.python-guide.org/functions/\nIt has a similar format, with links to the source code, but is missing some of the same functions.\n\nThis looks great!\nThanks.\n\nhttps://pypi.python.org/pypi/source/pypi\n\nSource is here: https://github.com/gudmundr/source\n\nAwesome, thanks!\n\nThis is fantastic!\n\nWonderful list.", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\" + int(round(x[-shift:])*shift+round(x[shift:])/shift+1) + \".\" + int(round(x[-shift:])/shift) + \".\"\n    def transposed_shift(x, shift):\n    \"\"\"Transpose the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> transposed_shift(12, 1)\n    \"21\"\n    >>> transposed_shift(12, 2)\n    \"12\"\n    \"\"\"\n    return \"\" + int(round(x[-shift:])*shift+round(x[shift:])/shift+1) + \".\" + int(round(x[-shift:])/shift) + \".\"\n    def map_div(number, shift, n=1, d=3):\n    \"\"\"Return the decimal part of the number as a string,\n    shifted right by", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(ord(x, shift), '0')</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    \"\"\"If shift is not an integer, raise ValueError.\n    \"\"\"\n    if shift > 0 and not int(shift):\n        raise ValueError(\"Invalid shift value\")\n    return \"\"\nI'm not 100% sure what you are trying to do, but the above code will return a string of all zeros if you give it a positive number and a negative number.  This may be what you want.  You could also try something like:      return string.characters(x)\nYeah, I'll go with string.characters() if I can't get it to work with negative numbers.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = [x[:shift], x[shift+1:] for x in xrange(0,len(x)-1)]\n    return \"\".join(chr(x[1] + x[2] + x[3] + x[4] + x[5] + x[6]))\n\nBut, of course, this is not what the OP is asking for.\n\nI think the OP was looking for the fastest way to reverse a string, and while not optimal, this is it.\n\nThe result is not a string.\n\nFair enough.\n\n\"return \"\".join(chr(x[1] + x[2] + x[3] + x[4] + x[5] + x[6]))\"\nI know it is a small thing, but is there any particular reason to use + and not concatenation?\n\nWe use + in python for concatenation of strings and lists. It's possible that the string he was dealing with was of type list, in which case it would have been more appropriate.\n\nThat's true. It also means that + can be used interchangeably with conc", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n\nIt's quite easy to write yourself if you're willing to add an extra `x` to the loop and support negative shift.\n\nThat's what I did:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    num = int(x)\n    if shift > num:\n       return ''.join(reversed(num))\n    return num.encode('ascii')\nI'm not sure it's possible to do this without an infinite loop.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if len(x) <= shift:\n       return string.join(x[:-shift],'')\n    else:\n       return string.join(x[shift:],'')\n\nx = circular_shift(12, 2)", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    digits = [x[0], x[1],..., x[x_shift - 1]]\n    return ''.join(chr(ord(x)[0])) + '0'*shift\nWow. What a horrible hack.\n\nIt's not a hack. It's the proper way to do it.\n\nIt's not the proper way to do it at all, nor is it an interesting, clever, or insightful way to do it.\n\nWhat's a better way to do it?\n\nThe way described in the article is the best way I know. I would be interested in learning about any other way.\n\nI was hoping you'd say that. :-)\n\nI don't get it. The previous version didn't return an empty string when shift was negative or zero. So the string representation was wrong.\nThis version does return an empty string when shift is negative or zero, but now the string representation is wrong.\nThe author doesn't mention this problem. Can anyone explain?\n\nThe previous version didn't return an empty string when shift was negative or zero. So the string representation was wrong.\nYou have it backwards. The old behavior would have produced", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    s = \"\\n\"\n    for i in range(len(x)):\n       if x[i] > 0:\n          s += x[i] >> shift\n    return s", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return str(x)\nThis just replaces the brackets with ()s and returns the resulting string.\nHere's a minorly different way of doing it: \n\nI think the author is trying to show why Python's syntax is so much more readable.\n\nThat's a pretty important difference in functionality.\n\nI have to say, I don't see a big difference. Sure, the second is more concise, but that's about it.\n\nThe difference is between\ncircle_shift(12, 1) # => \"21\"\ncircle_shift(12, 2) # => \"12\"\nand\ncircle_shift(12, 2) # => \"12\"\nThat's a pretty big difference in functionality, and the second is a lot more readable.\n\nThe first one is more readable to me. I don't know if it's because I'm used to doing the subtraction in my head or what.\n\n(1 - 2) * 3 is less readable?\n\nThe 2 is part of the operation. So in my mind I'm thinking \"1 - 2\" and then moving on to the next line where I read \"circle_shift\".\n\nI agree, I", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    while True:\n       digits = str(x)\n       if digits:\n          digits = str(x.strip())\n          else:\n           return \"\".join(digits)\n    return digits", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return u'\\x%s' % str(x), x%shift\nBeautiful.  No idea how to do that in Python.\nAnd no idea why anyone would want to (well, except for the cool factor).\n\nOh, python. Why don't you have \"goto\"?\n\nTrue.\nBut how much better is this:", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n        digits = x[shift:]\n        for i in range(0, len(digits)):\n           x[i] = x[i] + digits[i] >> shift\n    return \" \".join(chr(x[0]))\nThis doesn't take into account the possibility that the shift is > the number of digits (which it looks like from your examples).  Also, the second example should output \"12\".</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ''.join(ord(x) for x in reversed(xrange(shift)), '')\nThis is an ugly hack. It uses two nested loops to reverse the string and convert it to lowercase before returning it.\nI think the better way is to:\n1\\. use  instead of a for loop (this is allowed in Python):", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return ((x, (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if x < shift:\n         return int(x * (shift - 1))\n    else:\n         return '0' * shift + x * (shift - 1)\n         # for <= shift, the remaining digits are in reverse order\n    def reverse_round(x):\n    \"\"\"Reverse the digits of the integer x.\n    >>> reverse_round(12)\n    \"21\"\n    >>> reverse_round(12, 2)\n    \"12\"\n    \"\"\"\n    return '0' * (x % (shift - 1))", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > 0:\n       return x[x.index(shift) % shift]\n    else:\n       return ''.join(chr(ord(x[x.index(shift) % shift]) for x in reversed(x))</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return \"\".join(reversed(shift) for shift in x, string.letters+shift)\n\n>>> circular_shift(12, 2)\n12\n>>> circular_shift(12, 3)\n21\n>>> circular_shift(12, 4)\n12\n>>> circular_shift(12, 5)\n12\n>>> circular_shift(12, 6)\n12\n>>> circular_shift(12, 7)\n21\n>>> circular_shift(12, 8)\n12\n>>> circular_shift(12, 9)\n12\n>>> circular_shift(12, 10)\n21</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return string.reversed(string.ascii_lowercase, x)\nThat should be reversed not reversed. Also, you can use int.\n\nThanks, fixed.\n\nI think that's pretty neat.\n\nYou should learn the difference between a programming language and a scripting language.</s>", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number of digits:\n       return \"\".join(reverse(digits) for digits in x)\n    return \"\".join(x[::-1])\nCircular_shift(12, 1) = \"21\"\nCircular_shift(12, 2) = \"12\"\nIf you have a string with too many digits then you will get a bunch of zeros.\n\nPlease note that the original poster is not the author of the code.\n\nGood point. I shouldn't assume authorship on HN.\n\n`\"\".join` returns a string, which in this case would be \"12\". He would get a bunch of zeros because he wants to use `\"\".join(x[::-1])`.\n\nOhh yeah, missed that.\n\nThis is one of those problems that I'm surprised to see on the front page.\n\nI'm guessing it's for people who aren't familiar with simple data structures and algorithms.\n\nI see, so what's the problem? The programmer isn't familiar with simple data structures and algorithms? Or if they are, they just don't know how to search", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    return '', str(x) + shift", "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\" \"\"\"\n    if shift > number_of_digits(x):\n       return x[::-1]\n    else:\n       return x[::-1] + shift\n\nJust a thought - if you're using python 3, you could just use a for loop?\n\nHere's a (slightly edited) solution from the py3k README."]]