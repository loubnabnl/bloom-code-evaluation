[["def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    #-----------------------------\n    # Return an array of the right length, modulo p\n    #-----------------------------\n    # min: function that returns the minimum of the array\n    # max: function that returns the maximum of the array\n    #--------------------------------------------------------\n    # The min function works with arrays of a specified length\n    # The max function works with arrays of a specified length and\n    # returns 1 if the function was successful, 0 otherwise\n    #\n    # @param n: the length of the array\n    # @param p: the index of the element that should be mod\n    # @return: an array of the right length, modulo p\n    #-----------------------------\n    def modp(n: int, p: int):\n        #-----------------------------\n        # Return an array of the right length, modulo p\n        #-----------------------------\n        return [modp(n, p) for n, p in zip(range(n), p)]\n    #--------------------------------------------------------\n    # The max function works with arrays of a specified length\n    # The min function works with arrays of a specified length and\n    # returns 0 if the function was successful, 1 otherwise\n    #\n    # @param n: the length of the array\n    # @param p: the index of the element that should be mod\n    # @return:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    p = 0\n    if n <= 3:\n        p = modp(n, 5)\n    elif n <= 11:\n        p = modp(n, 11)\n    elif n <= 11:\n        p = modp(n, 1)\n    if p < 0:\n        raise ValueError(\"Invalid value for modp(n, p).\")\n    return p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n % p == 0:\n        return n % p\n    elif n % p == 1:\n        return n % p\n    else:\n        raise Exception('Incorrect modulo: n % p!= 1')", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modulo(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return np.mod(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p!= 0:\n        raise ValueError('Integer p must be zero or positive')\n    return (n * (p / 2)) - (n * 2 * 2) * (p % 2)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    ret = n * p\n    if ret < 0:\n        raise ValueError(\"modp(%d,%d): failed to reduce integer\" % (ret, p))\n    return ret", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp(3, 5)\n    modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p) + 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def modp_invariant(n: int):\n        if n < 0 or n > 1:\n            raise ValueError(\"Invalid number of bits in exponent\")\n        else:\n            return n % 1\n\n    def modp_exp(n):\n        if n < 0 or n > 1:\n            raise ValueError(\"Invalid number of bits in exponent\")\n        if n % 1!= 0:\n            raise ValueError(\"Invalid exponent fraction\")\n        if n % 1000!= 0:\n            raise ValueError(\"Invalid exponent fraction\")\n        return n % 1\n\n    def modp_concat(n):\n        if n < 0 or n > 1:\n            raise ValueError(\"Invalid number of bits in exponent\")\n        if n % 1!= 0:\n            raise ValueError(\"Invalid exponent fraction\")\n        if n % 1000!= 0:\n            raise ValueError(\"Invalid exponent fraction\")\n        return n % 1\n\n    modp_invariant(101)\n\n    modp_exp(101)\n\n    modp_concat(101)\n\n    modp_invariant(101)\n\n    modp_exp(101)\n\n    modp_invariant(101)\n\n    modp_exp(101)\n\n    modp_exp(101)\n\n    modp_invariant(101)\n\n    modp_exp(101)\n\n    modp_exp(101)\n\n    modp_exp(101)\n\n    modp_invariant(101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n % 2 == 0:\n        return 1\n    elif n % 2 == 1:\n        return (n % 2) * (p + 1)\n    elif n % 2 == 2:\n        return (p + 1) * (n - 1)\n    elif n % 2 == 3:\n        return (n - 1) * (n - p + 1)\n    elif n % 2 == 4:\n        return (n - p - 1) * (n - (n - p - 1))\n    elif n % 2 == 5:\n        return (n - p - 1) * (n - (n - (n + p - 1)))\n\n    if n % 2 == 0:\n        return n * (n - 1)\n    elif n % 2 == 1:\n        return (n * p - 1) * (n - p + 1)\n    elif n % 2 == 2:\n        return (n * p + 1) * (n - p + 1)\n    elif n % 2 == 3:\n        return (n * p + 1) * (n - p + 1)\n    elif n % 2 == 4:\n        return (n * p + 1) * (n - p + 1)\n    elif n % 2 == 5:\n        return n * p + 1\n\n    if n % 2 == 0:\n        return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return 2*n\n    else:\n        return 2**n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2**p*((1<<p)-1)^n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # make a function that takes one argument (n, p) and returns 2^n modulo p\n    fn = lambda n: p - n\n\n    def func(n: int, p: int):\n        \"\"\"Return a function that takes n and returns an integer that is a modulo\n        of p.\n        >>> fn(4, 5)\n        4\n        >>> fn(100, 101)\n        1\n        >>> fn(3, 11)\n        8\n        >>> fn(1101, 101)\n        1\n        >>> fn(0, 101)\n        1\n        >>> fn(3, 11)\n        8\n        >>> fn(100, 101)\n        1\n        \"\"\"\n        m = p + n\n        if m in (0, 1):\n            return m\n        return fn(m)\n\n    def retmodp(n: int, p: int):\n        \"\"\"Return n mod p (be aware of numerics).\n        >>> retmodp(4, 5)\n        4\n        >>> retmodp(100, 101)\n        1\n        >>> retmodp(3, 11)\n        8\n        >>> retmodp(1101, 101)\n        1\n        >>> retmodp(0, 101)\n        1\n        >>> retmodp(3, 11)\n        8\n        >>> retmodp(100, 101)\n        1\n        \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2**(n - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"numerical overflow\")\n    elif n == 0:\n        return 0\n    if p == 0:\n        return 1\n    if n % n == 0:\n        return 0\n    if p % p == 0:\n        return 0\n    if p % n == 1:\n        return 0\n    if p % n == 2:\n        return 0\n    if p % n == 3:\n        return 0\n    if n % n == 4:\n        return 0\n    if p % n == 5:\n        return 0\n    if n % n == 6:\n        return 0\n    if p % n == 7:\n        return 0\n    if n % p == 0:\n        return 0\n    if p % n == 10:\n        return 0\n    if p % n == 11:\n        return 0\n    if n % p == 12:\n        return 0\n    if p % n == 13:\n        return 0\n    if p % n == 14:\n        return 0\n    if n % p == 15:\n        return 0\n    if p % n == 16:\n        return 0\n    if n % p == 17:\n        return 0\n    if n % p == 18:\n        return 0\n    if n % p == 19:\n        return 0\n    if n % p == 20:\n        return 0\n    if n % p == 21:\n        return 0\n    if n % p ==", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 2:\n        return 1\n    if n == 3:\n        return modp(11, 5)\n    if n == 4:\n        return modp(1010, 101)\n    if n == 5:\n        return modp(101, 11)\n    if n == 6:\n        return modp(1011, 101)\n    if n == 7:\n        return modp(1010, 101)\n    if n == 8:\n        return modp(100, 11)\n    if n == 9:\n        return modp(100, 101)\n    if n == 10:\n        return modp(101, 11)\n    if n == 11:\n        return modp(100, 101)\n    if n == 12:\n        return modp(101, 11)\n    if n == 13:\n        return modp(100, 11)\n    if n == 14:\n        return modp(101, 11)\n    if n == 15:\n        return modp(100, 11)\n    if n == 16:\n        return modp(100, 11)\n    if n == 17:\n        return modp(100, 11)\n    if n == 18:\n        return modp(100, 11)\n    if n == 19:\n        return modp(100, 11)\n    if n == 20:\n        return modp(100, 11)\n    if n == 21:\n        return modp(100, 11)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(p, int):\n        return n % p\n    elif isinstance(p, float):\n        return 1 ** (p * p)\n    elif isinstance(p, long):\n        return n % p\n    elif isinstance(p, bool):\n        return np.isnan(n % p)\n    elif isinstance(p, int) and np.isnan(np.abs(n % p)):\n        return np.abs(np.abs(n % p)) % p\n    elif isinstance(p, float):\n        return np.abs(np.abs(n % p)) ** (p * p)\n    elif isinstance(p, int) and np.isinf(np.abs(n % p)):\n        return np.inf(np.abs(n % p)) % p\n    elif isinstance(p, long):\n        return np.abs(np.abs(n % p)) ** (p * p)\n    elif isinstance(p, bool):\n        return np.isnan(np.abs(n % p)) % p\n    elif isinstance(p, int) and np.isinf(np.abs(n % p)):\n        return np.inf(np.abs", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = int(n)\n    p = int(p)\n\n    for i in range(0, n):\n        for j in range(0, p):\n            result = modp(n, i + j)\n            if result == 0:\n                return j\n            elif result == 1:\n                return i\n            elif result == 2:\n                return i + p\n            elif result == 3:\n                return j + p\n    return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"invalid number type '%s'\" % n)\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 1: return 1\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return modp(n, p)\n    elif isinstance(n, list):\n        for x in n:\n            if isinstance(x, int):\n                return modp(x, p)\n            elif isinstance(x, list):\n                return modp(x, p)\n\n    elif isinstance(n, (int, int, int)):\n        return modp(n, p)\n\n    elif isinstance(n, list):\n        for x in n:\n            if isinstance(x, int):\n                return modp(x, p)\n\n    if isinstance(n, (int, int, int)) and len(n) > 3:\n        raise ValueError(\"modp(%d, %d) raises TypeError\" % (n, p))\n    elif isinstance(n, (int, int, int)) and len(n) > 2:\n        raise ValueError(\"modp(%d, %d) raises TypeError\" % (n, p))\n\n    if isinstance(n, (int, int, int)) and len(n) > 1:\n        raise ValueError(\"modp(%d, %d) raises TypeError\" % (n, p))\n\n    return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > p:\n        raise ValueError('numeric out of range')\n    if isinstance(p, int):\n        return 2 * p * n\n    elif isinstance(n, int):\n        return p * n\n    if isinstance(p, int) == (n, int):\n        raise ValueError('invalid integer in modp(' + str(p) + ','+ str(n) + ')')\n    return n * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return p\n    if n == 1:\n        return p\n    if n == 2:\n        return p\n    if n == 3:\n        return p\n    if n == 4:\n        return p\n    if n == 5:\n        return p\n    if n == 6:\n        return p\n    if n == 7:\n        return p\n    if n == 8:\n        return p\n    if n == 9:\n        return p\n    if n == 10:\n        return p\n    if n == 11:\n        return p\n    if n == 12:\n        return p\n    if n == 13:\n        return p\n    if n == 14:\n        return p\n    if n == 15:\n        return p\n    if n == 16:\n        return p\n    if n == 17:\n        return p\n    if n == 18:\n        return p\n    if n == 19:\n        return p\n    if n == 20:\n        return p\n    if n == 21:\n        return p\n    if n == 22:\n        return p\n    if n == 23:\n        return p\n    if n == 24:\n        return p\n    if n == 25:\n        return p\n    if n == 26:\n        return p\n    if n == 27:\n        return p\n    if n == 28:\n        return p\n    if n == 29:\n        return p\n    if n == 30:\n        return p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # 2^n modulo p\n    result = n * p\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n in range(3):\n        return modp(n, p)\n    elif n in range(5):\n        return modp(n, p)\n    elif n in range(1101):\n        return modp(n, p)\n    elif n in range(101):\n        return modp(n, p)\n    elif n in range(100):\n        return modp(n, p)\n    elif n in range(11):\n        return modp(n, p)\n    elif n in range(101, 1):\n        return modp(n, p)\n    elif n in range(101, 11):\n        return modp(n, p)\n    elif n in range(100, 101, 1):\n        return modp(n, p)\n    elif n in range(101, 101, 11):\n        return modp(n, p)\n    elif n in range(100, 101, 111):\n        return modp(n, p)\n    else:\n        return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 10 * p:\n        raise TypeError(\"Expected to be between 10 and 101\")\n    if n < 10 * p and n % p == 0:\n        raise TypeError(\"Expected to be between 10 and 101\")\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = n / 2\n    return n % 2 ** p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    a = 3\n    b = 5\n    c = 111\n    d = 101\n    e = 0\n    f = 0\n    g = 0\n    h = 0\n    i = 0\n    k = 0\n    l = 0\n    m = 0\n    n = 0\n    o = 0\n    p = 0\n    q = 0\n    r = 0\n    s = 0\n    t = 0\n    v = 0\n    u = 0\n    w = 0\n    x = 0\n    y = 0\n    z = 0\n    xc = 0\n    yc = 0\n    zc = 0\n    x1 = 0\n    x2 = 0\n    x3 = 0\n    y3 = 0\n    z3 = 0\n\n    def modp(n, p: int):\n        if p > 0:\n            return modp(n, p - 1)\n        else:\n            return -1\n\n    modp = modp\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp = modp\n\n    modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    m = 2**n\n    if m!= 2:\n        raise ValueError(\"modp() expects an integer.\")\n\n    return int(n * m + p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Pass in the right number\n    n = n % 5\n    # Assume the left number is either 0 or 1\n    p = n % 5\n    # Then return 3**15 + 2*p\n    if n % 5 == 0:\n        return 3*modp(p, n)\n    if p % 5 == 0:\n        return 2*modp(n, p)\n    return p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (1 + (-p) * (2 * p)) % n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # must be 2^n\n    for i in range(n):\n        if p < i:\n            return modp(i, p)\n    return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    while n >= 1:\n        for i in range(1, n):\n            if p == i:\n                break\n    if n <= p:\n        return modp(p, n)\n    else:\n        return modp(p, n - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return int(modp(3, p+1)).astype(int) + int(modp(11, p+1)).astype(int)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (modp(n, p) == 3 or modp(n, p) == 5 or modp(n, p) == 111)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(p):\n            result = result * (1. + i * j)\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # get the elements\n    u, v, w = 0, 1, 0\n    d = n * (p >> 1)\n    a = d * u\n    b = d * v\n    c = d * w\n    d = u + v + w\n    return u * d + v * d + w * d", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > 1:\n        raise ValueError(\"only one modp() function can be used\")\n    if p > 1:\n        raise ValueError(\"only one modp() function can be used\")\n\n    modp(n, p) = n*p\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p is None:\n        p = 0\n    if n is None:\n        n = 1\n    try:\n        modp(p, n)\n    except (ValueError, TypeError):\n        raise ValueError(\"%d = %d\" % (n, p))\n    return p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > p:\n        raise ValueError, \"Modulus not allowed\"\n    if n < p:\n        raise ValueError, \"Modulus not allowed\"\n    modp = p - n\n    return modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    # This is the way it works\n    # @global int modp\n    # @global int modp\n    # @global int modp\n    #\n    # Result of module modp (define modp to return 2^n modulo p)\n    # @return: 2^n modulo p\n    def modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        if p < 0:\n            return 2 - n * p\n        elif p > n:\n            return 2 + n * p\n        return n\n    # @global int modp\n    # @global int modp\n    # @global int modp\n    #\n    # Result of module modp (define modp to return 1^n modulo p)\n    # @return: 1^n modulo p\n    def modp(n: int, p: int):\n        \"\"\"Return 1^n modulo p (be aware of numerics).\"\"\"\n        if p < 0:\n            return 1 - n * p\n        elif p > n:\n            return 1 + n * p\n        return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(x: int, y: int):\n        return x % y\n\n    def modp(n: int, p: int):\n        return n % p\n\n    def modp(n: int, p: int, q: int):\n        return n % (2**p - 1) * q\n\n    def modp(n: int, p: int):\n        return n % p\n\n    def modp(n: int, p: int, q: int, r: int):\n        return n % (2**p - 1) * q\n\n    def modp(n: int, p: int, q: int, r: int):\n        return n % (2**p - 1) * r\n\n    def modp(n: int, p: int, q: int, r: int, q: int):\n        return n % (2**p - 1) * r\n\n    def modp(n: int, p: int, q: int, r: int, q: int, q: int):\n        return n % (2**p - 1) * r\n\n    def modp(n: int, p: int, q: int, r: int, q: int, r", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return (n % 2) * 2 ** n\n    elif isinstance(p, int):\n        return p * (2 ** p)\n    else:\n        raise ValueError(\"Can't convert \" + str(p) + \" to \" + str(n) + \" modp.\")", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (2 * n) * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 0:\n        return modp(n - 1, p)\n    elif n == 1:\n        return modp(1, p)\n    elif n == 2:\n        return modp(2, p)\n    elif n == 3:\n        return modp(3, p)\n    elif n == 4:\n        return modp(4, p)\n    elif n == 5:\n        return modp(5, p)\n    elif n == 6:\n        return modp(6, p)\n    elif n == 7:\n        return modp(7, p)\n    elif n == 8:\n        return modp(8, p)\n    elif n == 9:\n        return modp(9, p)\n    elif n == 10:\n        return modp(10, p)\n    elif n == 11:\n        return modp(11, p)\n    elif n <= 12:\n        return modp(n, p)\n    elif n == 13:\n        return modp(n, p)\n    elif n <= 14:\n        return modp(n, p)\n    elif n <= 15:\n        return modp(n, p)\n    elif n <= 16:\n        return modp(n, p)\n    elif n <= 17:\n        return modp(n, p)\n    elif n <= 18:\n        return modp(n, p)\n    elif n <= 19:\n        return", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(p, int):\n        p = int(p)\n    return modp(p, n)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > 2:\n        return (2 ** p) % n\n    else:\n        return (2 ** p) % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2 * (pow(2, n) + pow(2, p))", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > 1:\n        return n * p\n    return modp(p, n - 1) * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    m = (2 * n) // p\n    return (m * modp(n, p))", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    if n < 0:\n        raise ValueError(\"n is not positive\")\n\n    if p < 0 or n % p!= 0:\n        raise ValueError(\"p is not positive\")\n\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"modp() must take a positive integer as a return value\")\n    result = n % p\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2 * (n % p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 1:\n        return -1\n    elif p > 1:\n        return 1\n    elif n < 2:\n        return -1\n    elif p > 2:\n        return 1\n    elif n < 3:\n        return -1\n    elif p > 3:\n        return 1\n\n    # return -1 for n <= 0\n    if n < 0:\n        return -1\n    elif p > 0:\n        return -1\n    elif n < 4:\n        return -1\n    elif p > 4:\n        return -1\n\n    # return 1 for n <= 0\n    if n < 1:\n        return 1\n    elif p > 1:\n        return 1\n    elif n < 2:\n        return 1\n    elif p > 2:\n        return 1\n    elif n < 3:\n        return 1\n    elif p > 3:\n        return 1\n\n    # return 0 for n <= 0\n    if n < 0:\n        return 0\n    elif p > 1:\n        return 0\n    elif n < 2:\n        return 0\n    elif p > 2:\n        return 0\n    elif n < 3:\n        return 0\n    elif p > 3:\n        return 0\n\n    # return -1 for n <= 0\n    if n < 1:\n        return -1\n    elif p > 2:\n        return -1\n    elif n < 3:\n        return -1\n    elif p > 3:\n        return -1\n\n    # return 0 for n <= 0\n    if n < 1:\n        return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Return modulo p of an integer value.\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0:\n        return -1\n    if p < 0:\n        return 1\n    if n % p!= 0:\n        return -1\n    if n == 1:\n        return 0\n    if p == 1:\n        return 1\n    if p == 2:\n        return -1\n    if p == 3:\n        return 0\n    if p == 4:\n        return 1\n    if p == 5:\n        return -1\n    if p < 0:\n        return -1\n    if n % p == 0:\n        return -1\n    if n == 1:\n        return -1\n    if p == 1:\n        return -1\n    if p == 2:\n        return -1\n    if p == 3:\n        return -1\n    if p == 4:\n        return 1\n    if p == 5:\n        return -1\n    if p < 0:\n        return -1\n    if n % p == 0:\n        return -1\n    if n == 1:\n        return -1\n    if p == 1:\n        return -1\n    if p == 2:\n        return -1\n    if p == 3:\n        return -1\n    if p == 4:\n        return -1\n    if p == 5:\n        return -1\n    if p < 0:\n        return -1\n    if n % p == 0:\n        return -1\n    if n == 1:\n        return -1\n    if p == 1:\n        return -1\n    if p == 2:\n        return -1\n    if p == 3:\n        return", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    if n >= 3:\n        return 2\n    if p < 0:\n        return n * p\n    if p > 1:\n        return n * p + 1\n    if p < 1 or p > 3:\n        return n * (n * p) * p\n    if n == 1:\n        return 0\n    if n == 2:\n        return p\n    if n == 3:\n        return 1\n    if n == 4:\n        return 1\n    if n == 5:\n        return 1\n    if n == 6:\n        return 1\n    if n == 7:\n        return 0\n    if n == 8:\n        return 1\n    if n == 9:\n        return 0\n    if n == 10:\n        return 0\n    if n == 11:\n        return 1\n    if n == 12:\n        return 0\n    if n == 13:\n        return 1\n    if n == 14:\n        return 0\n    if n == 15:\n        return 1\n    if n == 16:\n        return 1\n    if n == 17:\n        return 1\n    if n == 18:\n        return 0\n    if n == 19:\n        return 0\n    if n == 20:\n        return 1\n    if n == 21:\n        return 0\n    if n == 22:\n        return 1\n    if n == 23:\n        return 1\n    if n == 24:\n        return 1\n    if n == 25", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics)\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n        >>> modp(3, 11, 101)\n        3\n        >>> modp(100, 111, 101)\n        1\n        \"\"\"\n        return modp(n, p)\n    def modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics)\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n        >>> modp(3, 11, 101)\n        3\n        >>> modp(100, 111, 101)\n        1\n        \"\"\"\n        return modp(n, p)\n\n    def modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics)\n        >>> modp(3, 5)\n        3", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 1:\n        raise TypeError(\"The modulus of a positive integer must be 1.\")\n    return n * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > 10 or p > 1:\n        raise TypeError(\"modp(%d, %d) must be a multiple of p\" % (n, p))\n    modp(n, p)\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def modp(m, p: int):\n        if p > 0:\n            return p * m\n        else:\n            return m\n\n    def modp(mods: int, p: int):\n        if p > 0:\n            return p * (mods * mods)\n        else:\n            return (mods * (mods - 1))\n\n    def modp(mods: int, p: int):\n        if p > 0:\n            return p * (mods * mods + 1)\n        else:\n            return (mods * (mods - 1) - mods)\n\n    def modp(mods: int, p: int, mods: int):\n        return modp(mods, p)\n\n    def modp(mods: int, p: int):\n        return modp(mods, p)\n\n    def modp(mods: int, p: int, mods: int, mods: int):\n        return modp(mods, p)\n\n    def modp(mods: int, p: int, mods: int):\n        return modp(mods, p)\n\n    def modp(mods: int, p: int, mods: int, mods: int):\n        return modp(mods, p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(p, int):\n        p = int(p)\n    m = (p % 10) or p % 100\n    x = 0\n    for i in range(10):\n        if m * i < p:\n            x += i\n    return x", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(p + 1, n)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n % 2 == 0:\n        return 2**n - 1\n    if n % 4 == 0:\n        return 1**n - 1\n    if n % 8 == 0:\n        return 0**n - 1\n    if n % 16 == 0:\n        return 0**n - 1\n    return 1**n - 1 - (1 - n / 2)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return n * p\n    else:\n        return n * p + p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p < 3:\n        return (n % (p - 1)) * (p - 1)\n    if p > 1:\n        return (n % (p - 1) + 1)\n    return (n % (p - 1) - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    return 2*(n-p)*p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    #\n    # first, check the modulus is right- or left- signed;\n    # usually it is right- signed;\n    # for sure, this is the most easily handled case (if p = 0 or -1\n    # then return 0, otherwise return 1). For example, if p = -1, then\n    # modp(0, -1) returns -1, and the answer is -1, which is the first\n    # sign of the right- or left- sign (0, -1, 1, 0, 1).\n\n    if p!= -1:\n        return modp(0, p)\n\n    # second, check the sign is not right- or left- signed;\n    # generally it is not right- signed;\n    # for sure, this is the most easily handled case (if p = 0 or -1\n    # then return -1, otherwise return 0).\n\n    if p!= 0:\n        return modp(0, -1)\n\n    # finally, check if p is an integer;\n    # in that case, modp returns an integer number (the first\n    # non-negative integer) modulo p.\n    if p!= 0:\n        return modp(p, p)\n\n    # finally, check if the answer is the right- or left-", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    i = n % 10\n    p = int(round(i, 10))\n    if p < 0:\n        raise TypeError('invalid modulo %s' % (p))\n    if i % 10!= 0:\n        raise TypeError('invalid modulo %s' % (i))\n\n    def mod(n: int, p: int):\n        \"\"\"Return modulo p, but leave the base unchanged.\n        >>> mod(1, 2)\n        3\n        >>> mod(11, 101)\n        1\n        >>> mod(100, 111)\n        1\n        >>> mod(3, 11)\n        8\n        >>> mod(10, 101)\n        1\n        >>> mod(100, 100)\n        1\n        >>> mod(11, 11)\n        8\n        >>> mod(100, 10)\n        1\n        >>> mod(1, 1)\n        1\n        >>> mod(3, 1)\n        3\n        >>> mod(11, 1)\n        5\n        >>> mod(100, 100)\n        1\n        \"\"\"\n\n        p = int(round(p, 10))\n        if p % 10 == 0:\n            raise TypeError('invalid modulo %s' % (p))\n        if i % 10!= 0:\n            raise TypeError('invalid modulo %s' % (i))\n\n    def modp(n: int, p: int):\n        \"\"\"Return modulo p modulo n,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    \"\"\"\n    >>> m = 1 << (n * p)\n    >>> m <<= p\n    >>> modp(m, m * 3)\n    3\n    >>> modp(m, m * 5)\n    3\n    >>> modp(m, m * 11)\n    8\n    >>> modp(m, m * 101)\n    1\n    \"\"\"\n    if p < 0:\n        return 0\n    if n < 0:\n        return n\n    if p > 1:\n        return n * p\n    return 2 ** p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (modp(3, 5) / 5) % 5", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n**(p-1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # math.modmodp gives a special case, not the whole one\n    if n > 1:\n        n = n - 1\n    return (n % 2) * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    i, k = n, p\n\n    result = 0\n    for i in range(n):\n        result += modp(i, k)\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (n % p) * p + n / (p - 1) - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 5 or n >= 101:\n        raise ValueError(\"Invalid number of mods\")\n    elif n < 0:\n        raise ValueError(\"Invalid number of mods\")\n    if p > n or p < 0:\n        raise ValueError(\"Invalid number of mods\")\n    return n * p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p == 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return n * p\n    elif n == 1:\n        return n * p + (n / 2) * p\n    elif n == 2:\n        return n * p + (n / 2) * p / 2\n    elif n == 3:\n        return n * p - (n / 2) * p / 2\n    else:\n        raise ValueError('Integer cannot be modded to integral value')\n    return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 0:\n        raise TypeError\n    if n == 0:\n        return modp(0, 0)\n    if n == 1:\n        return modp(0, 1)\n    if n == 3:\n        return modp(0, 0)\n    if n == 11:\n        return modp(0, 0)\n    if n == 101:\n        return modp(0, 0)\n    if n == 111:\n        return modp(0, 0)\n    if n == 1111:\n        return modp(0, 0)\n    if n < 101:\n        raise ValueError\n    if n < 110:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 1111 or n < 1111:\n        raise ValueError\n    if n < 111:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 101:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 1:\n        raise ValueError\n    if n < 111:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 101:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n    if n < 1111:\n        raise ValueError\n\n    if n < 1:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 2\n    if p == 0:\n        return n - 1\n    if p == 2:\n        return n\n    if n % p == 0:\n        return -1\n    if p % n == 0:\n        return 0\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return np.modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        return modp(n, p)\n    except ValueError:\n        return 1\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # the total number of bits, modulo p\n    result = -1\n    for i in range(n):\n        result = result * (p - i)\n    return result\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    p = int(p)\n\n    if n > 0:\n        return modp(n, p)\n\n    return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = (n % 2) + 1\n    p = (n % 7) + 1\n\n    try:\n        if n % 4 == 0:\n            return 1\n        elif n % 6 == 0:\n            return 2\n        elif n % 2 == 0:\n            return 3\n        elif n % 3 == 0:\n            return 4\n        elif n % 1 == 0:\n            return 5\n        elif n % 0 == 0:\n            return 6\n        else:\n            return -1\n\n    except ValueError:\n        return -1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    p = p % 2\n    n = n % 2\n    modp(n, p)\n    modp(p, n)\n    modp(n, p)\n    modp(p, n)\n    modp(n, p)\n    modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = -1\n    for i in range(n):\n        result = result * p\n\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = n + 1\n    p = p + 1\n    modp = (n * p) % p\n    if not isinstance(modp, (int, long)):\n        raise TypeError(modp)\n    return modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == p:\n        return 0\n    return math.mod(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        n = int(n)\n    if isinstance(p, int):\n        p = int(p)\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return int(mod(n, p) * (p - 1)) % (1 + p - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 0:\n        # the modulus is 2, so return the whole\n        return modp(n, p)\n    if n >= 1:\n        # the modulus is n, so return the remainder\n        return modp(n - 1, p)\n    if n == 1:\n        # the modulus is -1, so return the whole\n        return modp(n, -1)\n    if n == -1:\n        # the modulus is -1, so return the remainder\n        return modp(n - 1, -1)\n    if n > -1:\n        # the modulus is -1, so return the whole\n        return modp(n, -1)\n    if n < -1:\n        # the modulus is -1, so return the whole\n        return modp(n, -1)\n    if n == 0:\n        # the modulus is 0, so return the whole\n        return modp(n, 0)\n    if n == 1:\n        # the modulus is 1, so return the whole\n        return modp(n, 1)\n    if n == -1:\n        # the modulus is -1, so return the whole\n        return modp(n - 1, 0)\n    if n == 0:\n        # the modulus is -1, so return the whole\n        return modp(n, -1)\n    return modp(n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    r = n % p\n    if r!= 0:\n        raise ValueError(r'%r' % r)\n    return r", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(p, int):\n        return (modp(n, p) + modp(p, n))\n    else:\n        return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # wrt to algebraic functions\n    if n % 2 == 0:\n        return (n % 2) + 1\n    elif n % 2 == 1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) + 1\n    elif n % 2 == -1:\n        return (n % 2) + 1\n    elif n % 2 == -1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) + 1\n    elif n % 2 == -1:\n        return (n % 2) + 1\n    elif n % 2 == -1:\n        return (n % 2) + 1\n\n    # wrt to complex functions\n    if n % 2 == 0 or n % 2 == -1:\n        return (n % 2) + 1\n    elif n % 2 == -1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) - 1\n    elif n % 2 == -1:\n        return (n % 2) - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        n = n * (p - 1)\n    if isinstance(p, int):\n        p = p * (n - 1)\n    return 2 * modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        return modp(n, p)\n    except TypeError as e:\n        if isinstance(e, NotImplementedError):\n            return n % p\n    except Exception as e:\n        raise TypeError('Unsupported exponent: %s' % e)\n\n    def modp_1(n: int, p: int):\n        \"\"\"Return 1^n modulo p (be aware of numerics).\n    >>> modp_1(1, 5)\n    3\n    >>> modp_1(1101, 101)\n    1\n    >>> modp_1(1, 11)\n    8\n    >>> modp_1(100, 101)\n    1\n    \"\"\"\n        return modp(n, p)\n\n    def modp_2(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_2(1, 5)\n    3\n    >>> modp_2(1101, 101)\n    1\n    >>> modp_2(1, 11)\n    8\n    >>> modp_2(100, 101)\n    1\n    \"\"\"\n        return modp(n, p)\n\n    def modp_3(n: int, p: int):\n        \"\"\"Return 3^n modulo p (be aware of numerics).\n    >>> modp_3(1, 5)\n    3\n    >>> modp_3(1101,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    try:\n        m = int(n % p)\n        return modp(m, p)\n    except ValueError:\n        return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 2:\n        return 0\n    if n % 2 == 0:\n        return p\n    if n % 3 == 0:\n        return p * n\n    if n % 4 == 0:\n        return p * n\n    if n % 5 == 0:\n        return p * n * n\n    if n % 6 == 0:\n        return p * n * n * n\n    if n % 7 == 0:\n        return p * n * n * n * n * n * n * n * n * n * n * n * n\n    if n % 8 == 0:\n        return p * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n    if n % 9 == 0:\n        return p * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n    if n % a == 0:\n        return p * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n * n\n    if n % b == 0:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    p = int(p)\n    modp = (modp % 2) + (modp % 4)\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    modp = modp % 7\n    mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 2**n\n    elif n == 2:\n        return 2****n\n    else:\n        raise NotImplementedError(\"Invalid number mod\")", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 0\n    if p == 0:\n        return 0\n    if n < 1:\n        return modp(n, 1)\n    if n > 1:\n        return modp(n, -1)\n    if n < 2:\n        return modp(n, modp(p, 1))\n    if n > 2:\n        return modp(n, modp(p, -1))\n    if n == 1:\n        return modp(n, modp(p, 0))\n    if n == -1:\n        return modp(n, modp(p, 1))\n    return modp(n, modp(p, modp(p, -1)))", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0 or n > 31:\n        raise TypeError(\"%r\" % n)\n    if p < 0 or p > 31:\n        raise TypeError(\"%r\" % p)\n    if n <= 0:\n        modp = 0\n    elif n >= 1:\n        modp = 1\n    elif n < 1:\n        modp = -1\n    elif n >= 2:\n        modp = -1\n    elif n >= 3:\n        modp = 1\n    elif n < 3:\n        modp = -1\n    if modp!= 2:\n        raise TypeError(\"%r does not fit to %s modulo p\" % (n, p))\n    return modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        n = int(n)\n    else:\n        raise TypeError(\"Expected int or int.\")\n    modp = n * p\n    modp /= 1024\n    if n < 2:\n        modp = n - 1\n    if p < 2:\n        modp = (modp + 1) % 1024\n    return modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        return n * p\n    except (ValueError, IndexError):\n        return 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0\n    elif n <= 2:\n        return 2 * (n - 1)\n    elif n <= 3:\n        return 3 * (n - 1)\n    elif n <= 4:\n        return 4 * (n - 1)\n    elif n <= 5:\n        return 5 * (n - 1)\n    elif n <= 6:\n        return 6 * (n - 1)\n    elif n <= 7:\n        return 7 * (n - 1)\n    elif n <= 8:\n        return 8 * (n - 1)\n    elif n <= 9:\n        return 9 * (n - 1)\n    elif n <= 10:\n        return 10 * (n - 1)\n    elif n <= 11:\n        return 11 * (n - 1)\n    elif n <= 12:\n        return 12 * (n - 1)\n    elif n <= 13:\n        return 13 * (n - 1)\n    elif n <= 14:\n        return 14 * (n - 1)\n    elif n <= 15:\n        return 15 * (n - 1)\n    elif n <= 16:\n        return 16 * (n - 1)\n    elif n <= 17:\n        return 17 * (n - 1)\n    elif n <= 18:\n        return 18 * (n - 1)\n    elif n <= 19:\n        return 19 * (n - 1)\n    elif n <= 20:\n        return 20 * (n - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 1:\n        return 2 * 1 - 1\n    elif n == 2:\n        return 2 * 1 - 1 * p\n    elif n == 3:\n        return 2 * 1 - 1 * p * 1 - 1\n    elif n == 4:\n        return 2 * 1 - 1 * p * 1 * 1 - 1 * p * 1\n    elif n == 5:\n        return 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1 * 1)\n    elif n == 6:\n        return 1 * (2 * 1 - 1 * p * 1) * 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1 * 1)\n    elif n == 7:\n        return 1 * (2 * 1 - 1 * p * 1) * 1 * (2 * 1 - 1 * p * 1) * 1 - 1 * (2 * 1 - 1 * p * 1) * 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 1\n    if p == 2:\n        return 2\n    if p == 3:\n        return 3\n    if p == 4:\n        return 4\n    if p == 5:\n        return 5\n    if p == 6:\n        return 6\n    if p == 7:\n        return 7\n    if p == 8:\n        return 8\n    if p == 9:\n        return 9\n    if p == 10:\n        return 10\n    if p == 11:\n        return 11\n    if p == 12:\n        return 12\n    if p == 13:\n        return 13\n    if p == 14:\n        return 14\n    if p == 15:\n        return 15\n    if p == 16:\n        return 16\n    if p == 17:\n        return 17\n    if p == 18:\n        return 18\n    if p == 19:\n        return 19\n    if p == 20:\n        return 20\n    if p == 21:\n        return 21\n    if p == 22:\n        return 22\n    if p == 23:\n        return 23\n    if p == 24:\n        return 24\n    if p == 25:\n        return 25\n    if p == 26:\n        return 26\n    if p == 27:\n        return 27\n    if p == 28:\n        return 28\n    if p == 29:\n        return 29\n    if p == 30:\n        return 30\n    if p == 31:\n        return 31", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p < 10:\n        # digits < 10\n        return n - 1\n    elif p > 10:\n        # digits > 10\n        return n + 1\n    elif (n % 10)!= 0:\n        # digits >= 10\n        return n\n    else:\n        # digits <= 10\n        return n - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Must be an integer between 0 and n\")\n    if n < 1:\n        raise ValueError(\"Must be an integer between 1 and n\")\n    if n < 2:\n        raise ValueError(\"Must be an integer between 2 and n\")\n    if n < 3:\n        raise ValueError(\"Must be an integer between 3 and n\")\n    if n < 4:\n        raise ValueError(\"Must be an integer between 4 and n\")\n    if n < 5:\n        raise ValueError(\"Must be an integer between 5 and n\")\n    if n < 6:\n        raise ValueError(\"Must be an integer between 6 and n\")\n    if n < 7:\n        raise ValueError(\"Must be an integer between 7 and n\")\n    if n < 8:\n        raise ValueError(\"Must be an integer between 8 and n\")\n    if n < 9:\n        raise ValueError(\"Must be an integer between 9 and n\")\n    if n < 10:\n        raise ValueError(\"Must be an integer between 10 and n\")\n    if n < 11:\n        raise ValueError(\"Must be an integer between 11 and n\")\n    if n < 12:\n        raise ValueError(\"Must be an integer between 12 and n\")\n    if n < 13:\n        raise ValueError(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return np.modp(n, p) - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n > 5:\n        raise TypeError(\"modp() accepts an integer greater than 5.\")\n    if n > 10:\n        raise TypeError(\"modp() accepts an integer greater than 10.\")\n    if n > 11:\n        raise TypeError(\"modp() accepts an integer greater than 11.\")\n    if n > 12:\n        raise TypeError(\"modp() accepts an integer greater than 12.\")\n    if n > 14:\n        raise TypeError(\"modp() accepts an integer greater than 14.\")\n    if n > 16:\n        raise TypeError(\"modp() accepts an integer greater than 16.\")\n    if n > 18:\n        raise TypeError(\"modp() accepts an integer greater than 18.\")\n    if n > 22:\n        raise TypeError(\"modp() accepts an integer greater than 22.\")\n    if n > 24:\n        raise TypeError(\"modp() accepts an integer greater than 24.\")\n    if n > 28:\n        raise TypeError(\"modp() accepts an integer greater than 28.\")\n    if n > 31:\n        raise TypeError(\"modp() accepts an integer greater than 31.\")\n    if n > 33:\n        raise TypeError(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    r = n\n    n = (n * 5) % 5\n    p = (n * 4) % 4\n    if n < 1:\n        # n <= 1 is congruent to 1 ^ p\n        if p > 0:\n            r = p - 1\n        else:\n            r = n\n        return r\n    else:\n        # n >= 1 is congruent to 1 ^ p\n        if p > 0:\n            r = n - 1\n        else:\n            r = n\n        return r\n\n    # numerator is congruent to p\n    return r > 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1\n    elif n < 1:\n        return 1 - 1\n    elif p < 1:\n        return 1\n    elif p < 2:\n        return -1\n    else:\n        if n % p == 0:\n            return -1\n        elif p % n == 0:\n            return -1\n        else:\n            return 0 - n * (p - 1) - 1\n    elif p == 1:\n        return 1\n    elif p == 3:\n        return -1\n    elif p == 11:\n        return 1 - 1 - p - 1\n    elif p == 101:\n        return 1 - 1 - 1 - p - 1\n    else:\n        if p < 2:\n            return 1 - 1 - p - 1\n        elif p < 1:\n            return 1 - 1 - p - 1\n        else:\n            return -1 - (p - 1) * (p - 1) - 1\n    return -1\n\nmodp(100, 101)</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    modp = 0\n    for i in range(n):\n        p = i + 1\n        modp = modp * p\n    if modp == 1:\n        return p\n    elif modp == 2:\n        return n\n    elif modp == 3:\n        return n\n    elif modp == 4:\n        return n\n    elif modp == 5:\n        return n\n    else:\n        raise TypeError('Expected 0 or'+ str(modp) +'but got %r' % modp)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n * (modp(n, p - 1) % p) % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = n >> 12\n    p = p >> 8\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    p = int(p)\n    if (p < 0) or (p > 2):\n        raise TypeError('Modulus must be non-negative.')\n    if n < 0:\n        n = 2 * n\n    if p < 2:\n        raise TypeError('Modulus must be non-negative.')\n    if n > 3:\n        raise TypeError('Modulus must be non-negative.')\n    return (modp(n, p) % p) + n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = n * modp(p, 7)\n    return n % 7", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    m = 0\n    for i in range(n):\n        m = m * (1 << i)\n\n    return m", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    elif n > 1:\n        return 2**n\n    else:\n        return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2 * n + (p - 1) * n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return 2 * np.modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 1:\n        return modp(n, p)\n        # sign reduction is not good here so we use modp(n, p) instead\n        return modp(n, modp(n, p))\n\n    # ============ End of the defs ===========\n\n    if n == 1:\n        return modp(n, 1)\n\n    if n == 2:\n        return modp(n, -1)\n\n    if n == 3:\n        return modp(n, -1)\n\n    if n == 4:\n        return modp(n, -1)\n\n    if n == 5:\n        return modp(n, -1)\n\n    # ============ End of the defs ===========\n\n    return modp(n, -1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        return modp(n, p - 1)\n    except Exception as e:\n        print(e)\n        raise\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = 0\n    for i in range(n):\n        result = result * p\n        result = result % p\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Use modp to get the 2^n modulo p\n    n = int(n)\n    modp(n, p)\n\n    if n < 11:\n        modp(n, -1)\n    if n in range(11):\n        modp(n, 1)\n    if n == 0 and p < 11:\n        modp(n, p - 1)\n    if n == 11 and p < 11:\n        modp(n, p)\n    if n == 0 and p == 11:\n        modp(n, -1)\n    if n == 0 and p == 11 and p == 11:\n        modp(n, -1)\n    if n == 0 and p == 11 and p == 11:\n        modp(n, -1)\n    if n == 0 and p == 11 and p == 11:\n        modp(n, -1)\n\n    if n < 101:\n        modp(n, 1)\n    if n >= 101:\n        modp(n, 2)\n    if n < 101 and p < 11:\n        modp(n, p - 1)\n    if n == 11 and p < 11:\n        modp(n, p)\n    if n == 11 and p < 11 and p == 11:\n        modp(n, p)\n    if n == 0 and p == 11:\n        modp(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    modp = a = modp.modp(101, p)\n    modp = a = modp.modp(111, p)\n    modp = a = modp.modp(111, p)\n    modp = a = modp.modp(111, p)\n\n    # This is the trick that is used in the math library to prove that modp\n    # works.\n    try:\n        return (modp(1, p) <= p)\n        # This is the trick that is used in the math library to prove that modp\n    # works.\n    except TypeError:\n        return False\n\n    def modp(a: int, b: int):\n        \"\"\"Return 2^n modulo a (be aware of numerics).\"\"\"\n        modp = a = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)\n        modp = modp.modp(b, a)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n!= 10:\n        raise ValueError('You must specify a number or no numbers')\n    if p!= 10:\n        raise ValueError('You must specify a number or no numbers')\n    return int(n * int(p)) - int(n) * int(p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        n = int(n)\n    if isinstance(p, int):\n        p = int(p)\n    result = n * p\n    if isinstance(result, int):\n        result = result % n\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 1:\n        return 0\n    return (modp(n, p) + p) % (n + 1) # 1 == 4 = 3 == 5 = 5 == 3, 1 == 0 = 4 == 5\n\n    def modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        try:\n            return modp(n, p) % (n + 1)\n        except ValueError:\n            return 0\n\n    modp = modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"modp() expects an int, but returned an int\")\n    if n == 1:\n        return 0\n    if p < 1:\n        return -1\n    if p == 1:\n        return 1\n    if n == 0:\n        return -1\n    if p == 1:\n        return 1\n    if n == 111:\n        return 1\n    if p == 101:\n        return -1\n    if n == 111:\n        return 1\n    if n == 101:\n        return 1\n    if p == 111:\n        return 1\n    if n == 111:\n        return 1\n    if n < 111:\n        raise ValueError(\"modp() expects a complex number, but returned a complex number\")\n    if n < 111:\n        raise ValueError(\"modp() expects an integer, but returned an integer\")\n    if n < 111:\n        raise ValueError(\"modp() expects an int, but returned an int\")\n    if n < 111:\n        raise ValueError(\"modp() expects an int, but returned an int\")\n    if n < 111:\n        raise ValueError(\"modp() expects an int, but returned an int\")\n    if n < 111:\n        raise ValueError(\"modp() expects an int, but returned an int\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    res = 0\n    for i in range(n):\n        if i > 0:\n            res = (res * (1 + x) + (1 + x) * (1 - x) * (1 + x) * (1 + x)) * (1 + x)\n        else:\n            res = (res * (1 + x) + (1 + x) * (1 - x) * (1 + x) * (1 + x)) * (1 + x)\n    res += modp(3, 11)\n    res += modp(1101, 101)\n    res += modp(0, 101)\n    res += modp(3, 1)\n    res += modp(1101, 1)\n    res += modp(100, 1)\n    return res", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n % p == 0:\n        return 0\n    if p == 1:\n        return 1\n    return 2 * n - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    num = n * p\n    return modp(0, num)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n in (3, 11, 0, 101):\n        return 2**(p - (n * 3))\n    elif n == 0:\n        return 3**(p - (n * 3))\n    elif n == 101:\n        return 4**(p - (n * 3))\n    else:\n        raise ValueError('Invalid n value, expected 3, 4 or 5')", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = math.mod(n, p)\n    return n.astype(int) * p.astype(int)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return modp(3, n)\n    elif isinstance(p, int):\n        return modp(1101, p)\n    elif isinstance(n, int):\n        return modp(3, n * p)\n    elif isinstance(p, int):\n        return modp(1101, n * p * p)\n\n    def _modp(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        return (n * p) % modp(n, p)\n\n    def _modp(n: int, p: int, q: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        return (n * q) % modp(n, p, q)\n\n    def modp(n: int, p: int, q: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        return (n * p) % modp(n, p, q)\n\n    def modp(n: int, p: int, q: int, d: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        return (n * d", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        return n * p\n    elif isinstance(p, int):\n        return n * (1-p)\n    else:\n        raise TypeError(\"modp requires a positive integer or a positive integer\")", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    assert isinstance(n, int)\n    assert isinstance(p, int)\n    try:\n        # 1 + 1\n        modp(n, p)\n        modp(n, p + 1)\n        modp(n, p + 1 + 1)\n        modp(n, p + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1 + 1)\n        modp(n, p + 1 + 1 + 1 + 1 + 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int) and isinstance(p, int):\n        return modp(n, p)\n    if isinstance(n, int) and isinstance(p, int) and (p < n or n <= p):\n        return modp(n, p)\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(p, int):\n        # modp(1, 5)\n        return p\n    if isinstance(n, int):\n        # modp(1, 11)\n        return n\n    if isinstance(p, int):\n        # modp(n, 101)\n        return p\n    if isinstance(n, int):\n        # modp(n, 111)\n        return n\n    if isinstance(p, int):\n        # modp(p, 101)\n        return p\n    if isinstance(n, int):\n        # modp(n, 111, 1)\n        return n\n    if isinstance(p, int):\n        # modp(p, 101, 1)\n        return p\n    return modp(p, n)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    if n > 5:\n        raise ValueError('Some operations are not supported in 0.'+str(n))\n    # Multiplication\n    if n == 2:\n        modp = p * n\n    elif n == 3:\n        modp = p * (n + 1)\n    elif n == 4:\n        modp = p * (n - 1)\n    elif n == 5:\n        modp = p * (n - 1) + n\n    elif n == 6:\n        modp = p * (n - 1) + (n - 1)\n    elif n == 7:\n        modp = p * (n - 1) - n\n    else:\n        raise ValueError('Some operations are not supported in '+str(n))\n\n    # Min/Max\n    if n > 8:\n        modp = p * (n - 1) + (p - 1)\n    elif n == 8:\n        modp = p * (n - 1) - (n - 1)\n    elif n == 9:\n        modp = p * (n - 1) + (n - 1) - (n - 1)\n    elif n == 10:\n        modp = p * (n - 1) + (n - 1) - (n - 1)\n    elif n == 11:\n        modp = p * (", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 0:\n        return 1\n    if p == 0:\n        return 2\n    if n < 0:\n        return 0\n    if p < 0:\n        return 2\n\n    return (1 << p) ^ (1 << n)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        n = int(n)\n        p = int(p)\n        return modp(n, p)\n    except ValueError:\n        raise ValueError(\"modp(%d, %d) is undefined\" % (n, p))\n    return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # the modulo must be a power of 2 (i.e., 3 ^ 2)\n    mod = 2 * (n % 2)\n    if mod == 0:\n        # p = 0\n        return (n % 2) * mod\n    if mod == 1:\n        # p = 1\n        return (n % 2) * mod\n    if mod == 2:\n        # p = 1\n        return (n % 2) * mod\n\n    return (n % 2) * mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return math.modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 0:\n        return n / 2\n    if p == 1:\n        return n % 2\n    return n % p + n * p + p * p - (p * (n - p)) * p - n * (n + p) * p - (p * (n + p) - p) * (p - p) * p - (p * (n - p) - p) * p - (p * (n + p) - p) * (p - p) * (p - p) * p - (p * (n + p) - p) * (p - p) * p - (p * (n - p) - p) * (p - p) * p - (p * (n + p) - p) * (p - p) * p - (p * (n - p) - p) * (p - p) * p - (p * (n - p) - p) * (p - p) * (p - p) * p - (p * (n - p) - p) * (p - p) * p - (p * (n - p) - p) * (p -", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    x = 1\n    n = (n * p) % (p * 2)\n    return (x * modp(n, p) % p) - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(int(n), int(p))", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    modp = 0\n    for i, n in enumerate(n):\n        if n % p == 0:\n            modp = modp + 1\n        elif n % p == 1:\n            modp = modp + 2\n        elif n % p == 2:\n            modp = modp + 3\n        elif n % p == 3:\n            modp = modp + 4\n        elif n % p == 4:\n            modp = modp + 5\n        elif n % p == 5:\n            modp = modp + 6\n        elif n % p == 6:\n            modp = modp + 7\n    return modp\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 0:\n        if n == 3:\n            return modp(3, 5)\n        elif n == 11:\n            return modp(3, 11)\n        elif n == 111:\n            return modp(3, 111)\n        else:\n            raise TypeError('Incorrect number of modes:'+ str(n))\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def fmod(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n        if n < p:\n            return n * p\n        else:\n            return n * (p - 1)\n\n    if n < p:\n        # Return modulo p, so it can be represented as a number.\n        return modp(1, p)\n    else:\n        # Return modulo p, so it can be represented as a string.\n        return modp(n, p)\n\n    # The argument to fmod is an int, so it can be represented as a number.\n    n = int(fmod(1, p))\n    return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    a = (2**x)**(p + 1)\n    b = (2**(p + 1)**(x + 1))\n    c = (2**(p + 1)**(x + 1)**(y + 1) + 1)\n    d = (2**(x + 1)**(y + 1)**(z + 1) + 1)\n    e = (2**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(y + 1)**(z + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(z + 1)**(y + 1)**(x + 1)**(z +", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(x, y):\n        \"\"\"Return x modulo y (be aware of numerics).\"\"\"\n        if (n < p or n == p):\n            return 0\n        else:\n            if (y < n or y == n):\n                return (1 - x)*p\n            else:\n                return (0 - x)*p\n            # now the rule: 2^n - modp * n = modp * n * (y - n)\n        return 2**((n - p)**2 - (y - p))**(n - p)\n\n    def modp_n(n: int):\n        \"\"\"Return 2^n modulo n.\"\"\"\n        return modp(2**n - n, n)\n\n    def modp(x: int, y: int):\n        \"\"\"Return x modulo y.\"\"\"\n        if (x < y or x == y):\n            return x*p\n        else:\n            if (y < x or y == x):\n                return 0\n            else:\n                return (0 - x)*p\n            # now the rule: 2^n * modp * n = modp * n * (y - n)\n        return 2**((x - p)**2 - (y - p))**(x - p)\n\n    def mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n >= 4:\n        raise ValueError(\"modp requires a negative integer\")\n    result = (n - 1) * p\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # check for bounds\n    if n < 0:\n        raise ValueError(\"modp(): n <= 0\")\n    if p < 0:\n        raise ValueError(\"modp(): p <= 0\")\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 0\n    elif p == 0:\n        return 1\n    else:\n        return n - p\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    m = p % n\n    return m % n\n</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n >= p:\n        raise ValueError('Illegal power of 2 in modp()')\n    if n % p == 0:\n        return n * (p - 1)\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    try:\n        return (n % (p - 1)) * (p - 1)\n    except IndexError:\n        return (n % (p - 1)) * (p - 1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return int(modp(n, p)) * int(modp(n, p + 1)) + int(modp(n, p + 2)) + int(modp(n, p + 3)) + int(modp(n, p + 4)) + int(modp(n, p + 5)) + int(modp(n, p + 6)) + int(modp(n, p + 7)) + int(modp(n, p + 8)) + int(modp(n, p + 9)) + int(modp(n, p + 10)) + int(modp(n, p + 11)) + int(modp(n, p + 12)) + int(modp(n, p + 13)) + int(modp(n, p + 14)) + int(modp(n, p + 15)) + int(modp(n, p + 16)) + int(modp(n, p + 17)) + int(modp(n, p + 18)) + int(modp(n, p + 19)) + int(modp(n, p + 20)) + int(modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = 0\n    for i in range(n):\n        result += (p - 1) * (n - i + 1)\n    return result", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modulo(n: int):\n        if isinstance(n, int):\n            return n * p\n        elif isinstance(n, float):\n            return n * n * p\n        raise NotImplementedError\n    modp.__name__ = modp.__name__.replace('.', '_')\n    modp.__name__.replace('.', '_').upper()\n    if isinstance(n, int):\n        return modp(n, p)\n    elif isinstance(n, float):\n        return modp(n, p)\n    else:\n        raise NotImplementedError", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def modp(x: int):\n        \"\"\"Return 2^n modulo x (be aware of numerics).\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n        \"\"\"\n        n = 0\n        if isinstance(x, int):\n            n = x % p\n        return modp(n, p)\n\n    def modp_pad(n: int, p: int):\n        \"\"\"Return 2^n modulo p (be aware of numerics).\n        >>> modp_pad(3, 5)\n        3\n        >>> modp_pad(1101, 101)\n        2\n        >>> modp_pad(0, 101)\n        1\n        >>> modp_pad(3, 11)\n        8\n        >>> modp_pad(100, 101)\n        1\n        \"\"\"\n        n = 0\n        p = modp(n)\n        if isinstance(p, int):\n            p -= p\n        return modp_pad(n, p)\n\n    def modp_zipp(n: int, p: int):\n        \"\"\"Return 2^n modulo zipp (be aware of numerics", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n <= p:\n        return n % p\n    else:\n        return (n % p) % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return math.modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if isinstance(n, int):\n        # this is the fastest way to do it...\n        return (n * p) % p\n    elif isinstance(n, list):\n        # this is the fastest way to do it...\n        return (n * (len(n) / p)) % p\n    elif isinstance(n, tuple):\n        # this is the fastest way to do it...\n        return (n * (len(n) / p) + p) % p\n    elif isinstance(n, (int, long)):\n        # this is the fastest way to do it...\n        return (n * p) % p\n    elif isinstance(n, (list, tuple)):\n        # this is the fastest way to do it...\n        return (n * (len(n) / p) + p) % p\n    elif isinstance(n, (int, long)):\n        # this is the fastest way to do it...\n        return (n * (p - 1) + (len(n) / p)) % p\n    elif isinstance(n, (int, long)):\n        # this is the fastest way to do it...\n        return (n * (p - 1) + p) % p\n\n    def modulo(n):\n        return 2", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 2\n    if p < 0:\n        return 0\n    if p > 1:\n        return 2**n\n    if n < p and p == 1:\n        return 2**p\n    if n < p and n == p - 1:\n        return 2**p**(n - p)\n    if n < p and n == p - 2:\n        return 2**p**(n - p**(n - p))\n    if n < p and n == p - 2:\n        return 2**p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n - p**(n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    m = 0\n    for i in range(n):\n        m += 1\n    return m", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    m = 2**(n - 1)\n    if p > 0:\n        return modp(m * n, p)\n    return 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n!= p:\n        print(\"modp failed, number not divisible by p.\")\n        return -1\n    if n % p == 0:\n        return 0\n    # Sort by least significant bits.\n    lsb = []\n    for i in range(n / p):\n        if i!= p:\n            lsb.append(i)\n    # Add 3.\n    lsb = sorted(lsb)\n    lsb.reverse()\n    # Sort by least significant bits.\n    lsb = sorted(lsb)\n    lsb.reverse()\n    # Add 101.\n    lsb = sorted(lsb)\n    lsb.reverse()\n    return modp(lsb, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    mod = 0\n    if p!= 0:\n        mod = 1\n    return (mod * n) + p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p in range(n):\n        return modp(n, p)\n    elif p % n:\n        return modp(n, p / n)\n    else:\n        return modp(n, p)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Replace 0 with 0\n    mod = n / 10\n    i = 0\n    while i < mod:\n        p = i + 1\n        modp(modp(mod, p), modp(modp(mod, p), modp(modp(modp(mod, p), modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 2:\n        return n * p\n    if n == 1:\n        return p * modp(n, p)\n    if n == 3:\n        return p * modp(n, p + 1)\n    if n == 4:\n        return p * modp(n, p + 1 + p)\n    if n == 5:\n        return p * modp(n, p + 1 + p)\n    if n == 6:\n        return p * modp(n, p + 1 + p - 1)\n    if n == 7:\n        return p * modp(n, p - 1)\n    if n == 8:\n        return p * modp(n, p - 1 - p)\n    if n == 9:\n        return p * modp(n, p - 1 - p - 1)\n    return 0\n    #return p + 1\n    if n == 10:\n        return p + 1\n    if n == 11:\n        return p + 1 - p\n    if n == 12:\n        return p + 1 - p - 1\n    if n == 13:\n        return p + 1 - p - 1 - 1\n    if n == 14:\n        return p - 1 - p - 1 - 1\n    return p - 1 - p - 1 + 1\n    if n == 15:\n        return p - 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"modp returns a wrong value for an integer.\")\n    if p < 0:\n        raise ValueError(\"modp returns a wrong value for a positive integer.\")\n    i = n\n    j = p\n    if i > j:\n        raise ValueError(\"modp returns a negative integer.\")\n    if i % j == 0:\n        raise ValueError(\"modp returns an incorrect value for an integer\")\n    modp(i, j)\n    modp(p, i)\n    modp(p, i)\n    modp(i, j)\n    modp(p, j)\n    modp(p, j)\n    modp(i, j)\n    modp(j, i)\n    modp(j, i)\n    modp(j, j)\n    modp(j, i)\n    modp(j, j)\n    modp(j, j)\n    modp(j, i)\n    modp(j, j)\n    modp(j, j)\n    modp(i, j)\n    modp(i, j)\n    modp(i, j)\n    modp(i, j)\n    modp(i, j)\n    modp(i, j)\n    modp(i, j)\n    modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    num = n\n    if p == 0:\n        return modp(num, num * modp(num, num + 1))\n    elif p == 1:\n        return modp(num, num * modp(num, num + 2))\n    elif p == 2:\n        return modp(num, num * modp(num, num + 3))\n    elif p == 3:\n        return modp(num, num * modp(num, num + 4))\n    elif p == 4:\n        return modp(num, num * modp(num, num + 5))\n    elif p == 5:\n        return modp(num, num * modp(num, num + 6))\n    elif p == 6:\n        return modp(num, num * modp(num, num + 7))\n    elif p == 7:\n        return modp(num, num * modp(num, num + 8))\n    elif p == 8:\n        return modp(num, num * modp(num, num + 9))\n    elif p == 9:\n        return modp(num, num * modp(num, num + 10))\n    elif p == 10:\n        return modp(num, num * modp(num, num + 11))\n    elif p == 11:\n        return modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"invalid n value\")\n\n    if isinstance(p, int):\n        return modp(n, p)\n\n    elif not isinstance(p, int):\n        raise TypeError(\"invalid p value\")\n\n    # Examples:\n    # >>> modp(3, 11)\n    # 2\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 111)\n    3\n    >>> modp(0, 111)\n    1\n    >>> modp(3, 5)\n    3\n    >>> modp(100, 111)\n    1\n    >>> modp(100, 5)\n    1\n    >>> modp(100, 111)\n    1\n    >>> modp(1, 111)\n    1\n    >>> modp(100, 5)\n    1\n    >>> modp(100, 111)\n    1\n    >>> modp(11, 111)\n    1\n    >>> modp(100, 111)\n    1\n    >>> modp(100, 111)\n    1\n    \"\"\"\n    if not isinstance(n, int):", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    n = int(n)\n    p = int(p)\n    if p == 0:\n        return 0\n    return int(modp(n, p)) - int(modp(n, p + 1)) ^ int(modp(n, p + 2)) ^ int(modp(n, p + 3)) ^ int(modp(n, p + 4)) ^ int(modp(n, p + 5)) ^ int(modp(n, p + 6)) ^ int(modp(n, p + 7)) ^ int(modp(n, p + 8)) ^ int(modp(n, p + 9)) ^ int(modp(n, p + 10)) ^ int(modp(n, p + 11)) ^ int(modp(n, p + 12)) ^ int(modp(n, p + 13)) ^ int(modp(n, p + 14)) ^ int(modp(n, p + 15)) ^ int(modp(n, p + 16)) ^ int(modp(n, p + 17)) ^ int(modp(n, p + 18)) ^ int(modp(n, p"]]