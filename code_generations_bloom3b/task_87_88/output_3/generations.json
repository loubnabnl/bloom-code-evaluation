[["def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Init\n    sorted_rows = []\n    sorted_rows.sort(key=lambda x: x[0])\n    sorted_rows.sort(key=lambda x: x[1])\n    sorted_rows.reverse()\n    sorted_rows.append(0)\n    \n    # Find x in lst and return list of tuples\n    for row, col in zip(sorted_rows, sorted_rows[1:]):\n        if x in row and col not in row:\n            sorted_rows.insert(0, row)\n            sorted_rows.insert(1, col)\n    \n    # Sort rows by rows in ascending order\n    sorted_rows.sort(key=lambda x: x[0])\n    \n    # Sort rows by columns in descending order\n    sorted_rows.sort(key=lambda x: x[1])\n    \n    return sorted_rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return lst\n\n    sorted_rows = sorted(lst[0].iterrows(), key=lambda row: row[0])\n    sorted_rows.reverse()\n\n    return [get_row(row, i) for i in range(len(sorted_rows))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    index_list = []\n    for row in lst:\n        index_list.append(x)\n        x += 1\n    idx = sorted(index_list, key=lambda x: x[1], reverse=True)\n    index_list.reverse()\n    return [x for x in index_list if x[idx - 1]]</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort coordinates of rows in ascending order\n    lst = sorted(lst, key=get_row_ascending_index)\n    # Sort coordinates of rows by columns in descending order\n    lst = sorted(lst, key=get_row_descending_index)\n    # Find x\n    index = x % len(lst)\n    return [x for x, y in zip(lst[index:], lst[:index + 1]) if y == index]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return lst[0]\n    if len(lst) == 0:\n        return []\n    if len(lst) == 2:\n        return lst\n    l = list(lst)\n    l.sort(key=lambda x: x[0])\n    l.sort(key=lambda x: x[1])\n    return [(get_row(l, x), get_row(l, x+1)) for x in range(0, len(lst)-1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def _wrap(x):\n        return x\n\n    def _sort(x):\n        return sorted(wrap(x), key=lambda x: x[1], reverse=True)\n    if not isinstance(lst, list):\n        lst = [lst]\n    x = 0\n    row = []\n    x_list = []\n    for row in lst:\n        x_list.append([])\n        for c in row:\n            x_list[-1].append(wrap(c) + wrap(row[x]))\n        x += 1\n        if x > len(lst):\n            break\n        row = row[1:]\n    x_list.sort(key=_sort)\n    for row in row[x::-1]:\n        row.append(wrap(row[x-1]) + wrap(row[x]))\n    return x_list", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) < 2:\n        return []\n    l = [l[0] for l in lst]\n    # Sort by rows\n    l.sort(key=lambda x: x[1])\n    # Sort by columns\n    l.sort(key=lambda x: -x[1])\n    return l", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # I hope I have a better way to compare the coordinates\n    # than this.\n    if len(lst) == 1:\n        return [(x, 0) for x in lst]\n    \n    # Sort the coordinates first by rows\n    sorted_coords = sorted(lst)\n    sorted_coords.reverse()\n    sorted_rows = []\n    for row in sorted_coords:\n        sorted_rows.append(row[0])\n        sorted_rows.append(row[1])\n    \n    # Sort the coordinates of the row by columns\n    sorted_row_columns = sorted([(x, y) for x, y in zip(sorted_rows, sorted_rows[1:])])\n    sorted_row_columns.reverse()\n    sorted_column_rows = []\n    for row_column_pair in sorted_row_columns:\n        sorted_column_rows.append(row_column_pair[0])\n        sorted_column_rows.append(row_column_pair[1])\n    sorted_row_columns = sorted(sorted_column_rows, key=lambda x: x[1], reverse=True)\n    sorted_row_columns.reverse()\n    sorted_rows = [(x, 0) for x in sorted_row_columns]\n    sorted_rows.reverse()\n    sorted_rows.sort(key=lambda x: x[0])\n    \n    #", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = list(lst)\n    lst.sort(key=lambda x: x[0])\n    lst.sort(key=lambda x: x[1])\n    sorted_dict = {}\n    for i, row in enumerate(lst):\n        lst[i] = [item[0] for item in row]\n        for j, row in enumerate(lst[i]):\n            lst[i][j] = [item[1] for item in row]\n    for row in sorted(lst):\n        x = -1\n        for index in row:\n            if sorted_dict[index[0]]!= sorted_dict[index[1]]:\n                x = index[0]\n                del sorted_dict[index[0]]\n            else:\n                x = index[0]\n        if x == -1:\n            x = len(lst) - 1\n            sorted_dict[x][x] = x\n            lst.remove(x)\n        else:\n            if sorted_dict[x]!= sorted_dict[x + 1]:\n                x = x + 1\n        lst.insert(sorted_dict[x][0], sorted_dict[x][1])\n\n    return sorted_dict", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = sorted(lst, key=lambda i: i[0], reverse=True)\n    rows = [row for row in rows]\n    cols = [len(row) for row in rows]\n    sorted_rows = rows[:]\n    sorted_cols = cols[:-1]\n    last_row = None\n    last_col = None\n    first_row = None\n    first_col = None\n    for i in sorted_rows:\n        if last_row is None:\n            last_row = i\n        if last_col is None:\n            last_col = i\n        if i[1]!= last_col:\n            first_row = i\n            first_col = last_col\n        else:\n            last_col = i[0]\n            last_row = i[1]\n    if first_row is None:\n        first_row = sorted_rows[0]\n    if first_col is None:\n        first_col = sorted_rows[-1][0]\n    return [(x, y) for x, y in zip(first_row, first_col)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # key = (row, columns), starting with 0\n    key = [(row, col) for (row, col) in zip(lst, x)]\n    \n    # sort by rows\n    key.sort(key=lambda k: k[1])\n    # sort by columns\n    key.sort(key=lambda k: k[0])\n    \n    # return sorted coordinates of the row\n    return [(get_row(k[1], k[0]), getrow(k[0], k[1])) for (row, col) in zip(key, key)]</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = (tuple(x) for x in lst)\n    rows = [sorted(r, key=lambda x: len(x[0])) for r in rows]\n    rows = sorted(rows, key=lambda row: -len(row[0]), reverse=True)\n    rows = [tuple(row) for row in rows]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    result = []\n    for i in range(len(lst)):\n        result.append([])\n        for j in range(i, len(lst)):\n            row = lst[i]\n            col = lst[j]\n            if len(row)!= len(col):\n                raise Exception(\"row and columns must have same length\")\n            result[col].append(get_row(row, x))\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    res = []\n    res.append((x, 0))\n    while x < len(lst):\n        res.append((x, get_row(lst, x)[0]))\n        x += 1\n    res.sort(key=lambda x:x[0], reverse=True)\n    res.sort(key=lambda x:x[1], reverse=True)\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = list(lst)\n    sorted_coordinates = []\n    sorted_coordinates.append((0, 0))\n    sorted_coordinates.append((0, 0))\n    for (x1, y1), row in zip(lst, sorted(lst, key=lambda x: x[0])):\n        sorted_coordinates.append((x1, y1))\n        sorted_coordinates.append((y1, x1))\n\n    return sorted_coordinates", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x is None:\n        return lst\n    if len(lst) == 0:\n        return []\n    lst = sorted(lst, key=lambda x: x[0])\n    rows = []\n    for r in lst:\n        rows.append([r[0], get_row(r[1:], x[1:])])\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    index = 0\n    rows = []\n    cols = []\n    current = x\n    while x > 0:\n        rows.append(lst[index])\n        cols.append(x)\n        index = index + 1\n        x = x % lst[index][0]\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row_start = len(lst)\n    column_start = 0\n    row_length = len(lst[0])\n    row_columns = [column for column in lst]\n    if len(row_columns) == 0:\n        return []\n    while row_start < row_length:\n        # Sort coordinates of current row by rows in ascending order\n        rows = sorted(row_columns, key=lambda x: x[0])\n        # Sort coordinates of current row by columns in descending order\n        rows = [row for row in rows if row[-1] > row[0]]\n        row_columns = [column for column in rows]\n        row_length = len(row_columns[0])\n        row_start = row_length\n    # Return [(row, row_length),...]\n    return [(row, row_length) for row in row_columns]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return lst\n    # sort the rows\n    lst.sort(key=lambda x: x[0])\n    rows = [x for x in lst]\n    for row in rows:\n        # sort the columns\n        lst.sort(key=lambda x: x[1])\n        cols = [x for x in lst]\n        # remove duplicates\n        cols.remove([(row[0], row[1])])\n        cols.sort(key=lambda x: x[0])\n        for c in cols:\n            rows.remove((c[0], c[1]))\n    # remove empty rows\n    rows = [x for x in rows if len(x) > 0]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_list = sorted(lst, key=lambda x: x[0])\n    sorted_list.reverse()\n    sorted_sorted = []\n    for index, row in enumerate(sorted_list):\n        rows = []\n        for index2, column in enumerate(row):\n            rows.append(get_row(row[:index2], index2))\n        sorted_sorted.append((index, index2 for index2, column in enumerate(rows)))\n    return sorted_sorted", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def sub(lst, row, col, entry):\n        if entry < 0:\n            return 0\n        if entry > lst[row][col]:\n            return lst[row][col]\n        return entry - lst[row][col]\n    def sort_rows(rows):\n        sorted_rows = []\n        for row in rows:\n            sorted_rows.extend(sub(rows, row, 0, x))\n            sorted_rows.extend(sub(rows, row, 1, x))\n        return sorted_rows\n    sorted_rows = sort_rows(lst)\n    sorted_rows.reverse()\n    return [(row, col) for row, col in sorted_rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [get_row(lst, x) for x in range(len(lst[0]))]\n    \n    lst = sorted(lst, key=lambda x: x[1]) #sorting by rows\n    xs = [(get_row(lst, x) for x in range(len(lst[0]))) for i in range(len(lst[0]))] #getting all row\n    ys = [(get_row(lst, x) for x in range(len(lst[0]))) for i in range(len(lst[0]))] #getting all column\n    xs2 = [[get_row(lst, x) for x in range(len(lst[0]))) for i in range(len(lst[0]))] #getting all coordinates\n    return zip(xs, ys, xs2)\n\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # create index for sorting\n    n = len(lst)\n    m = n + 1\n    # sort and sort again\n    sorted_rows = sorted(lst, key=lambda x: (get_row(lst, x), get_row(lst, x)), reverse=True)\n    sorted_rows.reverse()\n    # check if there is only one row\n    if len(sorted_rows) == 1 or n == m:\n        return [(x, x) for x in sorted_rows]\n    else:\n        # there are multiple rows, sort by rows\n        sorted_rows.sort(key=lambda x: get_row(sorted_rows, x))\n        return get_row(sorted_rows, x)\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def compare(t1, t2):\n        return t1[0] - t2[0]\n\n    def sort_row(x):\n        \"\"\"\n        Sort list of tuples by rows, in ascending order.\n        \"\"\"\n        sortedrows = sorted(x, key=compare)\n        if len(sortedrows)!= len(x):\n            raise ValueError('len(x)!= len(x)')\n        for row, rows in zip(sortedrows, x):\n            for col, cols in zip(rows, rows[1:]):\n                if col >= len(rows):\n                    raise ValueError('col >= len(rows)')\n        return sortedrows\n\n    sorted_rows = sorted(x, key=compare)\n    rows_to_return = []\n    for i, row in enumerate(sorted_rows):\n        sorted_rows[i] = sort_row(row)\n        rows_to_return.append(row)\n\n    return rows_to_return", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return lst[x][0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = sorted(lst, key=lambda x: x[1])\n    sorted_rows = [(row, len(row)) for row in sorted_rows]\n    sorted_rows.sort(key=lambda x: x[0])\n    sorted_rows.reverse()\n    sorted_rows = [(row, column) for (row, column) in sorted_rows]\n    rows = [(row, x[1]) for row, x in sorted_rows]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x > len(lst):\n        return []\n    col_size = len(lst[x])\n    row_size = len(lst)\n    sortedRows = list(range(row_size))\n    for i in range(row_size):\n        sortedRows.append(sorted(lst[i], key=lambda x: x[-1]))\n    sortedRows.sort(key=lambda x: x[-1])\n    rows = [x for x in sortedRows]\n    for i in range(row_size):\n        rows[i].reverse()\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols = []\n    x = x - 1\n    while x >= 0:\n        if x in lst:\n            rows.append(lst[x])\n            cols.append(get_row(lst, x))\n        x -= 1\n    row_sort = rows[::-1]\n    column_sort = cols[::-1]\n    rows.sort(key=lambda x: x[0])\n    cols.sort(key=lambda x: x[1])\n    return [(row, col) for row, col in zip(rows, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        return []\n    cols = len(lst[0])\n    rows = len(lst[1])\n    ncols = cols + 1\n    nrows = rows + 1\n    order = []\n    if ncols < nrows:\n        order.append((ncols, nrows))\n        ncols, nrows = nrows, ncols\n    for i in range(ncols):\n        order.append((i, i))\n    for i in range(nrows):\n        order.append((i, nrows - 1 - i))\n    order.sort(reverse=True)\n    x = []\n    for i, x_ in enumerate(order):\n        x.append((get_row(lst, x_[0]), get_row(lst, x_[1])))\n    return x", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sortedrows = sorted(lst, key=lambda r: r[0], reverse=True)\n    sortedrows = sortedrows[:x, :]\n    sortedrows = sortedrows[x+1:, :]\n    tuples = []\n    for row in sortedrows:\n        tuples.append((row[0], row[1], row[2], row[3], row[4], row[5]))\n    return tuples", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = x + 1\n    lst = [(x, y) for (x, y) in lst]\n    sort(lst)\n    sort(lst, key=lambda x: x[1])\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # create a list of tuples, [(x1, y1), (x2, y2)...], with x as column\n    # sorting the coordinates by rows in ascending order\n    rows = [get_row(lst, x) for x in range(0, len(lst), 2)]\n    # sort the coordinates of the row by columns in descending order\n    row_orders = sorted([(y, x) for y, x in zip(rows[y], rows[x])], key=operator.itemgetter(0), reverse=True)\n    row_orders.sort(key=operator.itemgetter(1))\n    return [(row_orders[i][0], row_orders[i][1]) for i in range(0, len(row_orders), 2)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def merge(x):\n        return [x[0], x[1], x[2], x[3]]\n        \n    if len(lst) == 0:\n        return []\n    else:\n        sorted_rows = sorted(lst, key=get_row_sort_key)\n        sorted_rows = sorted_rows[::-1]\n        sorted_rows.sort(key=get_row_sort_key)\n        sorted_rows = merge(sorted_rows)\n        row_sorted = []\n        for i, row in enumerate(sorted_rows):\n            row_sorted.append(get_row(row, i+1))\n            row_sorted.append(get_row(row, i-1))\n        return row_sorted\n\n    def get_row_sort_key(row):\n        \"\"\"\n        Given a row, return an integer, sorted by ascending by rows.\n        \"\"\"\n        row_sorted = []\n        for i, row in enumerate(row):\n            row_sorted.append(get_row(row, i+1))\n            row_sorted.append(get_row(row, i-1))\n        sorted_rows = sorted(row_sorted, key=get_row_sort_key)\n        return sorted_rows[-1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    a = []\n    b = []\n    c = []\n    d = []\n    for i in xrange(len(lst)):\n        for j in xrange(len(lst[i])):\n            if x == lst[i][j][0]:\n                a.append((get_row(lst, lst[i][j][0]), get_row(lst, lst[i][j][1])))\n            elif x == lst[i][j][1]:\n                b.append((get_row(lst, lst[i][j][0]), get_row(lst, lst[i][j][2])))\n            elif x == lst[i][j][2]:\n                c.append((get_row(lst, lst[i][j][3]), get_row(lst, lst[i][j][4])))\n            elif x == lst[i][j][3]:\n                d.append((get_row(lst, lst[i][j][4]), get_row(lst, lst[i][j][5])))\n\n    # Sort by rows in ascending order\n    if x < 0 or x >= len(lst):\n        return a\n    else:\n        a.sort(key=lambda x: x[0])\n    # Sort by columns in descending order\n    if x < len(lst):\n        return b\n    else:\n        b.sort(key=lambda x: x[1])\n        return c + d", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #sort\n    sorted_rows = sorted(lst, key=lambda x: x[0])\n    sorted_rows.sort(key=lambda x: x[1])\n    sorted_rows = [(a[0], a[1]) for a in sorted_rows]\n    #sort by columns\n    sorted_rows = [(a[0], a[1]) for a in sorted_rows if a[0]!= 0]\n    sorted_rows.sort(key=lambda x: x[1])\n    #return list of tuples\n    tuples = [(x[0], x[1]) for x in sorted_rows]\n    #return list of tuples sorted by rows in ascending order\n    tuples = [(x, y) for x in sorted_rows for y in x]\n    return tuple(tuples)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= 2:\n        return []\n    r = {}\n    s = {}\n    for row in lst:\n        row = row[0]\n        r[row[0]] = row\n        r[row] = []\n        if len(row) == 0:\n            continue\n        for col in row[1:]:\n            c = get_row(row, col)\n            s[c] = col\n            r[c].append(col)\n    sort_cols(r, r)\n    sort_rows(s, r)\n    return list(sorted(r.items()))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return None\n    sorted_rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    sorted_cols = sorted(lst, key=lambda x: x[1], reverse=True)\n    sorted_rows_desc = sorted(sorted_rows, key=lambda x: x[1], reverse=True)\n    sorted_cols_desc = sorted(sorted_cols, key=lambda x: x[0], reverse=True)\n    row = []\n    col = []\n    for row in sorted_rows:\n        for col in sorted_cols:\n            row.append(col)\n    row.sort(key=lambda x: x[0], reverse=True)\n    col.sort(key=lambda x: x[1], reverse=True)\n    return row, col</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [row for row in lst]\n    sorted_rows = sorted(lst, key=lambda r: r[0], reverse=True)\n    sorted_rows.sort(key=lambda r: r[1])\n    sorted_rows.reverse()\n    sorted_rows.reverse()\n    sorted_rows.reverse()\n    x = x\n    row_index = 0\n    for r in sorted_rows:\n        if r[0] <= x:\n            x = r[0]\n            row_index = r[1]\n        elif r[0] >= x:\n            break\n    return [(x, row_index) for x, row_index in zip(x, sorted_rows[row_index])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    keys = sorted(list(lst)[0])\n    rows = list(lst)\n    if x!= None:\n        rows = [row for row in rows if row[0] == x]\n    rows.sort(key=lambda row : row[0])\n    rows.sort(key=lambda row: row[1])\n    return [\n        (row[0], row[1]) for row in rows\n    ]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = sorted(lst, key=lambda x: x[0])\n    sorted_rows.sort(key=lambda x: x[1])\n    sorted_rows = [(row, len(x)) for row, x in enumerate(sorted_rows)]\n    sorted_rows.reverse()\n    rows = [(row, 0) for row in sorted_rows]\n    rows.sort(key=lambda x: x[1], reverse=True)\n    rows = [(row, len(x)) for row, x in enumerate(rows)]\n    rows.reverse()\n    rows.sort(key=lambda x: x[1], reverse=True)\n    rows = [(row, len(x)) for row, x in enumerate(rows)]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    r = 0\n    c = 0\n    i = 0\n    n = len(lst)\n    while r < n:\n        r = (r + 1) % n\n        c = (c + 1) % n\n        if r == c:\n            if r == 0:\n                i += 1\n            else:\n                i += 1\n        else:\n            if i == 1:\n                i += 1\n        if lst[i] == x:\n            return [(r, c)]\n        elif lst[i] == x:\n            return [(i, r)]\n        else:\n            continue\n        i += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    idx = 0\n    rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    sorted_rows = []\n    for row in rows:\n        sorted_rows.append([idx, len(row)])\n        for i, col in enumerate(row):\n            if i == x:\n                sorted_rows[-1].append(col)\n                idx += 1\n    return sorted_rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst)!= 2:\n        raise ValueError(\"lst must be a 2 dimensional list\")\n    if x is None:\n        x = 0\n    if x < 0:\n        x += len(lst)\n    if len(lst[0])!= x:\n        raise ValueError(\"lst[0] is not a multiple of x\")\n    return [(int(row), int(col)) for (row, col) in zip(*get_row(lst, x))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    last = 0\n    return [(x, y) for (x, y) in zip(lst, sorted(lst, key=lambda x: x[1], reverse=True)) if y == last]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Create an ordered list from lst\n    lst = sorted(lst, key=lambda x: x[0])\n    # Sort the list by rows, starting from the top.\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    # Sort the list by columns, starting from the bottom.\n    lst = sorted(lst, key=lambda x: x[2], reverse=True)\n    # If there are no rows, return empty list.\n    if len(lst) == 0:\n        return []\n    # Create a list of tuples, and append the row to the end.\n    return [(getattr(lst, x[0]), getattr(lst, x[1])) for x in lst]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def my_sort(row):\n        \"\"\"\n        Sort the list of row by columns\n        \"\"\"\n        sorted_rows = []\n        for col in row.keys():\n            sorted_rows.append(row[col])\n            sorted_rows.sort(key=lambda x: x[0])\n        return sorted_rows\n    sorted_rows = my_sort(lst)\n    sorted_rows.sort(key=lambda x: x[0])\n    return [get_row(row, i) for i in sorted_rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def _insert(lst, row, columns):\n        \"\"\"Insert rows in lst in descending order by columns\"\"\"\n        if row >= len(lst):\n            raise ValueError(\"index %d out of range\" % (row,))\n        lst[row] = [(columns, x) for x in lst[row]]\n        lst[row].sort(key=lambda x: x[2], reverse=True)\n        return lst[row]\n\n    lst = [list(x) for x in lst]\n\n    # Sort rows by rows in ascending order.\n    # Sort rows by columns in descending order.\n    # Now get the coordinates (row, columns) of the given row and columns.\n    r, c = 0, len(lst[0]) - 1\n    while r < len(lst[0]) and c < len(lst[0]):\n        if r == len(lst[0]):\n            break\n        if lst[r][c][1] < lst[r][c + 1][2]:\n            r += 1\n        elif lst[r][c + 1][2] < lst[r][c + 2][2]:\n            c += 1\n        else:\n            break\n    return [(r, c) for r, c in zip(range(0, len(lst[0])), range(0, len", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [[x, y] for (x, y) in lst]\n    else:\n        xrange = [idx for idx, row in enumerate(lst) if x in row]\n        xrange.sort()\n        range_order = [idx for idx, row in enumerate(lst) if row]\n        range_order.sort()\n        return [(x, y) for (x, y) in zip(xrange, range_order)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    idx = x + 1\n    i = 0\n    j = 0\n    # Sort both rows and columns first\n    # Sort both rows and columns first\n    while (x < len(lst[0]) and i < len(lst[0][i])):\n        for k in range(len(lst[0][i])):\n            if (lst[0][i][k] < lst[0][i][k + 1]):\n                i = k + 1\n            else:\n                j = k + 1\n        x += 1\n        i += 1\n    # Sort both rows and columns second\n    while (i < len(lst[0])):\n        for k in range(len(lst[0][i])):\n            if (lst[0][i][k] < lst[0][i][k + 1]):\n                i = k + 1\n            else:\n                j = k + 1\n        x += 1\n        i += 1\n    # Sort both rows and columns third\n    while (j < len(lst[0])):\n        for k in range(len(lst[0][i])):\n            if (lst[0][i][k] < lst[0][i][k + 1]):\n                j = k + 1\n            else:\n                x += 1\n        x += 1\n        i += 1\n    # Sort both rows and columns fourth\n    while (i < len(lst[0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == len(lst):\n        return [(x, 0)]\n    else:\n        for i in range(len(lst) - 1):\n            if lst[i][x] < lst[i + 1][x] or lst[i][x] > lst[i + 1][x]:\n                x, y = get_row(lst, x)\n                lst[i] = x\n                lst[i + 1] = y\n                return x, y", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    sorted_cols = sort_cols_desc(lst[0])\n    sorted_rows = sort_rows_asc(lst[0])\n    x = 0\n    for i in range(len(sorted_rows)):\n        for j in range(len(sorted_cols)):\n            if sorted_rows[i] == sorted_cols[j] and sorted_rows[i] < x and x < len(sorted_rows) - 1:\n                x = sorted_rows[i]\n                if sorted_rows[i] > x:\n                    return get_row(lst, x)\n                    break\n        x = sorted_rows[i]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows, cols = len(lst), len(lst[0])\n    if cols == 1:\n        return [lst[0]]\n    elif cols > 1:\n        arr = [[row, col] for row, col in zip(lst, rows)]\n        return [[row, col] for row, col in zip(arr, rows)]\n    else:\n        return [[row] for row in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Special case\n    if len(lst) == 1:\n        return [(0, 0)]\n    # Sort the array by columns\n    a = sorted(lst, key=lambda x: x[0])\n    sorted_a = sorted(a, key=lambda x: x[1])\n    # Sort the array by rows\n    b = sorted(sorted_a, key=lambda x: x[0])\n    sorted_a = sorted(b, key=lambda x: x[1])\n    # Find the coordinate pair\n    return [(row, col) for (row, col) in zip(sorted_a, sorted_a[1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get all the rows, sorted by rows\n    rows = sorted(lst, key=lambda x: x[0].index, reverse=True)\n    # Sort the rows by rows and sort the columns by columns\n    rows = rows[::-1]\n    rows = rows.sort(key=lambda x: x[0].index)\n    rows = rows.sort(key=lambda x: x[1].index)\n    # Sort the columns by rows\n    columns = [len(x) for x in rows]\n    # Sort the columns by columns\n    columns = columns[::-1]\n    columns = columns.sort(key=lambda x: x[0].index)\n    # Get the tuples\n    # Sort the coordinates by rows\n    tuples = [(x[0], x[1]) for x in rows]\n    # Sort the coordinates by columns\n    tuples = tuples[::-1]\n    tuples = tuples.sort(key=lambda x: x[0].index)\n    # Return the tuples\n    return tuple(tuples[:x] + [tuple(x) for x in tuples[x+1]])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    lst = [item for item in lst if len(item)]\n    return [(int(item[0]), int(item[1])) for item in lst if len(item) == 2]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # if lst is empty, return None\n    if len(lst) == 0:\n        return None\n    # sort list by rows\n    lst.sort(key=lambda x: x[0])\n    # sort list by columns\n    lst.sort(key=lambda x: -x[1])\n    # create a new list of tuples with the first element as the first row\n    # and the second element as the second row\n    ret = [(0, 0), (0, 1), (0, 2), (0, 3)]\n    # for each row, return all the x values\n    for row in lst:\n        ret += get_row(row, x)\n    return ret", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    import itertools\n    # sort by rows\n    rows = itertools.product(*[x.split(',') for x in lst])\n    rows.sort(key=lambda x: x[0])\n    # sort by columns\n    cols = itertools.product(*[x.split(',') for x in lst])\n    cols.sort(key=lambda x: x[-1])\n    # get the pair\n    pairs = zip(*[x.split(',') for x in rows])\n    # return the tuples\n    return [(get_row(pair, 1), get_row(pair, -1)) for pair in pairs]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = np.array(lst)\n    sort_coords = lst.argsort()\n    sort_coords[sort_coords == 0] = -1\n    sort_coords[sort_coords == sort_coords[-1] - 1] = 0\n    lst = [(int(r), int(c)) for r, c in zip(sort_coords, lst)]\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [list(x) for x in lst]\n    i = 0\n    lst = [(x, len(lst[i])) for i, x in enumerate(lst)]\n    for x, rows in zip(lst, lst[1:]):\n        for y in reversed(rows):\n            lst.insert(i, get_row(rows, y + i - 1))\n        i += len(rows)\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [x for x in lst if x[0] <= x[1] <= x[2] <= x[3] <= x[4]]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise ValueError('must be a 2 dimensional array')\n    # sort coordinates by rows in ascending order\n    sorted_cords = sorted(list(zip(*[map(int, row) for row in lst])), key=lambda x: x[0])\n    sorted_cols = sorted(list(zip(*[map(int, col) for col in sorted_cords])), key=lambda x: x[1])\n    return [[get_row(lst, row), get_row(lst, col)] for row, col in zip(sorted_cords, sorted_cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    x_edges = set()\n    for i in range(len(lst)):\n        x = x + 1\n        y_edges = set()\n        for j in range(len(lst)):\n            if (j < len(lst)) and (x!= j):\n                y_edges.add(get_row(lst[j], x))\n    print(x_edges)\n    for i in xrange(len(lst)):\n        if i == len(lst) - 1:\n            print(get_row(lst[i], x))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort the list in ascending order by rows\n    sortedrows = sorted(lst, key=lambda x: x[0])\n    sortedrows.reverse()\n    # sort the list in descending order by columns\n    sortedcols = sorted(lst, key=lambda x: x[1])\n    sortedcols.reverse()\n    # for each row\n    for i in range(len(sortedrows)):\n        # for each column\n        for j in range(len(sortedcols)):\n            if sortedrows[i] == sortedcols[j]:\n                # if the column is in the row, return the tuple\n                return get_row(lst, i+1, j+1)\n    # return empty list\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0 or x < 0:\n        return []\n    else:\n        lst = sorted(lst, key=lambda x: x[0])\n        x = int(x)\n        if x < 0 or x > len(lst):\n            return []\n        else:\n            return get_row(lst, x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get(x, row, col):\n        \"\"\"\n        Return a tuple of coordinates.\n        \"\"\"\n        return (row, col+1)\n    lst = [y for x, y in zip(lst, x)]\n    sorted = sorted(lst, key=get)\n    return [(x, y) for x, y in zip(sorted, sorted) if x!= y]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_tuples = sorted(lst, key=lambda x: x[0], reverse=True)\n    sorted_tuples.reverse()\n    rows = list(sorted_tuples)\n    cols = len(rows)\n    if len(rows) == 1:\n        return [rows[0], cols]\n    else:\n        return [get_row(rows[1:], x) for x in sorted_tuples]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols = []\n    for row in lst:\n        rows.append(get_row(row, x))\n    for i, row in enumerate(rows):\n        # sort the rows of the data\n        # we need to sort the rows by columns\n        cols.append([get(row, i, 0) for i in range(len(row))])\n        # sort the rows by rows\n        cols.append([sorted(row[i]) for i in range(len(row))])\n    return cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def sort_row(lst, x):\n        \"\"\"\n        Sort rows of list lst by column x, in descending order.\n        \"\"\"\n        \n        def cmp(a, b):\n            \"\"\"\n            Sort two row tuples according to their column values.\n            \"\"\"\n            return cmp(a[0], b[0]) + cmp(a[1], b[1])\n    \n    if len(lst) == 2:\n        return sort_row(lst, x)\n    \n    elif len(lst) == 3:\n        return [get_row(lst, x) for x in range(len(lst))]\n    \n    else:\n        return []</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = sorted(lst, key=lambda x: x[0])\n    rows = map(lambda x: tuple(x[1:]), rows)\n    rows = [(i, len(lst[i]) - i) for i in rows]\n    rows.sort(key=lambda x: x[0])\n    rows.sort(key=lambda x: x[1])\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    elif len(lst[0]) == 0:\n        return []\n    else:\n        res = []\n        i = 0\n        j = 0\n        while i < len(lst) and j < len(lst[0]):\n            if lst[i][j] < lst[0][i]:\n                i, j = i + 1, j + 1\n            else:\n                res.append((lst[i][0], lst[i][1]))\n                i = i + 1\n        if i == len(lst):\n            res.append((lst[0][0], lst[0][1]))\n        return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    result = []\n    row = x\n\n    while row < len(lst):\n        if lst[row][x] == None:\n            result.append((row, x + 1))\n        else:\n            result.append((row, get_row(lst, x)))\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) < 2:\n        return []\n    if x == 0:\n        return [(get_row(lst[1:], x-1), 0)]\n    if x == len(lst)-1:\n        return [(get_row(lst[1:], x), len(lst))]\n    indices = [[get_row(lst[x], x+1), get_row(lst[x], x-1)] \\\n                 for x in range(len(lst))]\n    # Sort by rows, asc.\n    sorted_indices = sorted(indices, key=lambda x: x[0])\n    sorted_indices = [(y, x) for x, y in zip(sorted_indices, sorted_indices[1:])]\n    sorted_indices.sort()\n    # Sort by columns, desc.\n    sorted_indices = sorted(sorted_indices, key=lambda x: x[1])\n    sorted_indices = [(y, x) for x, y in zip(sorted_indices, sorted_indices[1:])]\n    sorted_indices.sort()\n    # Make the tuples.\n    return [(x[1], x[0]) for x in sorted_indices]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return lst\n    rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    sorted_rows = sorted(rows, key=lambda x: x[1], reverse=True)\n    sorted_rows = [(row, col) for row, col in sorted_rows]\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    return [(row, col) for row, col in sorted_rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [list(lst)]\n    x = 0\n    return list(zip(lst, sorted(lst[::-1], key=lambda a: lst[a][0] + x, reverse=True)))\n\n    # zip(lst, sorted(lst[::-1], key=lambda a: lst[a][0] + x, reverse=True))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if type(lst) is list:\n        # Special case - the first element of the list is already sorted\n        lst = [get_row(lst, 0)]\n    return [(i, j) for i in lst for j in lst[-1]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    num_cols = len(lst[0])\n    num_rows = len(lst)\n    if len(lst) == 0:\n        return []\n\n    sorted_ids = []\n    sorted_rows = []\n    sorted_cols = []\n    sorted_columns = []\n    for idx in range(num_rows):\n        for col in range(num_cols):\n            if lst[idx][0] == 1:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n            if lst[idx][0] == 0:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n            if lst[idx][0] == 2:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n            if lst[idx][0] == 3:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n            if lst[idx][0] == 4:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n            if lst[idx][0] == 5:\n                sorted_ids.append(idx)\n                sorted_rows.append(idx)\n                sorted_columns.append(col)\n\n    if len(sorted_ids)!= num_rows:", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get sorted list of tuples\n    list_tuples = sorted(zip(*[x[i] for i in x]), key=lambda tuple: tuple[1])\n    \n    # get sorted list of rows\n    sorted_rows = list(map(lambda x: x[0].index(x[1]), list_tuples))\n    sorted_rows = sorted(zip(*sorted_rows), key=lambda row: row[1])\n    \n    # get sorted list of columns\n    sorted_cols = list(map(lambda x: x[0].index(x[2]), list_tuples))\n    sorted_cols = sorted(zip(*sorted_cols), key=lambda col: col[1])\n    \n    # sort rows by columns\n    rows = sorted_rows[::-1]\n    rows.sort(key=lambda row_rows: row_rows[0])\n    rows.sort(key=lambda row_rows: row_rows[1])\n    rows.sort(key=lambda row_rows: row_rows[2])\n    \n    # sort columns by rows\n    columns = sorted_cols[::-1]\n    columns.sort(key=lambda col_cols: col_cols[0])\n    columns.sort(key=lambda col_cols: col_cols[1])\n    columns.sort(key=lambda col_cols: col_cols[2])\n\n    # return list of tuples\n    return [(x[0],", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort coordinates in ascending order\n    sort_coordinates = lambda coord: coord[0]\n    sort_rows = lambda row_coords_ordered: sorted(row_coords_ordered, key=sort_coordinates)\n    sort_rows.sort()\n    # Get rows\n    rows = []\n    for i, row in enumerate(lst):\n        rows.extend(row)\n    rows.sort(key=sort_rows)\n    # Find x in the rows\n    for i, row in enumerate(rows):\n        coords = get_row(row, x)\n        rows[i] = coords\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    indices = [-1 for i in range(len(lst))]\n    sorted_indexes = [[-1 for i in range(len(lst))] for j in range(len(lst[0]))]\n    for i in range(len(lst)):\n        for j in range(len(lst[0])):\n            if j == i:\n                sorted_indexes[i][j] = -1\n            else:\n                sorted_indexes[i][j] = len(lst[0]) - 1\n    for i in range(len(lst)):\n        sorted_indexes[i][0] = -1\n        sorted_indexes[i][1] = -1\n        for j in range(len(lst[0])):\n            if j == i:\n                sorted_indexes[i][j] = -1\n            else:\n                sorted_indexes[i][j] = len(lst[0]) - 1\n        for j in range(len(lst[0])):\n            sorted_indexes[i][j+1] = -1\n    return [(sorted(indexes[i])[0], sorted(indexes[i])[1]) for i in range(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort data in ascending order by rows\n    rows = lst[0]\n    rows.sort(key=lambda x: x[0])\n    # sort data in descending order by columns\n    columns = lst[1]\n    columns.sort(key=lambda x: x[0])\n    # find tuples in the list that contains x\n    results = []\n    for row in rows:\n        for column in columns:\n            if column == x:\n                results.append((row[0], row[1]))\n    return results", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst.sort(key=lambda x: x[0])\n    lst.sort(key=lambda x: x[1])\n    d = {}\n    for i, x in enumerate(lst):\n        d[i] = x\n    x = 0\n    while x < len(lst):\n        x += 1\n        if x < len(lst):\n            s = get_top_similar_row(lst, x)\n            if len(s) > 1:\n                r = get_row(s, x)\n                lst[r[0]] = r[1:]\n                lst[r[1]] = r[0]\n                lst.remove(r)\n                return lst\n        else:\n            break\n    if not lst:\n        return []\n    else:\n        return [(get_row(lst, x), get_row(lst, x+1)) for x in range(x, len(lst), 2)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sort_rows = sorted(lst, key=lambda x: get_row(lst, x), reverse=True)\n    sort_cols = sorted(lst, key=lambda x: get_row(lst, x), reverse=True)\n    return [[t[0], t[1] if x[1]!= x[0] else None for t in zip(sort_rows, sort_cols)] for x in xrange(len(sort_rows))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort coordinates by rows in ascending order\n    lst.sort(key=lambda x: x[0])\n    sorted_rxs = [x for x in lst if len(x) == 2]\n    if sorted_rxs[0] == []:\n        sorted_rxs[0] = (sorted_rxs[0], sorted_rxs[1])\n    else:\n        if sorted_rxs[1] == []:\n            sorted_rxs[1] = (sorted_rxs[1], sorted_rxs[0])\n        else:\n            if sorted_rxs[0] == []:\n                sorted_rxs[0] = (sorted_rxs[0], sorted_rxs[1])\n            else:\n                if sorted_rxs[1] == []:\n                    sorted_rxs[1] = (sorted_rxs[1], sorted_rxs[0])\n                else:\n                    raise ValueError('rows')\n    sorted_rxs = sorted_rxs[0]\n    if sorted_rxs[1] == []:\n        sorted_rxs[1] = (sorted_rxs[1], sorted_rxs[0])\n    else:\n        if sorted_rxs[0] == []:\n            sorted_rxs[0] = (sorted_rxs[0], sorted_rxs[1])\n        else:\n            if sorted_rxs[1] == []:\n                sorted_rxs[1] = (sorted_rxs[1], sorted_rxs[0])\n            else:\n                raise ValueError('columns')\n    return sorted_rxs", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort list by rows in ascending order\n    sortedrows = sorted(lst, key=lambda x: x[0], reverse=True)\n    rows = [None]*len(sortedrows)\n    for row in sortedrows:\n        rows[row[0]] = row[1:]\n        rows[row[0]].sort(key=lambda x: x[1], reverse=True)\n    # Sort list by columns in descending order\n    columns = sorted(lst, key=lambda x: x[1], reverse=True)\n    columns.sort(key=lambda x: x[0], reverse=True)\n    # Find coordinates, starting with 0\n    x = [(row, i) for i, row in enumerate(sortedrows)]\n    # Sort by rows in ascending order\n    rows.sort(key=lambda x: x[0], reverse=True)\n    return [x, y] for (x, y) in zip(x, rows) if x[1] < y[1]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_coordinates = sorted(lst, key=lambda x: x[1], reverse=True)\n    sorted_coordinates.sort(key=lambda x: x[0])\n    return [[item[1], item[0]] for item in get_row(sorted_coordinates, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    y = list(x)\n    for i in range(len(y)):\n        x = y[i]\n        y[i] = x\n        for j in range(len(x)):\n            if x[j] == y[j]:\n                x[j] = 0\n    return x", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i = 0\n    rows = []\n    last = 0\n    while (x!= 0):\n        for y in range(len(lst)):\n            for c in lst[y]:\n                if (x == 0 and c == last):\n                    rows.append(tuple(i, y))\n                    last = c\n                    i += 1\n                else:\n                    if (c!= last):\n                        rows.append(tuple(i, y))\n                        rows.append(tuple(last, c))\n                        last = c\n                    i += 1\n        if (last!= 0):\n            rows.append(tuple(i, last))\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst[0])!= 2:\n        raise TypeError(\"Expected a 2 dimensional data, not a list\")\n    return [get_row(lst[1:], x) for x in xrange(len(lst[0]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = sorted(lst, key=lambda x: x[0])\n    sorted_rows.sort(key=lambda x: x[1])\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows = sorted(sorted_rows, key=lambda x: x[1], reverse=True)\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows = [(k, x[1]) for k, x in enumerate(sorted_rows)]\n    sorted_rows.sort(key=lambda x: x[1], reverse=True", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = len(lst) if lst else 0\n    cols = len(lst[0]) if lst else 0\n    sort_rows = lambda rows: rows\n    sort_cols = lambda cols: cols\n    sort_rows(lst, 0)\n    sort_cols(lst[0], 0)\n    return [(x, y) for x, y in itertools.permutations(zip(sort_rows(rows), sort_cols(cols))))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    y = 0\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    for (x, y) in lst:\n        if x < 0:\n            continue\n        if y > y:\n            y2 = y\n            y = y\n            continue\n        if y > y1:\n            y2 = y\n            y1 = y\n            continue\n        if y > y2:\n            y2 = y\n            y2 = y\n            continue\n        if x > x1:\n            x1 = x\n            x1 = x\n            continue\n        if x > x2:\n            x2 = x\n            x2 = x\n            continue\n        x, y = get_row([x, y], x)\n        yield [(x, y), (x2, y2)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0: return []\n    sorted_rows = sorted(lst[0], key=lambda x: x[1], reverse=True)\n    sorted_cols = sorted(lst[1], key=lambda x: x[2], reverse=True)\n    \n    lst1 = list(lst)\n    lst1.sort(key=lambda x: x[0])\n    lst2 = list(lst2)\n    lst2.sort(key=lambda x: x[1])\n    lst3 = list(lst3)\n    lst3.sort(key=lambda x: x[2])\n    # print(lst1[0], lst1[1], lst2[0], lst2[1], lst3[0], lst3[1])\n    return [(get_row(lst1, x), get_row(lst2, x)) for x in zip(sorted_rows, sorted_cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows, columns = lst.shape\n    if not columns == 1:\n        raise ValueError(\"lst is not a 2 dimensional list\")\n\n    rows = range(rows)\n    columns = range(columns)\n    sorted_rows = sorted(rows, key=lambda row_index: row_index[0])\n    sorted_columns = sorted(columns, key=lambda col_index: col_index[0])\n    sorted_rows.reverse()\n    sorted_columns.reverse()\n\n    return zip(*[get_row(row, col) for row, col in zip(sorted_rows, sorted_columns)])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort the coordinates of the list in ascending order\n    lst = sorted(lst, key=operator.itemgetter(0), reverse=True)\n    # sort the rows of the list in descending order\n    lst = [item[0] for item in lst]\n    # go through the list of tuples and test for any match\n    # from the start of the list until the end, and return them\n    if len(lst) == 0:\n        return []\n    elif len(lst) == 1:\n        return lst[0]\n    else:\n        for i in range(len(lst) - 1):\n            for j in range(len(lst[i])):\n                if lst[i][j] == lst[i+1][j]:\n                    return lst[i][:i] + [(i + 1) * len(lst[i]) + j]\n        # find the coordinates of the last element of the list\n        last = lst[-1][-1]\n        last[0], last[1] = last[1], last[0]\n        return [last + [get_row(lst[:-1], x)] for x in lst[:-1]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    res = []\n    for row in lst:\n        for i, col in enumerate(row):\n            res.append((col, x - i)) # add to the list in ascending order\n    res.sort(key=lambda x: (x[0], x[1])) # sort by columns descending\n    res.sort(key=lambda x: (x[0], -x[1])) # sort by rows ascending\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = list(lst)\n    lst.sort(key=lambda x: x[0], reverse=True)\n    lst.sort(key=lambda x: x[1], reverse=True)\n    \n    def __get_row(row):\n        if not row: return None\n        elif row[0] == 0:\n            return [(row[0], row[1])]\n        else:\n            return [(row[0], __get_row(row[1:]))]\n    \n    row = lst[0]\n    row.sort(key=lambda x: x[0], reverse=True)\n    col = lst[1]\n    \n    col.sort(key=lambda x: x[1], reverse=True)\n    \n    return row, col\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #initially sort rows by rows ascending order.\n    lst.sort(key=lambda x: get_row(x, 0), reverse=True)\n    lst.sort(key=lambda x: get_row(x, 1), reverse=True)\n\n    #first step, find the coordinates of x in lst. Just put the row and\n    #columns of the x in the tuples.\n    for i, y in enumerate(lst):\n        if x in y:\n            yield (i, y.index(x))\n    #then sort coordinates of the row in descending order, starting from the\n    #last coordinate in ascending order.\n    lst.sort(key=lambda x: get_row(x, 1), reverse=True)\n    for i, y in enumerate(lst):\n        yield (i, y.index(x))\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort rows by rows in ascending order\n    lst = sorted(lst, key=operator.itemgetter(1), reverse=True)\n    \n    # sort rows by columns in descending order\n    lst = sorted(lst, key=operator.itemgetter(2), reverse=True)\n    \n    # return list of tuples that contains coordinates\n    return [(x, y) for x, y in zip(lst, lst)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get(lst, x):\n        \"\"\"\n        Return the value of the row at position x, and return a tuple\n        of (row, col)\n        \"\"\"\n        if x in lst:\n            return lst[x]\n        else:\n            return None, None\n    \n    if x in lst:\n        return lst[x]\n    else:\n        return None, None", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    r = []\n    columns = []\n    rows = []\n    for row in lst:\n        rows.append(row)\n        for col in row:\n            if col in columns:\n                columns.remove(col)\n            else:\n                columns.append(col)\n        r.append(row)\n        if len(rows) > 1:\n            r.sort(key=lambda x: x[0])\n    return r, columns", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    tmp = []\n    for i in lst:\n        x = i[int(x) - 1]\n        if x in tmp:\n            tmp.remove(x)\n        else:\n            tmp.append(x)\n    return tmp", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    lst, sorted_rows = zip(*sorted(lst))\n    for row, coor in zip(sorted_rows, lst):\n        y = len(coor)\n        if x < y:\n            yield [coor]\n            continue\n        if x > y:\n            yield [get_row(coor[:y], x), get_row(coor[y:], x)]\n        else:\n            for i in range(y+1, x):\n                if x == i:\n                    yield [get_row(coor, i)]\n    if len(lst) == 1:\n        yield [get_row(lst, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    a = [[] for i in range(len(lst))]\n    b = [[] for i in range(len(lst))]\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j]!= x + 1 or lst[i][j+1]!= x:\n                a[i].append(lst[i][j])\n                b[i].append(lst[i][j+1])\n        if len(a[i])!= 0:\n            a.sort(key=lambda x: x[0], reverse=True)\n            b.sort(key=lambda x: x[1], reverse=True)\n    return tuple(a), tuple(b)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_row_zip(lst):\n        \"\"\"\n        Given a list of tuples, [[x1, y1),(x2, y2)...],\n        you need to zip these tuples into one tuple, [(row, columns)],\n        such that the tuples are in ascending order by rows.\n        \"\"\"\n        return zip(*zip(*[(i[0], i[1]) for i in lst]))\n    \n    # First, check whether lst is empty\n    if len(lst) == 0:\n        return []\n    \n    # Then, sort by rows\n    row_arr = [(i, i) for i in lst]\n    row_arr.sort(key=operator.itemgetter(1)) # ascending\n    row_arr.reverse() # descending\n    rows = [row_arr[i][1] for i in row_arr]\n    rows.sort(key=operator.itemgetter(0)) # ascending\n    rows.reverse() # descending\n    \n    # Now, sort by columns\n    col_arr = [(i, i) for i in lst]\n    col_arr.sort(key=operator.itemgetter(0)) # descending\n    col_arr.reverse() # ascending\n    cols = [col_arr[i][1] for i in col_arr]\n    cols.sort(key", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort by row in ascending order\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    # sort by columns in descending order\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    # get last element of each row\n    last = [(x[0], x[1]) for x in lst]\n    # put tuples in the order of x, y\n    return [(getattr(last[-1], x[0]), getattr(last[-1], x[1])) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def gen(n, lst):\n        \"\"\"\n        Generate n row list of coordinates by modifying\n        the original list lst.\n        \"\"\"\n        if n == 0:\n            return lst\n        if len(lst) == 0:\n            return lst\n        #sort by rows in ascending order\n        sorted_lst = [lst[0]]\n        for i in range(1, n):\n            sorted_lst.append(lst[i])\n            lst[i] = sorted_lst[i]\n        #sort by columns in descending order\n        sorted_lst.reverse()\n        return sorted_lst\n\n    def get_row_sorted(lst, x):\n        \"\"\"\n        This function will sort the coordinates of the row given x\n        using the order given by the column index of lst\n        \"\"\"\n        def get_row(lst, i):\n            \"\"\"\n            Return a list of tuples, [(x1, y1), (x2, y2)...]\n            such that each tuple is a coordinate - (row, columns)\n            starting with 0.\n            \"\"\"\n            return get_row(lst, i)[:-1]\n        return gen(0, lst) + get_row(lst, x)[:-1]\n\n    return sorted(get_row(lst, x))</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    res = []\n    for i in lst:\n        j = len(i)\n        if x == j:\n            res.append((x, get_row(i, x + 1)))\n        else:\n            res.append((get_row(i, x), get_row(i, x + 1)))\n            res.append((get_row(i + 1, x), get_row(i + 1, x + 1)))\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # a list of tuples, [(x1, y1), (x2, y2)...] where each tuple is\n    # a coordinate - (row, columns), starting with 0.\n    # Sort coordinates initially by rows in ascending order.\n    # Also, sort coordinates of the row by columns in descending order.\n    #\n    # row = 0 is the first row, which contains coordinates (0, 0), (0, 1),...\n    # column = 0 is the first column, which contains coordinates (0, 0), (0, 1),...\n    #\n    # while row < len(lst):\n    #    row += 1\n    #    col = 0\n    #    while col < len(lst[row]):\n    #        col += 1\n    #        if col == len(lst[row]):\n    #            break\n    #        if lst[row][col] > lst[row][col - 1]:\n    #            # swap row and column\n    #            tmp = lst[row]\n    #            lst[row] = lst[col]\n    #            lst[col] = tmp\n    #        col += 1\n    #        if col == len(lst[row]):\n    #            col = 0\n    #        row += 1\n    #\n    # return", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort coordinates by rows in ascending order\n    # sort coordinates of the row by columns in descending order\n    # list = [[1, 2, 3, 4], [1, 2, 3, 4, 5], [1, 2, 3, 4, 1, 6]]\n    list = lst\n    rows = sorted(list, key=lambda xx: x[0], reverse=True)\n    rows.sort(key=lambda xx: -x[1], reverse=True)\n    for row in rows:\n        cols = sorted(row, key=lambda xx: -x[0], reverse=True)\n        cols.sort(key=lambda xx: -x[1], reverse=True)\n        for col in cols:\n            if col < 0:\n                continue\n            yield (get_row(row, x[0]), get_row(row, x[1] + col))\n\n    # TODO\n    if len(rows) == 1:\n        yield (0, 0)\n\n    if len(rows) == len(cols):\n        return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 2:\n        r, c = lst[0]\n        lst = lst[1:]\n        col = 0\n        rows = []\n        for i,x in enumerate(lst):\n            if len(x) == 1:\n                rows.append(get_row(x, col))\n            else:\n                rows.append(get_row(x, col+1))\n            col += 1\n    else:\n        r, c, m = lst\n        lst = [(get_row(l, i), i) for i, l in enumerate(m)]\n        col = 0\n        rows = []\n        for i,x in enumerate(lst):\n            if len(x) == 1:\n                rows.append(get_row(x, col))\n            else:\n                rows.append(get_row(x, col+1))\n            col += 1\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return lst[0]\n    else:\n        return [(get_row(lst[x], x), get_row(lst[x+1], x)) for x in range(0, len(lst)-1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [(x, x) for x in lst]\n    if len(lst) == 0:\n        return lst\n    # sort by rows\n    row = 0\n    column = 0\n    for x, row in zip(lst, range(len(lst))):\n        for y, column in zip(lst[row], range(len(lst[row]))):\n            if row > column:\n                lst[row].insert(column, lst[row][column])\n                lst[row][column] = None\n                row -= 1\n            else:\n                lst[row].insert(column, None)\n                lst[row][column] = lst[row][column + 1]\n                column += 1\n    return [(x, y) for x, y in zip(lst, range(len(lst)))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst.size == 0:\n        return []\n    x = x % lst.size\n    # First, sort the coordinates of each row in ascending order.\n    coord_array = [[x]] * len(lst)\n    for row in range(len(lst)):\n        coord_array[row] = get_row(lst[row], x + row)\n    # Now, sort the coordinates of each row by columns in descending order.\n    for row in range(len(coord_array)):\n        sorted_coord_array = sorted(coord_array[row], key=lambda (r,c): c, reverse=True)\n        coord_array[row] = sorted_coord_array\n    return coord_array", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # find index of coordinate\n    if len(lst) < x:\n        return []\n    i = 0\n    j = 0\n    # start from index 0\n    while i < x and j < len(lst[i]):\n        # if column is less than or equal to the current column, then\n        # increment i\n        if lst[i][j] < x:\n            i += 1\n        # if the current row is less than or equal to the current row, then\n        # increment j\n        if lst[i][j - 1] < x:\n            j += 1\n    # get coordinates by row and column\n    return [(get_row(lst, i), get_row(lst, j)) for i in range(0, x) for j in range(0, len(lst[i]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return lst[0]\n    r = lst[0][0]\n    c = lst[0][1]\n    col = get_col(lst, r)\n    rows = get_rows(lst, col)\n    row = get_row(rows, r)\n    ret = [(x, y) for (x, y) in zip(row, col) if x > 0 or y > 0]\n    # print ret\n    return ret", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [[(x, 0) for x in lst] for i in range(len(lst) - 1)]\n    return [(get_row(lst[i - 1], x), get_row(lst[i], x)) for i in range(len(lst) - 1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = (x, 0)\n    res = []\n    while row is not None:\n        if row[0] == x:\n            return row\n        row = row[1:]\n        res.append(row)\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    lst = [get_row(lst, x) for x in lst]\n    if len(lst) == 1:\n        return lst[0]\n    else:\n        return tuple(get_row(lst, x) for x in lst)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = []\n    for row in lst:\n        lst.extend([(get_row(row, x), x) for x in range(len(row))])\n        lst.sort(key=lambda x: x[0], reverse=True)\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst == []:\n        return []\n    else:\n        if len(lst[0])!= len(lst[1]):\n            raise ValueError(\"Input list must have the same size\")\n        if len(lst[0])!= len(lst[0][0]):\n            raise ValueError(\"Input list must have the same size\")\n        if len(lst[1])!= len(lst[1][0]):\n            raise ValueError(\"Input list must have the same size\")\n        temp = []\n        for x in range(len(lst[0])):\n            temp.append(get_row(lst[0], x))\n        return temp\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    sorted_coords = []\n    sorted_rows = []\n    for coords in lst:\n        sorted_coords.append(sort(coords))\n        sorted_rows.append(coords)\n    coords = [coords[0] for coords in sorted_coords]\n    rows = [coords[1] for coords in sorted_rows]\n    sorted_rows = [rows[i] for i in sorted_rows]\n    sorted_coords = [rows[i] for i in sorted_rows]\n    return sorted_coords, sorted_rows\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    rows = lst.copy()\n    rows.sort(key=lambda x: x[1])\n    rows.sort(key=lambda x: x[0])\n    rows = rows[0]\n    cols = []\n    for row in rows:\n        col = row.pop(0)\n        cols.append(col)\n        cols.append(col)\n        cols.append(col)\n    return cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sort_coords = [(k + 1) for k in lst]\n    sort_coord = lambda x, y: cmp(x, y) if y > x else cmp(y, x)\n    coord = [(sorted(sort_coords), sorted(sort_coord(x, y))) for (x, y) in zip(sort_coords, sort_coord(sort_coords))]\n    r = [row for row in coord]\n    return r, sorted(coord)\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = sorted(lst, key=lambda row: row[1], reverse=True)\n    # sort rows by columns\n    sorted_rows = list(map(lambda row: row[0], sorted_rows))\n    rows = sorted(sorted_rows, key=lambda row_: row_[0], reverse=True)\n    # sort rows by rows\n    rows = list(map(lambda row: row_[1], rows))\n    return [(get_row(row, x), get_row(row, y)) for (row, x), (row, y) in zip(rows, rows)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 0:\n        return []\n    rows = sorted(lst, key=lambda x: x[0])\n    rows.sort(key=lambda x: x[1])\n    columns = sorted(lst, key=lambda x: x[1])\n    columns.sort(key=lambda x: x[0])\n    # Return row, column pairs, [(row, columns),...]\n    rows = [(row, x) for x in rows]\n    columns = [(column, x) for x in columns]\n    return rows, columns\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst == []:\n        return []\n    elif lst[0] == []:\n        return [(x, 0) for x in lst[1:]]\n    else:\n        return [(x[0], x[1]) for x in lst[1:]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # We do not use itertools here, because we need to take care\n    # of sorting indices of row\n    # List is sorted by rows, so we do not need to sort indices.\n    # We sort rows first, because then columns are sorted.\n    rows = sorted(lst, key=lambda x: get_row(lst, x), reverse=True)\n    rows.sort(key=lambda x: get_row(lst, x))\n    row, col = rows[0]\n    return rows, col", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Initialize arrays\n    rows = []\n    cols = []\n    for i, row in enumerate(lst):\n        rows.append([])\n        cols.append([])\n        # Row is sorted by columns\n        for j, col in enumerate(row):\n            if j < len(col):\n                rows[i].append(x)\n                cols[i].append(j)\n            else:\n                cols[i].append(j-1)\n                rows[i].append(x)\n                cols[i].append(0)\n        # Sort rows by rows in descending order\n        rows.sort(key=lambda row: row[0])\n        # Sort columns by columns in descending order\n        cols.sort(key=lambda col: col[-1])\n\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [(i, j) for i, j in enumerate(lst) if x in lst[i] and len(lst[i]) == x]\n    if len(rows) < 2:\n        return []\n    # sort rows by rows in ascending order\n    rows.sort(key=lambda x: x[1])\n    rows.sort(key=lambda x: x[0])\n    # sort rows by columns in descending order\n    rows = sorted(rows, key=lambda x: (x[1], -x[0]))\n    return [[row[0], row[1]] for row in rows]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    colidx = []\n    rowidx = []\n    for idx, row in enumerate(lst):\n        for col in row:\n            colidx.append(idx+1)\n            rowidx.append(0)\n            if col!= None:\n                rowidx.append(col+1)\n    return colidx, rowidx", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows, cols = len(lst), len(lst[0])\n    sort_rows, sort_cols = list(zip(range(rows), range(cols)))\n    sort_rows.sort(key=lambda x: x[0])\n    sort_cols.sort(key=lambda x: x[1])\n    return [(get_row(lst, x)[0], get_row(lst, x)[1]) for x in sort_rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sort_list(lst, rows)\n    col = 0\n    while col < len(lst):\n        coord = get_row(lst, col)\n        if coord[0] == 1:\n            row = coord[1]\n        else:\n            row = col\n            for i in range(len(coord[0])):\n                yield coord\n                col += len(coord[0]) + 1\n        col += len(coord[0]) + 1", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [(i,j) for i in x for j in x]\n    lst.sort(key=lambda x:x[0])\n    return [(get_row(lst, x),get_row(lst, x+1)) for x in range(1,len(lst),2)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # we sort coordinates in ascending order, and then\n    # sort by columns in descending order\n    sorted_rows = sorted(lst, key=operator.itemgetter(0))\n    sorted_cols = sorted(lst, key=operator.itemgetter(1))\n    sorted_rows.reverse()\n    sorted_cols.reverse()\n\n    # check if x is in the list\n    if x in sorted_rows:\n        return [(sorted_rows[x][0], sorted_rows[x][1])]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst == []:\n        return []\n    \n    if len(lst) == 0:\n        return []\n    \n    colorder = [col for row in lst for col in row]\n    roworder = [row for col in colorder for row in colorder]\n    \n    x = 0\n    \n    try:\n        return [(x, list(roworder)) for x in range(len(colorder))]\n    except TypeError:\n        # check if colorder is already sorted, if not, sort it\n        if len(colorder) == 1:\n            colorder.sort()\n            colorder.reverse()\n            roworder.sort()\n            roworder.reverse()\n            return get_row(lst, x)\n        else:\n            return get_row(lst, x)\n    \n    # Sort by rows in ascending order\n    return [(x, list(roworder)) for x in range(len(colorder))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get coordinate and sort it\n    xidx = x\n    xrows = [(0, 0)]\n    xcols = [0]\n    for row in lst:\n        for col in row:\n            if col == xidx:\n                xrows.append(row)\n                xcols.append(col)\n                break\n    if len(xrows) > 1:\n        # Sort by row\n        xrows.sort()\n        # Sort by columns\n        xcols.sort()\n        # Now it is up to you how to sort the tuples here\n        # (rows, columns) pairs\n    else:\n        # Sort by rows\n        xrows.sort()\n        # Now it is up to you how to sort the tuples here\n        # (rows, columns) pairs\n    # Now, we have a list of tuples, ordered by rows, sorted by columns\n    # So, we can loop over it and find the corresponding coordinate\n    yrows = [(0, 0)]\n    ycols = [0]\n    for row in xrows:\n        for col in row:\n            if col == xidx:\n                yrows.append(row)\n                ycols.append(col)\n                break\n    if len(yrows) > 1:\n        # Sort by rows\n        yrows.sort()\n        # Sort by columns\n        y", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = 0\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    rows = [x[0] for x in lst]\n    rows.sort(key=lambda x: x[1], reverse=True)\n    lst = [[x for x in y] for y in rows]\n    x = 1\n    while True:\n        x -= 1\n        if x < len(lst):\n            lst.insert(0, (x, lst[x][1]))\n        else:\n            return lst\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # sort the rows in descending order\n    r = sorted(lst, key=lambda x: x[1], reverse=True)\n    \n    # now sort the columns in descending order\n    c = sorted(lst[0], key=lambda x: x[0], reverse=True)\n    \n    # return the data in a tuple\n    return tuple([(get_row(r, c), get_row(r, c + 1)) for c in range(len(r))])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Start by sorting coordinates of rows by rows in ascending order\n    lst = list(sorted(lst))\n    # Sort coordinates of the row by columns in descending order\n    lst = list(sorted(lst[1:]))\n    # Now, find all coordinate pairs\n    indexes = []\n    for i in range(len(lst[0])):\n        for j in range(len(lst[1])):\n            # Get the coordinates of the row\n            if i == 0 and j == 0:\n                # The row starts with (0, 0)\n                indexes.append((0, 0))\n            elif i == 0 and j!= 0:\n                # The row starts with (0, 0)\n                indexes.append((0, 0))\n            elif i!= 0 and j == 0:\n                # The row starts with (0, 0)\n                indexes.append((0, 0))\n            elif i!= 0 and j!= 0:\n                # The row starts with (0, 0)\n                indexes.append((0, 0))\n            else:\n                # The row starts with (0, 0)\n                indexes.append((0, 0))\n            # Get the coordinates of the column\n            if j == 0 and i == 0:\n                # The column starts with (0, 0)\n                indexes.append((0, 0))\n            elif j", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def f(idx, lst):\n        if len(lst) == 0:\n            return ()\n        row = lst[idx]\n        column = 0\n        for i in range(len(row)):\n            x = row[i]\n            if column == len(x):\n                return f(idx+1, lst)\n            elif column < len(x):\n                y1 = x[column]\n                if y1 not in lst:\n                    return f(idx+1, lst)\n                x.append(y1)\n                y1 = y[column]\n                if y1 not in lst:\n                    return f(idx+1, lst)\n            else:\n                y2 = x[column]\n                if y2 not in lst:\n                    return f(idx+1, lst)\n                x.append(y2)\n                y2 = y[column]\n                if y2 not in lst:\n                    return f(idx+1, lst)\n        return f(idx+1, lst)\n    return f(0, lst)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: get_row(lst, x[0]), reverse=True)\n    lst = sorted(lst, key=lambda x: get_row(lst, x[1]), reverse=True)\n    return tuple([(x[0], x[1]) for x in lst])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i, j = 0, len(lst[0])\n    while i < j:\n        if i == x:\n            return lst[i]\n        if lst[i][0] == lst[j][0]:\n            return get_row(lst, x)\n        i, j = j, len(lst[i])\n    return [(x, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def cmp(x1, x2):\n        \"\"\"\n        Cmp the rows of two tuples.\n        \"\"\"\n        return cmp(get_row(lst, x), get_row(lst, x))\n    if len(lst) == 1:\n        x = lst[0]\n    else:\n        x = x[0]\n        lst = lst[1:]\n    return x, [cmp(get_row(lst, y), get_row(lst, x)) for x, y in zip(x, lst)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    else:\n        for row in lst:\n            for col in row:\n                if col[0] <= x:\n                    return [(row, col)]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    n_rows = len(lst)\n    n_cols = len(lst[0])\n    if n_rows == 1:\n        return lst[0]\n    else:\n        n_rows = n_rows + 1\n        n_cols = n_cols + 1\n        x = x % n_cols\n        if x < 0:\n            x += n_cols\n        else:\n            x -= n_cols\n        return [(get_row(lst, x), get_row(lst[1:], x - 1)) for _ in xrange(n_rows)]\n\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if type(lst) == list:\n        sorted_lst = sort_list(lst)\n        # Sort each row by its coordinate in ascending order.\n        sorted_lst.sort(key=lambda x: get_row(x, 0))\n        # Sort each row by its coordinate in descending order.\n        sorted_lst.sort(key=lambda x: get_row(x, 1))\n        # Create list of tuples for each row.\n        # The first tuple is the coordinate of the row.\n        # The second tuple is a list of coordinates of the columns of the\n        # row, in descending order. \n        row_tuples = [(x, [get_column(y, 0) for y in sorted_lst[y]])\n                     for x in sorted_lst]\n        return row_tuples\n    else:\n        raise TypeError(\"get_row() function must be called on a list of \"\n                        \"tuples. Got: %s\" % type(lst))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort rows\n    lst = sorted(lst, key=lambda row : row[0])\n    row_index = 0\n    while row_index < len(lst) - 1:\n        # Sort rows by columns\n        lst = sorted(lst[row_index: row_index + len(lst[row_index])], key=lambda col: col[0])\n        col_index = 0\n        while col_index < len(lst) - len(lst[row_index]):\n            # Calculate row and column coordinates\n            row = row_index\n            col = col_index\n            # Check if coordinates are same\n            if row == col:\n                # y - coordinate is the same for row\n                y_coordinate = row_index\n                # x - coordinate is the same for row\n                x_coordinate = col_index\n                # We are done\n                break\n            # Check if x coordinates are same\n            if lst[row_index][0] == lst[row][col_index]:\n                # x - coordinate is the same for row\n                x_coordinate = col_index\n                # y - coordinate is the same for row\n                y_coordinate = row_index\n                # We are done\n                break\n            # x coordinates are different - continue\n            col_index += 1\n        # We are done\n        row_index += 1\n    # Calculate coordinates\n    return [(", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 2:\n        return lst[0]\n    else:\n        i = 0\n        # iterate over the rows and columns\n        rows = [row for row in lst]\n        i += 1\n        # iterate over the rows and columns and sort by columns\n        rows.sort(key=lambda row: row[-2])\n        # iterate over the rows and columns and sort by rows\n        rows.sort(key=lambda row: row[-1])\n        # iterate over the rows and sort the column by the same order\n        for row in rows:\n            col = row[-1]\n            for col in row[:-1]:\n                col = col[0]\n        # iterate over the columns and sort the row by the same order\n        for col in cols:\n            row = col[0]\n            for row in row[1:]:\n                row = row[1]\n        # iterate over the row and return a list of tuples\n        return [(x, y) for x, y in zip(rows[i], cols[:i])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    \n    lst = [list(lst)]\n    for i in range(len(lst[0])):\n        i = list(i)\n        i.sort()\n        if len(i) > 0:\n            idx = i.index(x)\n            if idx >= len(i):\n                lst.append([(x, 0)])\n                idx = 0\n            lst[idx][0] = i[idx]\n            lst[idx][1] = len(i) - idx\n        else:\n            lst.append([(x, 0)])\n    \n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort coordinates by rows in ascending order\n    sortedrows = sorted(lst, key=lambda x: x[0], reverse=True)\n    # sort coordinates of the row by columns in descending order\n    sorted_rows = [(row, c) for row, c in sortedrows for c in sorted(x, key=lambda x: x[1])]\n    return [(x[0], x[1]) for x in sorted_rows]</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    numrows = len(lst)\n    numcols = len(lst[0])\n    rowlist = [(x, y) for x, y in zip(lst, range(numrows))]\n    collist = [(x, y) for x, y in zip(range(numrows), lst)]\n    rowlist.sort(key=lambda x: x[0])\n    collist.sort(key=lambda x: x[1])\n    return [(get_row(row, x), get_row(col, y)) for x, y in zip(rowlist, collist)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = x % len(lst[0])\n    if x < 0:\n        x = len(lst[0]) + x + 1\n    elif x > len(lst[0]):\n        x = len(lst[0]) + x - 1\n    for r, c in zip(lst[1:], lst[:-1] + [0]):\n        if c < x:\n            y = r\n            x = c\n            break\n    return [(x, y)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [(x, x) for x in lst]\n    if len(lst) == 0:\n        return []\n    return [(x, x) for x in sorted(lst, key=get_row)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise ValueError('Argument lst is not a 2 dimensional list')\n    if x < 0:\n        raise ValueError('Argument x is negative')\n    \n    rank = 0\n    rows = lst[0]\n    cols = lst[1]\n    for i in xrange(len(rows)):\n        if rows[i] <= x:\n            if cols[i] > x:\n                rank += 1\n                rows[i], cols[i] = rows[i], cols[i] - x\n                if rank > len(rows):\n                    break\n        else:\n            break\n\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    y = len(lst)\n    if len(lst) == 1:\n        return [(x, y) for x in lst]\n    else:\n        sort_coord(lst, x)\n        sort_coord(lst, y)\n        return [(x, y) for x in lst for y in get_row(lst, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return lst[0]\n    else:\n        sort_coord = []\n        sort_rows = []\n        sort_cols = []\n        for row in lst:\n            sort_rows.append(row[0])\n            sort_cols.append(row[1])\n            sort_coord.append(row[2])\n            sort_rows.append(row[0])\n            sort_cols.append(row[1])\n            sort_coord.append(row[2])\n        sort_rows.reverse()\n        sort_cols.reverse()\n        return [(x, y) for x, y in zip(sort_coord, sort_rows)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = map(list, lst)\n    y = x % len(lst[0])\n    x = x // len(lst[0])\n    new_y = len(lst) - y - 1\n    x = x % len(lst[0])\n    x = x // len(lst[0])\n    l = [(lst[y], lst[x])]\n    y = new_y\n    while l:\n        l.append((lst[y], lst[x]))\n        y = new_y\n        if (y % len(lst[0])) == 0:\n            x = x // len(lst[0])\n            x = x % len(lst[0])\n        else:\n            x = x // len(lst[0])\n            x = x % len(lst[0])\n    return l", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    # sort the rows in ascending order\n    i = 0\n    rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    for row in rows:\n        for x in get_row(row, x):\n            yield tuple(x)\n    # now sort the columns in descending order\n    i = 1\n    cols = sorted(lst, key=lambda x: x[1], reverse=True)\n    for column in cols:\n        for x in get_row(row, x[0]):\n            yield tuple(x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    res = []\n    for row in lst:\n        for col in row:\n            if col!= x:\n                res.append((row[col-1], col))\n        res.sort()\n        res.reverse()\n        for row in res:\n            rows = get_row(row, x)\n            res.append(rows)\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = sorted(lst, key=lambda x: x[0])\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    sorted_rows = [(i, j) for (i, j) in zip(sorted_rows, sorted_rows[1:])]\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    return [[(i, j)] for i, j in zip(sorted_rows, sorted_rows[1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst.shape[0] == 2:\n        y, x = lst.shape\n        y = y + 1\n    else:\n        raise ValueError(\"Input list has wrong number of columns\")\n    if lst[0].shape[0] == 2:\n        y, x = lst[0].shape\n        y = y + 1\n    return [get_row(lst[1:], x - 1)] + [(0, 0)] + [(y, y)] + \\\n          get_row(lst[1:], x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    def get_row(lst, x):\n        \"\"\"\n        \"\"\"\n        lst.sort(key=lambda x: x[0])\n        # Sort rows by descending order of columns\n        lst.sort(key=lambda x: x[1], reverse=True)\n        return [x[1] for x in lst]\n    return [get_row(lst, x) for x in range(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    col_order = {}\n    rows = []\n    for i in range(len(lst)):\n        row = [get_row(lst[i], x) for x in xrange(len(lst[i]))]\n        rows.append(row)\n        col_order[row[0]] = i\n    rows.sort(key=operator.attrgetter(0))\n    rows.sort(key=operator.attrgetter(1))\n    return [(row[0], col_order[row[1]]) for row in rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = list(lst)\n    lst.sort(key=lambda x: (x[0], x[1]))\n    n, m = len(lst[0]), len(lst)\n    nrows = len(lst[0])\n    ncols = len(lst[0][0])\n    rows = []\n    cols_per_row = []\n    for i in range(0, n):\n        if i > 0:\n            rows.append(0)\n            cols_per_row.append(0)\n        rows.append(i)\n        cols_per_row.append(0)\n        for j in range(0, ncols):\n            if j > 0:\n                if (rows[i], cols[j]) not in cols_per_row:\n                    cols_per_row.append((rows[i], cols[j]))\n    cols_per_row.sort(key=lambda x: (x[1], x[0]))\n    rows.sort(key=lambda x: (x[0], x[1]))\n    return [(x[0], x[1]) for (x, y) in zip(rows, cols_per_row)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort the coordinates, initially, by row and columns.\n    sorted_rows = sorted(lst[0], key=lambda x: x[1], reverse=True)\n    sorted_columns = sorted(lst[1], key=lambda x: x[0], reverse=True)\n    \n    # Now sort the rows, by columns, in descending order.\n    sorted_rows.sort(key=lambda x: x[0], reverse=True)\n    sorted_columns.sort(key=lambda x: x[1], reverse=True)\n    \n    # Now return the tuples, with the correct coordinates.\n    return [(x[0], x[1]) for x in sorted_rows] + [(x[0], x[1]) for x in sorted_columns]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = [[], [], [], [], [], [], [], [], [], [], []]\n    for i in xrange(len(lst)):\n        temp = []\n        for j in lst[i]:\n            temp.append(j)\n        row[0].append(x)\n        row[1].append(len(temp))\n        row[2].append(temp)\n        row[3].append(temp[0])\n        row[4].append(temp[1])\n        row[5].append(temp[2])\n        row[6].append(temp[3])\n        row[7].append(temp[4])\n        row[8].append(temp[5])\n        row[9].append(temp[6])\n        row[10].append(temp[7])\n        row[11].append(temp[8])\n        row[12].append(temp[9])\n        row[13].append(temp[10])\n        row[14].append(temp[11])\n        row[15].append(temp[12])\n        row[16].append(temp[13])\n        row[17].append(temp[14])\n        row[18].append(temp[15])\n        row[19].append(temp[16])\n        row[20].append(temp[17])\n    return row\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def is_col(x):\n        if len(x) == 1:\n            return True\n        else:\n            return False\n    \n    row = [list() for x in lst]\n    i = x\n    while True:\n        y = lst[i]\n        if is_col(y):\n            row.append(i)\n            i += 1\n            continue\n        elif y == x or is_col(y):\n            row.append((x, i))\n            i += 1\n        else:\n            raise ValueError(\"Input not valid.\")\n    \n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    \n    def x_ord(x):\n        return [y[1] for y in sorted(lst, key=lambda y: x[1])]\n    \n    lst = [(x, y) for x, y in zip(lst, x_ord(x))]\n    lst.sort(key=lambda x: x[0])\n    lst.reverse()\n    return list(zip(*get_row(lst, x)) for x in x_ord(x))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [row for row in lst]\n    rows.sort(key=lambda x: x[1], reverse=True)\n    return [(x[0], x[1]) for x in get_row(rows, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) < 2:\n        return None\n    # Get list of coordinates\n    lst_row, lst_col = [int(x) for x in lst], [int(x) for x in lst]\n    if len(lst_row)!= len(lst_col):\n        return None\n    # Sort rows\n    lst_row.sort(key=lambda x: x[0])\n    # Sort columns\n    lst_col.sort(key=lambda x: x[1])\n    # Get coordinates\n    row, col = [int(x) for x in lst_row]\n    col.reverse()\n    for i in range(len(lst_row)):\n        row = [int(x) for x in lst_row[i] if x not in row]\n        if len(row) == 1:\n            continue\n        col = [int(x) for x in lst_col[i] if x not in col]\n        if len(col) == 1:\n            continue\n        if row == col:\n            continue\n        row.append(col[0])\n        col.append(row[1])\n        row.sort(key=lambda x: x[1])\n        col.sort(key=lambda x: x[0])\n    return [(row, col)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return sorted([x for x in lst if x[0] == x[1]], key=lambda x: x[0], reverse=True)[:-] + get_row(lst, x) + get_row(lst, x[1:]) + [(0, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    rows = list(zip(*[iter(lst)] * len(lst)))\n    rows.sort(key=lambda x: int(x[1]))\n    cols = list(zip(*[iter(lst)] * len(lst)))\n    cols.sort(key=lambda x: int(x[0]))\n    return [(rows[x], cols[x]) for x in range(len(rows))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    assert len(lst) == 2\n    ordered = [(x, y) for x, y in zip(lst[1:], lst[:-1])]\n    sorted_rows = sorted(ordered, key=lambda x: x[0], reverse=True)\n    sorted_cols = sorted(ordered, key=lambda x: x[1], reverse=True)\n    rows = [row for (row, col) in zip(sorted_rows, sorted_cols)]\n    col_pos = [0] * len(rows)\n    x = 0\n    for row in rows:\n        x += row\n        col_pos.append(x)\n    return [(x, y) for (x, y) in zip(rows, col_pos)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = [row for row in lst if row]\n    sorted_rows.sort(key=lambda row: row[0], reverse=True)\n    sorted_rows.sort(key=lambda row: row[1], reverse=True)\n    sorted_rows.reverse()\n\n    rows = [row.pop(0) for row in sorted_rows]\n    rows.reverse()\n    for row in sorted_rows:\n        for i in range(len(row)):\n            yield (row[i], row[i+1])\n    if not lst:\n        return\n\n    for row in sorted_rows:\n        for i in range(len(row)):\n            yield (row[i], row[i+1])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    assert len(lst) == 2, \"get_row: given list length not matched\"\n    lst = lst[1:] if lst[0] else lst[:1]\n    sorted_rows = []\n    sorted_cols = []\n    for row in lst:\n        sorted_rows.append(get_row(row, 0))\n        sorted_cols.append(get_row(row, 1))\n    sorted_rows.sort(key=lambda x: x[0])\n    sorted_cols.sort(key=lambda x: x[1])\n    return [(i, j) for i in range(len(sorted_rows)) for j in range(len(sorted_cols))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Check to see if we have a list of tuples\n    if type(lst) == list and len(lst) == 2:\n        lst = tuple(lst)\n\n    # Get the coordinates of the rows, sort them\n    rows = [row for row in lst]\n    rows.sort(key=lambda row: row[1])\n    rows = [row for row in rows if row[0]]\n    \n    # Get the coordinates of the columns, sort them\n    columns = [col for col in lst]\n    columns.sort(key=lambda column: column[0])\n    columns = [col for col in columns if column[1]]\n    \n    # Now, for each row, sort by columns in descending order\n    for row in rows:\n        # Get the coordinates of the rows, sort them\n        rows = [row for row in lst if row[0] == row[0]]\n        rows.sort(key=lambda row: row[1])\n        rows = [row for row in rows if row[0]]\n        \n        # Get the coordinates of the columns, sort them\n        columns = [col for col in lst if col[0] == column[0]]\n        columns.sort(key=lambda column: column[1])\n        columns = [col for col in columns if column[1]]\n        \n        # Now, for each row, sort by columns in ascending", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sort_cols = (len(lst)-1) * len(lst[0]) + x\n    sort_rows = sorted(lst[:len(lst)-1], key=lambda x: x[0], reverse=True)\n    sort_rows.reverse()\n    sort_cols.reverse()\n    rows = []\n    for row in sort_rows:\n        rows.append([get_row(row, i) for i in xrange(len(row[0]))])\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [[row, j] for j, row in enumerate(lst) if j!= x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_dup_row(lst):\n        \"\"\"\n        Given a list of tuples,\n        return a list of tuples, [(x1, y1), (x2, y2)...] such that\n        each tuple is a coordinate - (row, columns), starting with 0.\n        Sort coordinates initially by rows in ascending order.\n        Also, sort coordinates of the row by columns in descending order.\n        \"\"\"\n        dup_list = []\n        for i in range(len(lst)):\n            row = lst[i][0]\n            for j in range(len(lst[i])):\n                if row == lst[i][j][0]:\n                    dup_list.append((lst[i][0], lst[i][j][1]))\n        return dup_list\n    def check_row(lst):\n        \"\"\"\n        Given a list of tuples,\n        return a tuple - (row, columns), where row is the row in the data,\n        and columns are the number of columns in the row.\n        \"\"\"\n        for i in range(len(lst)):\n            if lst[i][0] == 0:\n                return (i, len(lst[i]))\n        return (None, None)\n    # Create the data structure\n    data = []\n    for row in lst:\n        data.append(row)\n    data.sort(key=lambda x: get_dup_row(x))\n    # Sort", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    t = []\n    for i in range(len(lst)):\n        r,c = lst[i]\n        if c == 0:\n            if r == 0:\n                t.append((0,r))\n            else:\n                t.append((r,0))\n        else:\n            for j in range(len(lst)):\n                if r == lst[j][0]:\n                    t.append((r,j))\n                elif lst[j][0] > r:\n                    t.append((r,j+1))\n                else:\n                    t.append((r,0))\n    return sorted(t, key=lambda x: x[0])[0:len(t)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = lst[0]\n    cols = lst[1]\n    if len(cols)!= len(rows):\n        return []\n    sorted_rows = sorted(rows, key=lambda x: x[0])\n    sorted_cols = sorted(cols, key=lambda x: x[1])\n    ordered = [[(i, j) for i, j in enumerate(sorted_rows) if i > 0 and j > 0]]\n    ordered.append((0, len(rows)))\n    ordered.append((0, len(cols)))\n    ordered.append((1, len(rows)))\n\n    # sort rows\n    for row in ordered[1:]:\n        sorted_rows.sort(key=lambda x: x[0])\n        rows.sort(key=lambda x: x[0])\n\n    # sort columns\n    for col in ordered[1:]:\n        sorted_cols.sort(key=lambda x: x[1])\n        cols.sort(key=lambda x: x[1])\n\n    return ordered", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows, cols = lst.shape\n    def get_row_list(lst, i):\n        \"\"\"\n        If lst[i] contains more than one element, return\n        a list of tuples, [(x1, y1), (x2, y2)...] such that\n        each tuple is a coordinate - (row, columns), starting with 0.\n        Sort coordinates initially by rows in ascending order.\n        Also, sort coordinates of the row by columns in descending order.\n        \"\"\"\n        a, b, c, d, e, f = lst[i]\n        return [(a, b), (c, d), (e, f)]\n    \n    # Sort by rows\n    rows_asc = sorted(rows, key=lambda x: x[0])\n    rows_desc = sorted(rows_desc, key=lambda x: x[0])\n    \n    # Sort by columns\n    columns_desc = sorted(cols, key=lambda x: x[-1])\n    columns_asc = sorted(cols, key=lambda x: x[-1])\n    \n    # Determine the x, y coordinate pairs for each row\n    x_list = []\n    y_list = []\n    for row in rows_asc:\n        x_list.append(get_row_list(row, 0))\n        y_list.append(get_row_list(row, 1))\n    return x_list, y_list", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst is None:\n        return []\n\n    ncols = len(lst[0])\n    rows = len(lst)\n\n    if ncols > 1:\n        idx = 0\n        for row in xrange(rows):\n            for col in xrange(ncols):\n                if row == idx and col == 0:\n                    return get_row(lst[1:], x)\n                    break\n            idx += 1\n\n    else:\n        row = 0\n        for row in xrange(rows):\n            if row == 0:\n                return get_row(lst[1:], x)\n                break\n            row += 1\n        for row in xrange(rows):\n            if row == 0:\n                return get_row(lst[1:], x)\n                break\n\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # check inputs\n    assert len(lst) == len(x), \"Input list (%s) length (%s) is not the same as the number of columns (%s)\" % (lst, len(lst), len(x))\n    # check whether coordinates are in ascending order\n    sortedcoordinates = sorted(lst, key=operator.itemgetter(0), reverse=True)\n    sortedcoordinates = sortedcoordinates[:-1] # remove last coordinate\n    sortedcoordinates = sortedcoordinates[1:] # remove last coordinate\n    # sort coordinates of the row by columns in descending order\n    sortedcoordinates = sortedcoordinates[:len(x)] + [(0, 0)] * len(x)\n    # get sorted coordinates\n    sortedcoordinates = sortedcoordinates.translate(None, list('abc'))\n    # convert sorted coordinates to tuple\n    return [(get_row(lst, co.start), get_row(lst, co.end)) for co in sortedcoordinates]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_row_to_sorted(lst, x):\n        \"\"\"\n        Given the input list of coordinates, sort them in order.\n        \"\"\"\n        sorted_coords = sorted(lst)\n        sorted_coordinates = sorted(sorted_coords, key=lambda x: x[0])\n        # sort coordinates in ascending order\n        sorted_coordinates.sort()\n        # sort coordinates by columns\n        sorted_coordinates.reverse()\n        return [(x[0], x[1]) for x in sorted_coordinates]\n    rows = get_row_to_sorted(lst, x)\n    sorted_rows = sort_row(rows)\n    return [(row, sorted_column) for row, sorted_column in zip(rows, sorted_rows)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    arr = []\n    row = []\n    col = 0\n    for row_idx, row in enumerate(lst):\n        for column_idx, col in enumerate(row):\n            arr.append((row_idx, column_idx))\n            row.append(col)\n            col += 1\n    if col == x:\n        return arr\n    else:\n        return get_row(arr, x-1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # TODO: this code is not correct, and needs to be refactored\n    # and optimized\n    sorted_rows = sorted(lst, key=lambda x: x[1].lower() < x[0].lower()) # we sort the list\n    sorted_rows.sort(reverse=True) # we sort the list by descending order\n    if len(sorted_rows) == 1:\n        return sorted_rows[0] # this is the first row\n        # we return the first row as a single tuple\n    else:\n        return [[get_row(y, x), x] for y, x in zip(sorted_rows, sorted_rows[1:])] # we return a tuple of tuples\n    \n    # this code is probably not the best solution.\n    # but, it's the only solution I have found for this problem\n    # and I think it's sufficient for the purpose\n    # it should be rewritten as a function\n    return zip(*[get_row(y, x) for y, x in zip(sorted_rows, sorted_rows[1:])])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    tmp = [x for x in lst if x[1] == x[0]]\n    if len(tmp) == 2:\n        return tmp\n    x = x[0]\n    y = x[1]\n    if len(x) == 1:\n        return []\n    if len(y) == 1:\n        return [(y[0], y[1])]\n    if len(x)!= len(y):\n        return []\n    # sort rows\n    for i in range(0, len(tmp)):\n        if tmp[i][1] == tmp[i][0]:\n            tmp[i] = tmp[i][1:]\n        else:\n            tmp[i] = tmp[i][:1]\n    # sort columns\n    for i in range(len(tmp) - 1, -1, -1):\n        if tmp[i][1] < tmp[i+1][1]:\n            tmp[i] = tmp[i+1]\n            tmp[i+1] = tmp[i][1:]\n        else:\n            tmp[i] = tmp[i][1:]\n    return tmp", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted_rows = [[(x, row) for row, x in lst.iterrows()] for x in xrange(len(lst))]\n    sorted_rows.sort(key=lambda x: x[0], reverse=True)\n    sorted_rows.sort(key=lambda x: x[1], reverse=True)\n    \n    sorted_rows.reverse()\n    \n    sorted_row = sorted_rows[0][0]\n    for row in sorted_row:\n        sorted_row.remove(row)\n\n    return sorted_row</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    arr = []\n    for i in lst:\n        for j in i:\n            if j!= x and j!= 0:\n                arr.append((get_row(i, j), j))\n            else:\n                arr.append((0, j))\n        # sort the column by descending order\n        arr.sort(key=lambda x: x[2], reverse=True)\n        # sort the row by descending order\n        arr.sort(key=lambda x: x[0], reverse=True)\n    return arr", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= 0:\n        return [(0, 0), (0, 0)]\n\n    # Sort column names ascending\n    sort_col_names(lst)\n    sort_cols(lst, 0)\n\n    # Sort rows ascending\n    sort_rows(lst, 0)\n\n    # Sort rows by columns descending\n    sort_rows(lst, 1)\n\n    # Initialize to empty list\n    result = []\n\n    # For each row\n    for row in lst:\n        result.append([])\n\n        # For each column\n        for column in row:\n            # Calculate row coordinate\n            result[row[0]].append(column)\n\n    # Sort rows by columns in descending order\n    sort_rows(result, 0)\n\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 0:\n        return [(x, len(lst)) for x in lst]\n    else:\n        sorted_data = sorted(lst, key=lambda x: x[1])\n        sorted_data = sorted(sorted_data, key=lambda x: x[0])\n        new_data = []\n        if len(sorted_data) == 1:\n            new_data.append((sorted_data[0], 0))\n        else:\n            new_data.append((sorted_data[0], len(sorted_data)-1))\n            for i, row in enumerate(sorted_data):\n                for j, column in enumerate(row):\n                    if j == len(row)-1:\n                        new_data[-1].append(j)\n                    else:\n                        new_data[-1].append(j-1)\n        return [(get_row(row, x), get_row(column, x)) for x in new_data]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # the first step is to sort the coordinates by rows, in ascending order\n    lst = sorted(lst, key=lambda x: x[1])\n    # we need to sort the rows by columns, in descending order\n    lst = sorted(lst, key=lambda x: -x[1])\n\n    # the next step is to create a dict where the key is the row, and\n    # the value is the tuple of coordinates\n    rowdict = {}\n\n    # for each row in the list, we create a dict containing a tuple\n    # of coordinates. The key is the row, and the value is the tuple\n    # of coordinates\n    for i, row in enumerate(lst):\n        rowdict[row] = get_row(row, i + 1)\n\n    # now we return the tuples that were created\n    return sorted(rowdict, key=lambda x: x[1])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(x, y) for (x, y) in lst]\n    if x == 0:\n        return get_row(lst, len(lst)-1)[0]\n    else:\n        for i in xrange(len(lst)):\n            tmp = [(get_row(lst, i+1)[x], get_row(lst, i+1)[y]) for (x, y) in lst]\n            if tmp[0][1] < tmp[0][0]:\n                tmp[0][0], tmp[0][1] = tmp[1][0], tmp[1][1]\n            if tmp[1][1] < tmp[0][1]:\n                tmp[0][1], tmp[1][1] = tmp[2][0], tmp[2][1]\n        tmp = [(x, y) for (x, y) in lst]\n        tmp = sorted(tmp, key=lambda (x, y): tmp[0][1], reverse=True)\n        return tmp\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise TypeError(\"Expected a 2 dimensional data, but got a %d\" % len(lst))\n    if x == 0:\n        return lst\n    else:\n        xs = []\n        ys = []\n        r = 0\n        c = 0\n        for row in lst:\n            xs.append(get_row(row, x))\n            ys.append(get_direction(xs, r))\n            r += 1\n            c += 1\n        xs.sort(key=lambda x:x[0])\n        ys.sort(key=lambda x:x[1])\n        return xs, ys", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    assert len(lst) == 2\n    # rows are sorted by descending rows order\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    rows = lst[0]\n    # rows are sorted by ascending columns order\n    # FIXME - this is a hack to simplify\n    # the code below. could be done better.\n    # First, find the columns\n    for i in range(len(rows)):\n        if x <= rows[i][0]:\n            idx = i + 1\n            break\n    # find the first row with an x in it.\n    # I.e. I want the row with an x in the list.\n    for i in range(len(rows)):\n        if x <= rows[i][1]:\n            idx = i\n            break\n    if x in rows:\n        return rows[idx]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    sorted = sorted(lst, key=lambda x: (x[0], x[1]))\n    sorted.sort(key=lambda x: x[1])\n    sorted.sort(key=lambda x: x[0])\n    \n    for x in sorted[:-1]:\n        # do step(x[0],x[1])\n        yield tuple(get_row(x, 1))\n    yield tuple(get_row(sorted[-1], 1))\n    yield tuple(get_row(sorted[-1], -1))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = list(zip(range(len(lst)), lst))[-1]\n    row, col = l\n    sorted_rows = [row]\n    sorted_cols = [col]\n    n_rows = len(row)\n    n_cols = len(col)\n\n    while len(row)!= 1:\n        if col == 0:\n            row = row[1:]\n        else:\n            col = col - 1\n            if col == 0:\n                sorted_rows.append(row)\n                sorted_cols.append(col)\n                n_rows, n_cols = n_rows, n_cols - 1\n        if n_rows!= len(row):\n            row = row[1:]\n\n    if n_rows!= len(row):\n        sorted_rows.append(row)\n        sorted_cols.append(col)\n\n    return sorted_rows, sorted_cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    x = int(x)\n    list_rows = []\n    for row in lst:\n        list_rows.append([])\n        for col in row:\n            list_rows[-1].append(int(col))\n    return list_rows</s>"]]