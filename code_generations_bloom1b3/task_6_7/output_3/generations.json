[["from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Init list of nested parentheses\n    paren_list: List[int] = []\n    # Loop through the string and add new group in the end\n    # Only add new groups if they have not been already added\n    for paren in paren_string:\n        # Is this a group?\n        if paren == '(':\n            # Add this to the list of groups\n            paren_list.append(-1)\n        elif paren == ')':\n            # Get the top level of nesting\n            nesting_level: int = -1\n            # Is this the top level?\n            if paren_list[-1] == -1:\n                # Yes, is it the last one?\n                if paren_list[-2] == -1:\n                    # Yes, is it the last one?\n                    nesting_level = max(nesting_level, paren_list[-1])\n                else:\n                    # No, is it the last one?\n                    nesting_level = max(nesting_level, paren_list[-1] + 1)\n            # Get the next level of nesting\n            next_level: int = paren_list[-2]\n            # Add this to the list of groups\n            paren_list.append(nesting_level)\n            # Adjust nesting level for nested parentheses\n            nesting_level += 1\n            #", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    parens = []\n    cur = paren_string\n    while cur and cur[-1] == ')':\n        cur = cur[:-1]\n        level += 1\n    if cur and cur[-1]!= ')':\n        raise ValueError('Wrong end of string')\n    return [int(c) for c in re.split(r'([(){}])', cur, flags=re.IGNORECASE)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens_groups = []\n    parens_groups_count = 0\n    for paren_string_part in paren_string.split(' '):\n        parens_groups_count += 1\n        if paren_groups_count == 2:\n            parens_groups.append(1)\n            parens_groups_count = 0\n        elif paren_groups_count == 3:\n            parens_groups.append(2)\n            parens_groups_count = 0\n    return parens_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split(' ')\n    current_depth = 0\n    for group in paren_groups:\n        current_depth += int(group)\n        if current_depth > 1:\n            return [current_depth]\n        if group == '()':\n            return [current_depth - 1]\n        if group == ')':\n            return [current_depth]\n\n    # Just bail\n    return [-1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return parse_unnested_parens(paren_string, 3)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n\n    # nesting starts from 1\n    paren_groups[1:] = []\n\n    # iterate through all the groups and output the groups\n    for group in paren_groups:\n        for paren in group:\n            paren_groups.append(len(paren))\n\n            if paren in ('(', ')'):\n                paren_groups.append(paren_groups.pop(0))\n\n        if paren in ('(', ')'):\n            paren_groups.append(len(paren))\n\n            if paren == '(':\n                paren_groups.append(len(paren_groups.pop(0)))\n            elif paren == ')':\n                paren_groups.append(len(paren_groups.pop(0)))\n\n            if len(paren_groups) == 0:\n                raise Exception('Error in parsing nested parentheses.')\n\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    first_part = paren_string[:1]\n\n    for part in first_part:\n        result.append(int(part))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    for paren in paren_string.split(' '):\n        if paren == '':\n            continue\n        if paren[0] == '{':\n            nesting += 1\n        elif paren[0] == '}':\n            nesting -= 1\n            if nesting <= 0:\n                break\n        elif paren[0] == '(':\n            nesting += 1\n        elif paren[0] == ')':\n            nesting -= 1\n            if nesting <= 0:\n                break\n        else:\n            raise ValueError('Invalid parenthesis token: {}'.format(paren))\n\n    return [int(n) for n in nesting if n > 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split(' '):\n        if group[0] == '(':\n            result.append(group[1] + 1)\n        elif group[0] == ')':\n            result.append(group[1] - 1)\n        elif group[0] == '(':\n            result.append(group[1] - 2)\n        elif group[0] == ')':\n            result.append(group[1] + 2)\n        else:\n            raise ValueError('Invalid nesting group')\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[int] = []\n    while paren_string:\n        if paren_string[0] == '(':\n            groups.append(0)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1] + 1)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1] + groups[1] + 1)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1] + 1)\n        elif paren_string[0] == '(':\n            groups.append(groups[-1] + 1)\n        elif paren_string[0] == ')':\n            groups.append(0)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1])\n        elif paren_string[0] == '(':\n            groups.append(groups[-1])\n        elif paren_string[0] == ')':\n            groups.append(0)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1])\n        elif paren_string[0] == '(':\n            groups.append(groups[-1])\n        elif paren_string[0] == ')':\n            groups.append(0)\n        elif paren_string[0] == ')':\n            groups.append(groups[-1])\n        elif paren_string[0] == '(':\n            groups.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    paren_group = 0\n    while paren_group < len(paren_string):\n        paren = paren_string.find('(', paren_group)\n        if paren == -1:\n            break\n        paren_group += 1\n        if paren_group == len(paren_string):\n            paren_group = 0\n            continue\n        paren_group += 1\n        if paren_group == len(paren_string):\n            break\n        result.append(paren_group)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group = 0\n    num_groups = len(paren_string)\n    if num_groups == 1:\n        yield group\n        return\n    level = 1\n    num_levels = 0\n    for paren_string_group in paren_string:\n        # If we find two consecutive (...), we have two levels of nesting.\n        if paren_string_group[0] == (':':\n            num_levels += 1\n            if num_levels == 2:\n                yield level\n                return\n        group += 1\n        level += 1\n\n    # If we find any additional parenthesis, we have at least three levels of nesting.\n    if num_levels!= 3:\n        raise ValueError('There are {!r} levels of nesting in {!r} parentheses.'.format(num_levels, paren_string))\n    return parse_nested_parens(paren_string[group:])\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    for paren_group in paren_string.split(' '):\n        if paren_group == \"(\":\n            nesting += 1\n        elif paren_group == \")\":\n            nesting -= 1\n        elif paren_group == \"((),\":\n            nesting -= 2\n        elif paren_group == \"((),,\":\n            nesting -= 3\n        elif paren_group == \"()(),\":\n            nesting -= 4\n        elif paren_group == \"()(),,\":\n            nesting -= 5\n        elif paren_group == \"()(),,(),\":\n            nesting -= 6\n        elif paren_group == \"()(),(),(),(),\":\n            nesting -= 7\n        elif paren_group == \"()(),(),(),(),(),(),\":\n            nesting -= 8\n        elif paren_group == \"()(),(),(),(),(),(),(),(),(),(),(),(),\":\n            nesting -= 9\n        elif paren_group == \"()(),(),(),(),(),(),(),(),(),(),(),(),(),\":\n            nesting -= 10\n        elif paren_group == \"()(),(),(),(),(),(),(),(),(),(),(),(),(),\":\n            nesting -= 11\n        elif paren_group == \"()(),(),", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    current_level: int = 0\n    current_group: int = 1\n    group_size: int = 0\n    last_group: int = None\n    last_level: int = None\n    for i, paren in enumerate(paren_string):\n        if paren == '(':\n            group_size += 1\n        elif paren == ')':\n            group_size -= 1\n            if group_size == 0:\n                last_group = current_group\n                last_level = current_level\n                current_group = 1\n        else:\n            if current_level < last_level:\n                nested_parens.append(current_level)\n                current_level += 1\n            elif current_level == last_level:\n                nested_parens.append(last_group)\n                current_group = current_group - 1\n            else:\n                current_level = current_level - 1\n                nested_parens.append(last_group)\n                last_group = current_group\n            current_group = current_group - 1\n            last_group = None\n\n        if current_group < last_group:\n            nested_parens.append(current_group)\n            current_group += 1\n        elif current_group == last_group:\n            nested_parens.append(last_level)\n            current_level = current_level - 1\n        else:\n            current_group = current", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n    for nested_paren in paren_string.split(' '):\n        for nested_paren_group in nested_paren.split(' '):\n            nested_levels.append(int(nested_paren_group))\n\n    return nested_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n    group_names = []\n    for index, value in enumerate(paren_string):\n        if value == '(':\n            nested_levels.append(index + 1)\n            group_names.append('(')\n        elif value == ')':\n            nested_levels.append(index - 1)\n            group_names.append(')')\n        elif value == ',':\n            nested_levels.append(index)\n            group_names.append(',')\n        else:\n            nested_levels.append(index + 1)\n            group_names.append(value)\n    nested_levels.sort()\n    nested_levels_list = [int(x) for x in nested_levels]\n    nested_levels_list.extend(group_names)\n    return nested_levels_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups: List[str] = []\n    levels = 0\n\n    for paren in paren_string.split(' '):\n        if paren.startswith('())'):\n            levels += 1\n        elif paren.startswith('(())'):\n            levels += 2\n        elif paren.startswith('(())'):\n            levels += 1\n        elif paren.startswith('(()())'):\n            levels += 1\n        elif paren.startswith('(()())'):\n            levels += 1\n        elif paren.startswith('()'):\n            groups.append(paren)\n            levels += 1\n        elif paren.startswith('())'):\n            groups.append('()')\n            levels += 2\n        elif paren.startswith('())'):\n            groups.append('())')\n            levels += 1\n        elif paren.startswith('())'):\n            groups.append('())')\n            levels += 1\n        elif paren.startswith('())'):\n            groups.append('())')\n            levels += 1\n        elif paren.startswith('()'):\n            groups.append('())')\n            levels +=", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # We don't want to separate spaces with commas\n    paren_string = paren_string.strip().replace(' ', ',')\n\n    return paren_string.split()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parentheses = []\n    current_depth = 0\n    groups = paren_string.split(',')[1:]\n    for g in groups:\n        if current_depth == 0:\n            parentheses.append(current_depth)\n        current_depth += 1\n        if current_depth > 3:\n            return parentheses\n\n    if current_depth == 0:\n        return parentheses\n\n    for i in range(current_depth - 1):\n        current_depth -= 1\n        if current_depth == 0:\n            return parentheses\n\n    for i in range(0, current_depth):\n        parentheses.append(i)\n\n    return parentheses", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_list = []\n    for group in paren_string.split():\n        group_list.append(int(group.strip()))\n    return group_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    while level < len(paren_string):\n        level = level + 1\n        if paren_string[level] == '(':\n            level = level + 1\n        if paren_string[level] == ')':\n            level = level - 1\n        if paren_string[level] == ',':\n            level = level + 1\n            if level > len(paren_string) - 1:\n                return [level - 1]\n            level = level - 1\n        elif paren_string[level] == ':':\n            level = level + 1\n            if level > len(paren_string) - 1:\n                return [level - 1]\n            level = level - 1\n\n    return level\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for element in paren_string.split(' '):\n        if element:\n            nested_parens.append(int(element))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # paren_string is delimited by spaces. Each group is delimited by a space.\n    result = []\n    for paren in paren_string.split(' '):\n        if paren.startswith('('):\n            result.append(1)\n        elif paren.startswith(')'):\n            result.append(0)\n        elif paren.startswith(','):\n            result.append(0)\n        else:\n            result.append(-1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    level = 1\n    for paren_group in paren_string.split():\n        groups.append(level)\n        level += 1\n\n    for group in groups:\n        for paren_group in group:\n            if paren_group == '()':\n                groups.pop(groups.index(level - 1))\n            if paren_group == '(':\n                groups.pop(groups.index(level - 1))\n            if paren_group == ')':\n                groups.pop(groups.index(level - 1))\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = []\n    for group in paren_string.split(' '):\n        depth = 1\n        for pair in group.split(' '):\n            if pair:\n                depth += 1\n            else:\n                break\n        nested.append(depth)\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n\n    # Count level of nesting of parentheses in each group\n    group_count: int = 0\n    for paren in paren_string:\n        # Get depth of all parentheses in that group\n        for paren_group in paren.split(' '):\n            if paren_group in nested_parens:\n                nested_parens.append(group_count)\n                group_count += 1\n            else:\n                nested_parens.append(group_count)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string == '(':\n        return []\n    elif paren_string == ')':\n        return []\n    else:\n        return parse_level(paren_string, 1)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # A list of nesting levels in parentheses.\n    nested_levels = []\n\n    # For each level of nesting,\n    for level in range(0, len(paren_string)):\n        # If the current level is 0, exit.\n        if level == 0:\n            break\n\n        # A list of characters after the current level of nesting,\n        current_char = paren_string[level]\n\n        # A list of characters before the next level of nesting.\n        previous_char = previous_char.rstrip()\n\n        # If the current level of nesting is less than the previous level of nesting,\n        if current_char in previous_char:\n            # Append the current level of nesting to the previous level of nesting.\n            nested_levels.append(level)\n        else:\n            # Append the current level of nesting to the next level of nesting.\n            nested_levels.append(level + 1)\n\n    return nested_levels\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for group in paren_string.split(' '):\n        try:\n            output.append(int(group))\n        except ValueError:\n            output.append(0)\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # we need to strip the leading and trailing spaces\n    paren_string = paren_string.strip()\n\n    # we can use a regex to get all of the groups\n    groups = re.findall(r\"(?<!\\n)^([^(])\", paren_string)\n    # if we have any groups, output them\n    if len(groups) > 0:\n        return groups\n\n    # otherwise, we just need to use a dict to get the deepest level\n    groups = {\"(\": [], \")\": [], \"[\": []}\n\n    # iterate over each group in turn\n    for group in groups:\n        if len(group) == 0:\n            continue\n\n        # add any new groups to the previous dict\n        groups[\"(\"].append(group[0])\n        groups[\")\"].append(group[1])\n        groups[\"[\"].append(group[2])\n\n        # output the deepest level\n        groups[\"(\"].pop(0)\n        groups[\")\"].pop(0)\n        groups[\"[\"].pop(0)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level, parens = 0, []\n    current_paren = ''\n\n    while current_paren!= '':\n        level += 1\n        for paren in parse_nested_parens(current_paren):\n            if parens[-1] == 0:\n                parens.pop(-1)\n            else:\n                parens.append(0)\n            if level == 1:\n                break\n        current_paren = ''\n\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = []\n    parens = []\n    for paren in paren_string.split(' '):\n        if paren == '':\n            parens.append(0)\n        elif paren[0] == '(':\n            nested.append(1)\n        elif paren[0] == ')':\n            nested.append(1)\n        elif paren[0] == '(':\n            parens.append(1)\n        elif paren[0] == ')':\n            parens.append(0)\n        elif paren[0] == '(':\n            parens.append(1)\n        elif paren[0] == ')':\n            parens.append(0)\n        else:\n            parens.append(0)\n    return nested, parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels = [int(paren_level) for paren_level in paren_string.split()]\n    paren_levels.sort()\n    deepest_level = paren_levels.pop()\n    return [deepest_level, paren_levels[deepest_level - 1], paren_levels[deepest_level - 2]]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    input = paren_string.strip().split()\n    output = []\n    for i, group in enumerate(input):\n        if group:\n            if group[0] == '(':\n                output.append(i)\n                continue\n            elif group[0] == ')':\n                output.append(output[-1] + 1)\n            else:\n                output.append(0)\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parts = []\n    for paren in paren_string.split():\n        if not paren.startswith('('):\n            continue\n        level = int(paren.split()[1])\n        if level > 1:\n            nested_parts.append(level)\n    return nested_parts", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens_list = []\n    max_level = 0\n    for paren_group in paren_string.split(' '):\n        if paren_group.startswith('('):\n            parens_list.append(paren_group[2:])\n            max_level += 1\n        elif paren_group.startswith(')'):\n            parens_list.append(paren_group[3:])\n            max_level += 1\n    return parens_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[int] = []\n    for paren in paren_string.split('('):\n        if not paren.startswith('('):\n            continue\n        if paren.endswith(')'):\n            groups[-1 - len(paren)] += 1\n        else:\n            groups[-1] += 1\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for i, paren in enumerate(paren_string.split(' ')):\n        if paren.isdigit():\n            if paren == '(':\n                parens.append(i)\n            elif paren == ')':\n                parens.append(len(parens) - 1)\n            elif paren == ',':\n                return parens\n    return None", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels = {}\n    for paren_group in paren_string.split(' '):\n        paren_levels[paren_group.strip()] = 1\n\n    return paren_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def iter_groups_of_depth(group: str) -> List[int]:\n        \"\"\" Returns all the nested parentheses from the group.\n        The function iterates over each grouping for each parentheses.\n        Returns the deepest nested parentheses level found.\n        \"\"\"\n        for i, group in enumerate(group):\n            if group.startswith('('):\n                yield i\n                for group_name, group_level in iter_groups_of_depth(group):\n                    yield group_name, group_level\n            elif group.startswith('('):\n                yield i\n                for group_name, group_level in iter_groups_of_depth(group):\n                    yield group_name, group_level\n                yield '('\n            elif group.startswith('('):\n                yield i\n                for group_name, group_level in iter_groups_of_depth(group):\n                    yield group_name, group_level\n                yield '())'\n            else:\n                yield i\n                for group_name, group_level in iter_groups_of_depth(group):\n                    yield group_name, group_level\n                yield '()'\n\n    return [i for i, paren_group in enumerate(paren_string) if iter_groups_of_depth(paren_group)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    while True:\n        group = paren_string.split('(')\n        if len(group) < 2:\n            break\n        group = group[1:]\n        if level == 0:\n            level = level + 1\n            if len(group) == 1:\n                break\n        else:\n            if len(group) == 2:\n                level = level - 1\n            else:\n                raise ValueError('Invalid group length: {}'.format(len(group)))\n\n    return level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Convert paren_string to list of string\n    paren_list = list(paren_string)\n\n    # Determine deepest level of nesting of parentheses\n    depth = 0\n    for paren in paren_list:\n        # Check if the current paren is a sub-paren\n        if paren.startswith('(') and paren.endswith(')'):\n            depth += 1\n        # Check if the current paren is a child of the previous paren\n        if paren == paren_list[depth - 1]:\n            # If the current paren is the parent of the previous paren\n            if depth == 0:\n                return depth - 1\n            else:\n                # If the current paren is a parent of the previous paren but not the next paren\n                if depth > 2:\n                    return depth - 1\n                # If the current paren is not the next paren but is the next child of the previous paren\n                if depth > 2:\n                    return depth - 2\n                # If the current paren is not the next child of the previous paren but is the next child of the parent\n                if depth > 3:\n                    return depth - 3\n                # If the current paren is not the parent of the previous paren or", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    if paren_string == '':\n        return []\n    paren_string = paren_string.strip()\n\n    # Process parens in order of appearance\n    nesting = 1\n    paren_group = ''\n    for paren in paren_string.split():\n        paren_groups = paren.split()\n        if paren_groups[-1] == '(':\n            paren_group = paren_groups[:-1]\n        else:\n            paren_group += paren_groups[-1]\n            nesting += 1\n\n    # Process parens grouped by \"()\"\n    paren_group = paren_group.lower()\n    if paren_group.endswith('())'):\n        paren_group = paren_group[:-1]\n    if paren_group.endswith('())()'):\n        paren_group = paren_group[:-1]\n    if paren_group.endswith('()'):\n        paren_group = paren_group[:-1]\n    if paren_group.endswith('())()'):\n        paren_group = paren_group[:-1]\n    if paren_group.endswith('())()'):\n        paren_group = paren_group[:-1]\n    if paren_group.endswith('())()'", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    paren_levels = []\n    for paren_group in paren_groups:\n        paren_group = paren_group.strip()\n        if len(paren_group) > 1 and paren_group[0] == '{':\n            paren_levels.append(len(paren_group[1:]) - 1)\n        elif len(paren_group) > 1 and paren_group[0] == '}':\n            paren_levels.append(0)\n    return paren_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    grouping_levels = []\n    for paren_item in paren_string.split(' '):\n        if paren_item.isdigit():\n            grouping_levels.append(paren_item)\n        elif paren_item.startswith('('):\n            grouping_levels.append(1)\n        elif paren_item.startswith(')'):\n            grouping_levels.append(2)\n        elif paren_item.startswith('('):\n            grouping_levels.append(0)\n        else:\n            grouping_levels.append(-1)\n    return grouping_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')\n    nested_level = 0\n\n    for group in groups:\n        group = group.strip()\n        if group == '':\n            continue\n        nested_level += 1\n        if nested_level > 2:\n            break\n\n    return [int(group) for group in groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n\n    for group in paren_string:\n        groups.append(group.count(' ') - 1)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for paren in paren_string.split(')'):\n        parens.extend(list(reversed(paren)))\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = paren_string.split(\" \")\n    return [int(i) for i in parens if i]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    while level < len(paren_string):\n        if paren_string[level] in ('(', ')'):\n            level += 1\n            continue\n        if paren_string[level] == '(':\n            level += 1\n            continue\n        if paren_string[level] == ')':\n            level += 1\n            continue\n        if paren_string[level] not in ('(', ')'):\n            raise ValueError('Invalid parenthesis format, expected \"(\" or \")\", got \"%s\"' % paren_string[level])\n        if paren_string[level] == '(':\n            level += 1\n            continue\n        if paren_string[level] == ')':\n            level += 1\n            continue\n        if paren_string[level] == '(':\n            level += 1\n            continue\n        if paren_string[level] == ')':\n            level += 1\n            continue\n        if paren_string[level] == '(':\n            level += 1\n            continue\n        if paren_string[level] == ')':\n            level += 1\n            continue\n        raise ValueError('Invalid parenthesis format, expected \"(\" or \")\", got \"%s\"' %", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    list_of_levels = []\n    for level in paren_string.split(' '):\n        list_of_levels.append(int(level))\n    return list_of_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Get the string representation of the nested parens\n    nested_string = paren_string.strip()\n    # Get the deepest level of nesting\n    max_level = 0\n    for ind, paren_group in enumerate(nested_string.split(' ')):\n        if len(paren_group) > max_level:\n            max_level = len(paren_group)\n    return [max_level]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for paren_string_group in paren_string.split():\n        # If paren_string_group is a single group of parenthesis, return the deepest level of nesting\n        if paren_string_group[0] == '(':\n            return []\n        elif paren_string_group[0] == ')':\n            return [paren_string_group[1].index('()')]\n        elif paren_string_group[0] == '(' and paren_string_group[-1] == ')':\n            return [paren_string_group[-1].index('()')]\n        elif paren_string_group[0] == '(' and paren_string_group[-1] == ')':\n            return [paren_string_group[-1].index('()')]\n        elif paren_string_group[0] == '(' and paren_string_group[-1] == ')':\n            return [paren_string_group[-1].index('()')]\n        elif paren_string_group[0] == '(' and paren_string_group[-1] == ')':\n            return [paren_string_group[-1].index('()')]\n        elif paren_string_group[0] == '(' and paren_string_group[-1] == ')':\n            return [paren_string_group[-1].", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string.split(','):\n        if paren.isdigit():\n            num_parens = int(paren)\n        else:\n            num_parens = len(paren)\n        result.append(num_parens)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens_list = []\n    for paren_str in paren_string.split(' '):\n        parens_list.append(int(paren_str.strip()))\n\n    return parens_list\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    groups_list = []\n    groups = []\n\n    while depth < len(paren_string):\n        group = paren_string[depth].strip()\n        groups_list.append(group)\n        groups.append(group.split(' ')[0])\n        depth += 1\n\n    return [int(i) for i in groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group = 0\n    for char in paren_string:\n        if char == ')':\n            group += 1\n        elif char == '()':\n            group += 2\n        else:\n            if group == 2:\n                return group\n            elif group == 1:\n                return group, 1\n            elif group == 0:\n                return group, 2\n            else:\n                return group, 2, 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    last_level = 0\n\n    for _, group in enumerate(paren_string.split(\" \")):\n        # skip empty groups\n        if len(group) == 0:\n            continue\n        # skip duplicate groups\n        if group[0] == group[-1] and group[1] == group[-1]:\n            continue\n\n        # skip empty groups\n        if len(group) == 1:\n            continue\n\n        # skip duplicate groups\n        if group[0] == group[-1] and group[1] == group[-1]:\n            continue\n\n        # first level\n        if group[-1] == \"(\":\n            nested_parens.append(last_level)\n            last_level = 1\n\n        # second level\n        elif group[-1] == \")\":\n            nested_parens.append(last_level + 1)\n            last_level += 1\n\n        # third level\n        elif group[-1] == \")\":\n            nested_parens.append(last_level + 1 + last_level)\n            last_level += 1\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split('(')[:-1]\n    groups.sort()\n    top_level_groups = list(groups)\n    if len(groups) == 2:\n        return top_level_groups\n    if len(groups) == 3:\n        return [top_level_groups[i:i + 2] for i in range(2, len(top_level_groups), 2)]\n    return top_level_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.strip() == '':\n        return []\n\n    # Transpose the string.\n    paren_strings = paren_string.split(' ')\n    paren_strings = [int(s) for s in paren_strings]\n    paren_strings = [int(s) for s in paren_strings if s > 1]\n\n    # Get the deepest level of nesting.\n    for paren_string in paren_strings:\n        if paren_string == 0:\n            return []\n        elif paren_string == 1:\n            return paren_strings[1:]\n        elif paren_string == 2:\n            return paren_strings[2:]\n        elif paren_string == 3:\n            return paren_strings[3:]\n\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    tree = []\n    for paren_string_part in paren_string:\n        paren_string_part = paren_string_part.lower()\n        if paren_string_part in ('(', ')', ')'):\n            tree.append(0)\n            continue\n        if paren_string_part in (')', ']'):\n            tree.append(1)\n        elif paren_string_part in ('[', ']'):\n            tree.append(2)\n        elif paren_string_part.isdigit():\n            tree.append(3)\n        else:\n            raise ValueError('Expected one of (), () or [ ]. Received \"%s\"' % paren_string_part)\n    return tree", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n\n    for paren_string_part in paren_string.split(\" \"):\n        if paren_string_part[0] == \"(\":\n            groups.append(0)\n        elif paren_string_part[0] == \")\":\n            groups.append(1)\n\n        elif paren_string_part[0] == \"(\" or paren_string_part[0] == \")\":\n            groups.append(2)\n\n        elif paren_string_part[0] == \"(\" or paren_string_part[0] == \")\" or paren_string_part[0] == \")\":\n            groups.append(3)\n\n        groups.append(len(paren_string_part))\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for paren_group in paren_string.split(' '):\n        parsed_paren = int(paren_group.split(')')[0])\n        parsed_level = int(paren_group.split(')')[1]\n        return parsed_level, parsed_paren", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    groups = []\n    for i, paren in enumerate(paren_string):\n        if paren == '(':\n            groups.append(depth)\n        elif paren == ')':\n            depth += 1\n        else:\n            groups.append(depth)\n        depth = depth + 1\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(x) for x in re.split(r'(?=(?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((?!((", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    current_item = None\n    current_item_complete = False\n    parse_step = 1\n    nested_parens = []\n    current_paren = None\n    while parse_step < len(paren_string):\n        current_paren = current_item.paren\n        current_item = current_item.parent_item\n        if current_item == current_item_complete:\n            level += 1\n            if current_item.level == 1:\n                nested_parens.append(level)\n            else:\n                break\n        if current_item.level == level:\n            if current_item.paren == current_paren.paren == current_item.parent_item.paren and current_item.parent_item.parent_item == current_item_complete:\n                level += 1\n                nested_parens.append(level)\n            else:\n                break\n        parse_step += 1\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    depth = 0\n    level = 1\n    for line in paren_string.split('\\n'):\n        if not line:\n            continue\n        if level == 0:\n            parens.append(depth)\n            depth += 1\n            if depth == 1:\n                break\n        level += 1\n        if level >= 3:\n            break\n        parens.append(level)\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    global _PAREN_DEPTH\n    _PAREN_DEPTH = 0\n    if paren_string == '':\n        return []\n\n    parse_index = 0\n    prev_index = 0\n    parens = []\n    while paren_string[parse_index]:\n        index = paren_string.find(')', parse_index)\n        if index < 0:\n            break\n        parens.append(index + 1)\n        paren_string = paren_string[:index]\n        parse_index = index + 1\n    if parens[0] < 0:\n        return []\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    group_indexes = []\n    nesting_levels = 0\n    for paren_string_parts in re.split(r\"(?i)\", paren_string):\n        group_parts = paren_string_parts.split(\" \")\n        if group_parts[0] == '()':\n            group_parts.pop(0)\n        elif group_parts[0] == '()':\n            group_parts.pop(0)\n        elif group_parts[0] == '()':\n            group_parts.pop(0)\n        groups.append(group_parts)\n        group_indexes.append(nesting_levels)\n        nesting_levels += 1\n    return group_indexes, groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    stack = []\n    while depth < len(paren_string):\n        if stack[-1] == 0:\n            depth += 1\n            stack.append(0)\n        else:\n            stack.append(depth)\n            stack.append(stack[-1])\n        if len(stack) > 2:\n            break\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    tree = []\n    for part in paren_string.split(' '):\n        # This is a nesting of multiple parentheses with spaces\n        tree.append(int(part))\n        if len(tree) >= 3:\n            # This is a nested parenthesis with spaces and it is followed by a space\n            tree = tree[:-2]\n    return tree", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # This is a little trick to convert the paren string into a list of ints.\n    # Because there are multiple groups of parentheses, we convert each group to a list.\n    return [int(i) for i in re.findall(r'(\\s*)(\\[.*?\\]', paren_string)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    paren_group = paren_string.split(' ')[0].strip()\n    paren_level = len(paren_group)\n    paren_pos = 1\n    for paren in paren_group:\n        paren_string = paren_string +'' + paren\n        paren_level += 1\n        if paren_pos < paren_level:\n            paren_pos = paren_level\n        if paren_pos == paren_level:\n            return [paren_pos]\n        paren_pos += 1\n    return [paren_pos]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren_group in paren_string.split(' '):\n        paren_group = paren_group.strip()\n        if paren_group is not '':\n            paren_groups.append(paren_group)\n    deepest_level = 0\n    for paren_group in paren_groups:\n        level = paren_group.count(')')\n        if level == 2:\n            deepest_level += 1\n        elif level == 3:\n            deepest_level += 2\n        else:\n            print(\"Parens group {} is not a valid level of nesting.\".format(paren_group))\n            break\n    return deepest_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = 1\n    nested = 0\n    for paren in paren_string.split():\n        nested = nested + 1\n        if nested == 1:\n            levels = levels + 1\n        else:\n            levels = levels - 1\n            if nested == 1:\n                break\n            levels = levels - 1\n\n    return [level for level in levels]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    cur_level = 0\n    i = 0\n    for c in paren_string:\n        if i == 0:\n            cur_level += 1\n        elif cur_level == 2:\n            cur_level += 2\n        elif cur_level == 3:\n            cur_level += 3\n        elif cur_level > 3:\n            break\n        i += 1\n    return [i for i in cur_level]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nesting_levels = []\n    nested_parens = []\n    for paren in paren_string.split(' '):\n        if len(paren) > 1:\n            if paren[0] == '(':\n                nesting_levels.append(len(paren[1:]))\n            elif paren[0] == ')':\n                nested_parens.append(0)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    depth = 0\n    for group in groups:\n        depth += 1\n        if depth > 2:\n            break\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_groups = []\n    for n in paren_string:\n        if n[0] == '(':\n            nested_paren_groups.append(0)\n        elif n[0] == '([]':\n            nested_paren_groups.append(1)\n        elif n[0] == '[]':\n            nested_paren_groups.append(2)\n        elif n[0] == ')':\n            nested_paren_groups.append(3)\n        elif nested_paren_groups[0] > nested_paren_groups[1]:\n            nested_paren_groups = nested_paren_groups[1], nested_paren_groups[0]\n        else:\n            nested_paren_groups = nested_paren_groups[0], nested_paren_groups[1], nested_paren_groups[2]\n    return nested_paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for char in paren_string:\n        # groups[0] is the group with the number of groups\n        # groups[1] is the group with the deepest level of nesting\n        # groups[2] is the group with the deepest level of nesting without parentheses\n        groups.append((char.isdigit() and char or char.isalnum(), int(char)))\n        # groups[1] is the group with the deepest level of nesting without parentheses\n        # groups[2] is the group with the deepest level of nesting\n        # groups[0] is the group with the deepest level of nesting without parentheses\n        # groups[3] is the group with the deepest level of nesting without parentheses\n        # groups[3] is the group with the deepest level of nesting without parentheses\n        # groups[4] is the group with the deepest level of nesting without parentheses\n        groups.append((char, 0))\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    groups = []\n    for group in paren_string.split(' '):\n        groups.append(group.split())\n        groups[-1].append(0)\n        parens.append(len(groups))\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    group_number = 0\n    result_list = []\n    for paren_group in paren_string.split(' '):\n        result_list.append(group_number)\n        if len(paren_group) > 1:\n            group_number += 1\n        else:\n            result_list.append(-1)\n    if len(paren_string) > 1 and paren_string[0] == '{':\n        result_list.append(group_number)\n    elif len(paren_string) > 1 and paren_string[0] == '(':\n        result_list.append(group_number - 1)\n    elif len(paren_string) > 1 and paren_string[0] == ')':\n        result_list.append(group_number - 1 - 1)\n    elif len(paren_string) > 1 and paren_string[0] == '[':\n        result_list.append(group_number - 1 - 2)\n        group_number += 1\n    elif len(paren_string) > 1 and paren_string[0] == ']':\n        result_list.append(group_number - 1 - 2 - 1)\n    elif len(paren_string) > 1 and paren_string[0] == ')':\n        result_list.append(group_number - 1 - 1)\n    elif len(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    if paren_string is not None:\n        parens = []\n        for item in paren_string.split('('):\n            if item in ('()', '())'):\n                parens.append(depth + 1)\n            elif item.isdigit():\n                parens.append(depth)\n            else:\n                depth += 1\n                if depth > 2:\n                    return [depth - 2]\n                else:\n                    return [depth]\n    return [depth]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    tokens = tokenize(paren_string)\n    token_depth = 0\n    for token in tokens:\n        if token.is_punctuator:\n            token_depth += 1\n        elif token.is_number:\n            token_depth += 1\n        elif token.is_string:\n            token_depth += 1\n        elif token.is_punctuator:\n            token_depth += 1\n        elif token.is_number:\n            token_depth += 1\n        elif token.is_string:\n            token_depth += 1\n        elif token.is_punctuator:\n            token_depth += 1\n        elif token.is_number:\n            token_depth += 1\n        elif token.is_string:\n            token_depth += 1\n        elif token.is_punctuator:\n            token_depth += 1\n        else:\n            raise ValueError('bad token')\n        if token_depth > 1:\n            raise ValueError('bad token')\n\n    return token_depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_string = paren_string.strip()\n    num_levels = 0\n    for level in paren_string:\n        if level.isdigit():\n            num_levels += 1\n            if level == '0':\n                return num_levels\n            elif level == '1':\n                return num_levels + 1\n            elif level == '2':\n                return num_levels + 1 + 1\n        elif level == paren_string[len(paren_string) - 1]:\n            return num_levels + 1\n        elif level == paren_string[len(paren_string) - 2]:\n            return num_levels + 1 + 1\n    return num_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    if paren_string[level] == '(':\n        level += 1\n    if paren_string[level] == ')':\n        level -= 1\n    return [int(p) for p in paren_string[level:level]]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    for paren_group in paren_string.split('('):\n        nesting += 1\n        paren_group = paren_group.strip()\n        if paren_group:\n            if paren_group in ('()', ')'):\n                nesting += 1\n            else:\n                yield nesting\n    if nesting > 1:\n        yield nesting - 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split(' '):\n        if group is not None:\n            result.append(group.pop(0) - 1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Parse through the group separated by spaces to obtain a list of integers.\n    grouped_parens_list = []\n    for space_char in paren_string.split(' '):\n        if space_char == '(':\n            grouped_parens_list.append(1)\n        elif space_char == ')':\n            grouped_parens_list.append(2)\n        elif space_char == ',':\n            grouped_parens_list.append(3)\n        else:\n            raise ValueError('Invalid character in group')\n    return grouped_parens_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    pos = 0\n    while pos < len(paren_string):\n        if paren_string[pos] == '(':\n            pos += 1\n            if pos == len(paren_string):\n                pos = 0\n        elif paren_string[pos] == ')':\n            pos -= 1\n            if pos == 0:\n                pos = len(paren_string)\n            else:\n                pos += 1\n\n    return [int(v) for v in paren_string[pos: pos + 1].split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    level = 0\n    for s in paren_string:\n        if s.startswith('('):\n            level += 1\n            nested_parens.append(level)\n            nested_parens.extend(parse_nested_parens(s[1:]))\n        elif s.startswith('('):\n            level += 1\n            nested_parens.append(level)\n            nested_parens.extend(parse_nested_parens(s[1:]))\n        else:\n            nested_parens.append(level)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_names = [(j, i) for j, i in enumerate(paren_string)]\n\n    nesting = 0\n    for group_name in group_names:\n        nesting += 1\n        if nesting > 1:\n            group_names = group_names[:-1]\n\n        for group in group_names:\n            if group_name in group.split():\n                for nested in parse_nested_parens(group_name):\n                    nesting += nested\n                    break\n\n    return group_names", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_count = 0\n    parent_count = 0\n    for paren in paren_string:\n        if paren == '(':\n            parent_count += 1\n        elif paren == ')':\n            group_count += 1\n            parent_count -= 1\n        else:\n            if group_count > parent_count:\n                group_count = parent_count\n            else:\n                parent_count += 1\n\n    return [parent_count, group_count]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # The input should be a list of strings that are nesting levels of parentheses\n    nested_parens = []\n    for paren_string_group in paren_string:\n        # Look for the group delimiter that separates each group of nested parentheses\n        # Also, a group delimiter with a space should be found.\n        # Group delimiter:\n        #     * ( and ( for nested parentheses )\n        #     * ( and ( for nested parentheses ) *\n        #     * ( and ( for nested parentheses )\n        #     * ( and ( for nested parentheses ) * *\n        #     * ( and ( for nested parentheses ) * * *\n        # Group delimiter: ( and ( for nested parentheses ) *\n        # Group delimiter: ( and ( for nested parentheses ) * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter: ( and ( for nested parentheses ) * * * *\n        # Group delimiter:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n    for paren_string_part in paren_string.split():\n        paren_string_part = paren_string_part.strip()\n\n        if paren_string_part.startswith('('):\n            nested_parens.append(0)\n        elif paren_string_part.startswith(')'):\n            nested_parens.append(-1)\n        elif paren_string_part.startswith('('):\n            nested_parens.append(1)\n        elif paren_string_part.startswith(')'):\n            nested_parens.append(2)\n        elif paren_string_part.startswith('('):\n            nested_parens.append(3)\n        elif paren_string_part.startswith(')'):\n            nested_parens.append(-1)\n        else:\n            print('WARNING: Invalid Paren String:'+ paren_string_part)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren in paren_string:\n        paren_groups.append(0)\n    for paren in paren_groups:\n        if paren > 1:\n            paren_groups.pop()\n    if paren_groups is None:\n        return []\n    return paren_groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')[1:]\n    nesting = 0\n    for group in groups:\n        nesting += len(group) - 1\n        if nesting > 2:\n            return [group] + groups[-nesting:]\n        else:\n            return [group] + groups[:nesting]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    while True:\n        parens.append(0)\n        if paren_string.count(')') > 0:\n            # It's not going to be the first paren\n            break\n        if paren_string.count('(') > 0:\n            # It's going to be the first paren, so we need to check if it's a match\n            current_depth = len(parens)\n            if paren_string.count('()') == current_depth:\n                # It's going to be the first paren, so we need to check if it's a match\n                current_depth += 1\n            if current_depth == 2:\n                # It's the second level of nesting\n                parens.append(2)\n            elif current_depth == 3:\n                # It's the third level of nesting\n                parens.append(3)\n        else:\n            # It's not a match\n            break\n\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    paren_groups = [x for x in paren_groups if x not in ['(', ')']]\n    paren_groups.sort()\n    paren_groups.append(0)\n    return paren_groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    with open(nested_paren_file) as paren_file:\n        lines = paren_file.readlines()\n\n    groups = []\n    for line in lines:\n        groups.append(line.rstrip().split()[1:])\n\n    groups.sort(key=lambda x: -x[1])\n\n    if len(groups) == 2:\n        return groups[0], groups[1]\n    elif len(groups) == 3:\n        return groups[0], groups[1], groups[2]\n    else:\n        raise ValueError('Invalid input.')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace(' ', '')\n\n    return list(re.findall(r'\\[(?:[^\\]\\\\]*\\\\])', paren_string))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            result.append(i)\n        elif paren_string[i] == ')':\n            result.append(result[-1] + 1)\n        else:\n            result.append(i)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for paren in paren_string.split(\"(\"):\n        if paren.startswith(\"((\") and paren.endswith(\"))\"):\n            nested_parens.append(parse_nested_parens(paren.replace(\"((\", \"\").replace(\"))\", \"\")))\n        elif paren.startswith(\"(\"):\n            nested_parens.append(0)\n        else:\n            nested_parens.append(parse_nested_parens(paren.replace(\"(\", \"\").replace(\")\", \"\")))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Example: (()())()\n    # Output: [2, 3, 1]\n    # Example (()))()\n    # Output: [2, 1, 3]\n\n    paren_stack: List[int] = []\n    num_parens: int = 0\n\n    while num_parens < len(paren_string):\n        paren_level = num_parens\n\n        # Skip group zero (when there are no parens)\n        if paren_string[num_parens] == '()':\n            num_parens += 1\n\n            paren_stack.append(num_parens)\n            num_parens = 0\n        else:\n            num_parens += 1\n\n        if paren_string[num_parens] == ')':\n            paren_level = max(0, paren_level + 1)\n\n        if paren_level == 1:\n            return [num_parens]\n\n        paren_stack.append(paren_level)\n\n    # Example: ((()))()\n    # Output: [1, 3]\n    # Example ((())))\n    # Output: [1, 1, 3]\n    return paren_stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    nested_parens = []\n    for line in paren_string.splitlines():\n        if level == 1:\n            nested_parens.append(line[2:])\n        elif level == 2:\n            nested_parens.append(line[2:])\n            level = 0\n        else:\n            level += 1\n            nested_parens.append(line[2:])\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # The input string is '((()))'\n    # We need to iterate over all groups and output the deepest level of nesting of parentheses in each group.\n    nested_parens = []\n\n    for group in paren_string.split(')'):\n        if group.startswith('('):\n            nested_parens.append(0)\n        elif group.startswith('(') and group.endswith(')'):\n            nested_parens.append(-1)\n        else:\n            nested_parens.append(-1)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # split the paren string into groups\n    groups = paren_string.strip().split(' ')\n\n    # loop through each group and output the deepest level of nesting\n    for group in groups:\n        if group.endswith(')'):\n            return parse_nested_parens(group[:-len(')'])\n        elif group.endswith(')'):\n            return parse_nested_parens(group[:-len('(')])\n        else:\n            return parse_nested_parens(group)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for each_paren in paren_string.split():\n        each_paren = each_paren.strip()\n        if each_paren.startswith('('):\n            nested_parens.append(parse_paren(each_paren))\n        elif each_paren.startswith('['):\n            nested_parens.append(parse_paren(each_paren))\n        elif each_paren.startswith('([])'):\n            nested_parens.append(parse_paren(each_paren))\n        elif each_paren.startswith('([][])'):\n            nested_parens.append(parse_paren(each_paren))\n        elif each_paren.startswith('([][][])'):\n            nested_parens.append(parse_paren(each_paren))\n        elif each_paren.startswith('({})'):\n            nested_parens.append(parse_paren(each_paren))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for paren in paren_string.split(' '):\n        nesting = int(paren)\n        if nesting > 0:\n            return [paren, nesting - 1]\n        else:\n            return None", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n    for nested_paren_group in paren_string:\n        nested_levels.append(max(nested_paren_group.count('(') + 1, 0))\n    return nested_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for paren in paren_string.split('('):\n        parens.append(0)\n        for group in paren.split(','):\n            parens.append(parse_nested_parens(group))\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Let's keep it simple.\n    level = 0\n    current = ''\n    for char in paren_string:\n        if char == '(':\n            level += 1\n            if current:\n                break\n            current = ''\n        elif char == ')':\n            level -= 1\n            if current:\n                break\n            current = ''\n        elif char =='':\n            if level == 0:\n                return [level]\n            if level > 0:\n                level = level - 1\n            if level < 2:\n                level = 1\n            else:\n                level = 0\n        else:\n            current += char\n    return current", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        if group[0]!= '(':\n            continue\n        if len(group) > 1:\n            if group[1] == '()':\n                result.append(1)\n            elif group[1] == '((())':\n                result.append(2)\n            elif group[1] == '(':\n                result.append(3)\n            else:\n                raise ValueError('Expected ( or () ) but got %s' % group)\n        elif len(group) == 1:\n            result.append(0)\n        else:\n            raise ValueError('Expected at least 1 group and got %s' % group)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_list = []\n    for n in paren_string.split(' '):\n        if n.isdigit():\n            nested_paren_list.append(int(n))\n        elif n.startswith('('):\n            nested_paren_list.append(parse_nested_parens(n[1:]))\n        elif n.startswith(')'):\n            nested_paren_list.append(parse_nested_parens(n[1:]))\n        else:\n            nested_paren_list.append(0)\n    return nested_paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_groups: List[int] = []\n    for group, paren_count in enumerate(paren_string.split(' ')):\n        nested_paren_groups.append(int(group) - 1)\n    return nested_paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = paren_string.strip()\n    return [parens.split() for parens in parse_parens(parens)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.startswith('((())'):\n        if paren_string.startswith('('):\n            return [int(x.split()[0].strip()) for x in paren_string.split()[1:]]\n        return paren_string.split()\n    return paren_string.split()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')\n    groups.reverse()\n    for group in groups:\n        for _ in range(2, len(group) - 1):\n            if group[group.index(group[len(group) - 1:])] == group[len(group) - 2]:\n                yield group[group.index(group[len(group) - 1:])]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # parsing a nested parentheses is done by breaking up string into\n    # groups as follows :\n    # () ---> ()\n    # (() ---> ()) ---> ()\n    # (()) ---> () ---> ((())\n    # () ---> () ---> ((())\n    #\n    # group number 1 is the group containing the first parenthesis in the string. The\n    # number of parenthesis in the group is the number of spaces in between the\n    # parenthesis. Group number 2 is the group containing the second parenthesis in\n    # the string. Group number 3 is the group containing the third parenthesis in\n    # the string.\n\n    # get number of spaces in between parenthesis\n    space_nr = 0\n\n    # group number 1 contains the first parenthesis in the string\n    groups = group_string(paren_string, 1)\n\n    # group number 2 contains the second parenthesis in the string\n    groups = group_string(paren_string, 2)\n\n    # group number 3 contains the third parenthesis in the string\n    groups = group_string(paren_string, 3)\n\n    # output all groups\n    output = []\n\n    for g in groups:\n        # group number 1 is the group containing the first parenthesis in the string.\n        # output the group number 1\n        output.append(g[0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    for paren in paren_string.split(\" \"):\n        if paren[0] == \"(\":\n            nested_parens.append(0)\n        elif paren[0] == \")\":\n            nested_parens.append(1)\n        elif paren[0] == \"(\" and paren[1] == \")\":\n            nested_parens.append(2)\n        elif paren[0] == \"(\" and paren[1] == \")\" and paren[2] == \"(\":\n            nested_parens.append(3)\n        else:\n            nested_parens.append(4)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[int] = []\n\n    for index, paren_token in enumerate(paren_string):\n        if not paren_token:\n            break\n        if paren_token[0] == '(':\n            groups.append(index)\n        elif paren_token[0] == ')':\n            groups.append(groups.pop() + 1)\n\n        if paren_token[0] == '{':\n            groups.append(index + 1)\n\n        if paren_token[0] == '}':\n            groups.pop()\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for group in paren_string.split(' '):\n        nested_parens.append(len(group))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Expand the parentheses to a list of shallow parentheses\n    nested_paren_list = []\n    for group in paren_string.split(\"()\"):\n        for element in group:\n            if element == '()':\n                if len(nested_paren_list) == 0:\n                    nested_paren_list.append('()')\n                else:\n                    nested_paren_list.extend(nested_paren_list[:-1])\n            elif element == '(':\n                if len(nested_paren_list) == 0:\n                    nested_paren_list.append('(')\n                else:\n                    nested_paren_list.extend(nested_paren_list[:-1])\n            elif element == '(':\n                if len(nested_paren_list) == 0:\n                    nested_paren_list.append('((())())')\n                else:\n                    nested_paren_list.append('((((()))()())())')\n            elif element == '())':\n                if len(nested_paren_list) == 0:\n                    nested_paren_list.append('((((()))()())()')\n                else:\n                    nested_paren_list.append('((((((((()))()())())())())())())')\n            elif element == ')':\n                if len(nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested = []\n    stack = []\n    stacks = []\n\n    # we are reading from the string and removing spaces at the beginning and end\n    stack.append(0)\n    stacks.append(0)\n\n    for group in paren_string:\n        if not group.isdigit():\n            raise ValueError('Expected a group number, not %s' % group)\n        if group > stacks[-1]:\n            stack.append(group)\n            stacks.append(0)\n\n    # now we have the stack and the stacks\n    for i in range(0, len(stack), 2):\n        if stack[i] <= stack[i + 1]:\n            nested.append(stack[i] - stack[i + 1])\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren_group in paren_string.split(' '):\n        if paren_group.startswith('(('):\n            paren_groups.append(1)\n        elif paren_group.startswith('))'):\n            paren_groups.append(2)\n        elif paren_group.startswith('())'):\n            paren_groups.append(3)\n        else:\n            raise ValueError('Invalid parenthesis group')\n\n    return paren_groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups_set = set()\n    nesting = 0\n    for paren_group in paren_string.split(','):\n        # Split the paren group by spaces\n        paren_groups = paren_group.split(' ')\n        # Add each paren group to the groups_set\n        for paren_group in paren_groups:\n            # Check if we have more than two groups, in which case we have more than one level of nesting\n            if len(paren_groups) > 2:\n                # Add the nesting level to the groups_set\n                groups_set.add(nesting)\n                nesting += 1\n                # Add the last group in the paren group to the groups_set\n                if len(paren_groups) == 1:\n                    groups_set.add(nesting)\n                else:\n                    groups_set.add(nesting + 1)\n\n        # Check if we have at least one level of nesting in the paren group\n        if nesting == 0:\n            # Add the group to the groups_set\n            groups_set.add(nesting)\n\n    return groups_set.pop()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    parens = []\n\n    while level < len(paren_string):\n        try:\n            parens.append(int(paren_string[level]))\n        except ValueError:\n            parens.append(level)\n            level += 1\n\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n\n    for paren in paren_string:\n        paren_list.append(int(paren, 16))\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for paren_group in paren_string.split(','):\n        if len(paren_group) == 1:\n            if paren_group[0] == '(':\n                return []\n            else:\n                return [parse_nested_parens(paren_group[1:])]\n        else:\n            if paren_group[0] == '(':\n                return [parse_nested_parens(paren_group[1:])]\n            else:\n                return [parse_nested_parens(paren_group[1:])] + parse_nested_parens(paren_group[1:])", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string.split():\n        if paren.endswith('()') and paren.endswith('('):\n            result.append(len(paren.lstrip())) + 2\n        elif paren.endswith('())') and paren.endswith('('):\n            result.append(len(paren.lstrip())) + 3\n        elif paren.endswith('())') and paren.endswith(')'):\n            result.append(len(paren.lstrip())) + 2\n        elif paren.endswith(')') and paren.endswith(')'):\n            result.append(len(paren.lstrip())) + 1\n        else:\n            result.append(len(paren.lstrip()))\n\n    return sorted(result)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for paren_string, level in enumerate(paren_string.split()):\n        # Paren string is a list of groups, each group is a list of spaces separated by a\n        # separator character. For each group, output the deepest level of nesting of\n        # parentheses that are not explicitly contained within the group. For example,\n        # ((),()) has maximum two levels of nesting while (((),())) has maximum three.\n        if paren_string[0]!= '(':\n            parens.append(level)\n        elif paren_string[-1]!= ')':\n            parens.append(level + 1)\n        elif paren_string[-1][-1]!= ',':\n            parens.append(level + 2)\n        elif paren_string[-1][-2]!= ':':\n            parens.append(level + 3)\n        elif paren_string[-1][-4]!= ')':\n            parens.append(level + 4)\n        elif paren_string[-1][-6]!= '(':\n            parens.append(level + 5)\n        else:\n            parens.append(level + 6)\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for i, paren in enumerate(paren_string):\n        if paren == '(':\n            groups.append(i)\n        elif paren == ')':\n            groups.append(groups[i + 1] + 1)\n        elif paren == ',':\n            groups.append(groups[i + 1] + groups[i + 2])\n        else:\n            groups.append(groups[i + 1] + 1)\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups = []\n    for i, paren in enumerate(paren_string):\n        if paren == '(':\n            groups.append(i)\n        elif paren == ')':\n            groups.append(groups.pop() - 1)\n        elif paren == '(':\n            groups.append(groups.pop() - 1)\n        elif paren == ')':\n            groups.append(groups.pop() - 1)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for paren in paren_string:\n        if paren == ')':\n            nested_parens.append(0)\n        elif paren == ')':\n            nested_parens.append(1)\n        elif paren == ')':\n            nested_parens.append(2)\n        elif paren == ')':\n            nested_parens.append(3)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = [0] * 4\n\n    for paren in paren_string:\n        if paren.isalnum():\n            nesting[paren.start()] += 1\n        elif paren.isdigit():\n            nesting[paren.start()] += 1\n        elif paren.isalphanum():\n            nesting[paren.start()] += 1\n        elif paren.isalpha():\n            nesting[paren.start()] += 1\n        elif paren.isdigit() and paren.isdigit():\n            nesting[paren.start()] += 1\n        elif paren.isdigit() and paren.isdigit() and paren.isdigit():\n            nesting[paren.start()] += 1\n        elif paren.isdigit() and paren.isdigit() and paren.isdigit() and paren.isdigit() and paren.isdigit():\n            nesting[paren.start()] += 1\n        else:\n            raise ValueError('Invalid nested paren %s. Expected %s but got %s' % (paren, paren.value, str(paren)))\n\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [\n        nested_paren\n        for nested_paren in paren_string.split('()')\n        if nested_paren.count('(') > 1\n        and nested_paren.count(')') > 1\n        and nested_paren.count(')') > 0\n    ]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    for paren_string_item in paren_string.split(' '):\n        paren_list.append(int(paren_string_item))\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def str_repr(level: int) -> str:\n        return str(level) if level else '({})'.format(level)\n\n    lvl = 0\n    for paren in paren_string.split(','):\n        if paren == '':\n            return lvl\n        lvl += 1\n        paren = paren.strip()\n        if paren in ('(', ')'):\n            paren = paren.replace(')', ',')\n        paren = paren.strip()\n        if paren in ('((', ')'):\n            paren = paren.replace(')', ',')\n\n        return str_repr(lvl) + paren\n\n    return [lvl for lvl, paren in zip(range(1, lvl + 1), paren_string)]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_lvl = 0\n    for paren in paren_string.split(' '):\n        if paren == '(':\n            paren_lvl += 1\n            continue\n        if paren == ')':\n            if paren_lvl > 1:\n                paren_lvl -= 1\n            else:\n                raise ValueError('Only one level of parentheses allowed.')\n        paren_lvl += 1\n        if paren_lvl > 1:\n            return [paren_lvl - 1]\n        else:\n            return paren_lvl - 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren_group in paren_string.split():\n        if paren_group[0] == '(':\n            paren_groups.append(0)\n        elif paren_group[0] == ')':\n            paren_groups.append(len(paren_group) - 1)\n        elif paren_group[0] == '()':\n            paren_groups.append(len(paren_group) - 1)\n        elif paren_group[0] == '(':\n            paren_groups.append(0)\n        elif paren_group[0] == ')':\n            paren_groups.append(1)\n        elif paren_group[0] == ')':\n            paren_groups.append(1)\n        else:\n            paren_groups.append(0)\n    return paren_groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Parse the string into groups\n    groups = paren_string.split(' ')\n    # Get the maximum depth of nested parentheses\n    max_depth = 0\n\n    for i in range(len(groups)):\n        # Get the current depth\n        current_depth = max_depth\n\n        # Check the group is a valid nest group\n        if groups[i][0] == '(':\n            # Check if there are more than one groups\n            if len(groups) > 1:\n                # Calculate the depth of the current group\n                depth = 0\n\n                # Loop through each group\n                for j in range(len(groups)):\n                    # Check if the current group is a valid nest group\n                    if groups[j][0] == '(':\n                        # Calculate the depth of the current group\n                        depth += 1\n\n                        # Get the current group and depth\n                        current_depth += depth\n\n                        break\n\n                # If the group is valid and has depth of at least 1, then it is a valid nest group\n                if current_depth > 1:\n                    # Get the current group and depth\n                    current_depth += depth\n                    break\n\n            # Get the next group in the list\n            next_group = groups[i][1:]\n\n            # Add the current depth to the max depth\n            max_depth = max_depth + current_depth\n\n        # Check if the current group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # skip any whitespace\n    if paren_string[-1] == '\\n':\n        paren_string = paren_string[:-1]\n\n    # skip the closing paren\n    if paren_string[-1] == ')':\n        paren_string = paren_string[:-1]\n\n    # The output will be sorted in order of nesting.\n    output = []\n    for paren_in_string in paren_string.split(' '):\n        # process the next group\n        output.append(parse_nested_parens(paren_in_string))\n\n        # The output will be sorted in order of depth of nesting.\n        output.sort(key=lambda x: int(x) - x)\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    nesting = 0\n    for paren_group in paren_string.split(\" \")[1:]:\n        for paren in paren_group.split(\" \")[1:]:\n            output.append(nesting)\n            nesting += 1\n            if paren_group[-1:] == paren[\"\"]:\n                break\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren_group in paren_string:\n        for current_group in paren_group.split('()'):\n            if current_group == '()':\n                result.append(2)\n            elif current_group == '(':\n                result.append(3)\n            else:\n                result.append(int(current_group))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.startswith('('):\n        return [parse_nested_parens(paren_string[1:-1])]\n    else:\n        return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(n) for n in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    if paren_string.startswith('('):\n        current = 1\n        for word in paren_string[2:]:\n            if word.isdigit():\n                current += 1\n            elif word.startswith('['):\n                current += 1\n            elif word.startswith(']'):\n                current -= 1\n            elif word == ')':\n                break\n        else:\n            raise ValueError('Invalid parentheses found in input string: {}'.format(paren_string))\n\n    if current < len(paren_string):\n        return [int(paren_string[current])]\n\n    raise ValueError('Invalid parentheses found in input string: {}'.format(paren_string))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    if paren_string is not None:\n        paren_string = paren_string.replace('()', '(').replace(')', ')').strip()\n        paren_string = paren_string.replace(')', ')').strip()\n        paren_string = paren_string.replace(',','').strip()\n        paren_string = paren_string.replace(' ', '').strip()\n        paren_string = paren_string.replace('[', '(').replace(']', ')').strip()\n        paren_string = paren_string.replace('[', '(').replace(']', ')').strip()\n        paren_string = paren_string.replace(' ', '').strip()\n        paren_string = paren_string.replace(',','').strip()\n        paren_string = paren_string.replace(' ', '').strip()\n        paren_string = paren_string.replace('(', '(').replace(')', ')').strip()\n        paren_string = paren_string.replace('(", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    num_groups = 0\n\n    while num_groups < len(paren_string):\n        num_groups += 1\n        group = paren_string[num_groups]\n        if group == '(':\n            if num_groups == 1:\n                return [num_groups]\n            else:\n                return [group, num_groups]\n        elif group == ')':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == '([':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == ')[':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == '({})':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == '){}':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == '}':\n            if num_groups == 1:\n                return [group]\n            else:\n                return [group, num_groups]\n        elif group == ')':\n            if num_groups == 1:\n                return [group]\n            else:\n                return", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parentheses = paren_string.split()\n    for group in range(len(paren_string)):\n        # Skip whitespace\n        if'' in paren_string[group]:\n            continue\n\n        # Find deepest level of nesting\n        current_level = 0\n        for level in range(current_level, len(paren_string)):\n            if (''in paren_string[level] or '(' in paren_string[level]):\n                current_level = level\n\n        if current_level == 0:\n            continue\n\n        # Add level to result\n        result = (current_level,)\n        result.append(paren_string[group])\n        return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def get_number(paren):\n        \"\"\" Return the number of the next parenthesis.\n        If no next parenthesis is found, return -1.\n        \"\"\"\n        if paren.group not in [('(', ')')]:\n            return -1\n        return paren.group.index(paren.group[0]) + 1\n\n    groups = paren_string.split()\n    if len(groups)!= 2:\n        raise ValueError('Expected 2 groups in parenthesis, got {}'.format(len(groups)))\n    depth = 0\n    for group in groups:\n        if depth == 0 and group[0] == '(':\n            depth += 1\n        elif depth == 0 and group[0] == ')':\n            depth -= 1\n        elif depth == 0 and group[0] == ',':\n            depth -= 1\n        elif depth == 0 and group[0] == '(' or group[0] == ')':\n            depth -= 1\n        elif depth == 1 and group[0] == ',':\n            depth -= 1\n        elif depth == 1 and group[0] == '(':\n            depth -= 1\n        elif depth == 1 and group[0] == ')':\n            depth -= 1\n        elif depth == 1 and group[0] == ',':\n            depth -= 1\n        elif depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def nest_level(group: str) -> int:\n        return len(group.split())\n\n    if group.startswith('('):\n        nest_level(group[1:])\n\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith(')'):\n        nest_level(group[1:])\n\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith('('):\n        nest_level(group[1:])\n    if group.startswith(')'):\n        nest_level(group[1:])\n\n    if group.startswith('()'):\n        nest_level(", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Group 1 represents the first level of nesting\n    group_pairs = paren_string.split(\"()\")\n    # Group 2 represents the second level of nesting\n    group_pairs += [line.strip() for line in paren_string.split(\"())\") if line.strip()]\n    group_pairs += [line.strip() for line in paren_string.split(\"())\") if line.strip()]\n    group_pairs += [line.strip() for line in paren_string.split(\"())\") if line.strip()]\n    # Group 3 represents the third level of nesting\n    group_pairs += [line.strip() for line in paren_string.split(\"())\") if line.strip()]\n    return group_pairs", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for p in paren_string.split():\n        if len(p) > 1:\n            yield parse_nested_parens(p[:1])", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string == '':\n        return None\n\n    paren_list = []\n\n    for paren_number in range(1, len(paren_string)):\n        if paren_number == len(paren_string) - 1:\n            return paren_list\n\n        paren_list.append(paren_number)\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [(item + 1) for item in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] = []\n    while paren_string:\n        match = re.match(r'^((?:(', paren_string)\n        if match:\n            stack.append(match.start(1))\n            paren_string = paren_string[match.end(1):]\n        else:\n            break\n    return stack\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for group in paren_string.split(' '):\n        nested_parens.append(len(group))\n        for depth in parse_depth(group):\n            nested_parens.append(depth)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Keyword is used to map a group to its depth (number of spaces) within the string.\n    group_keyword = '{}'.format(' '.join('{}'.format(paren_string[i]) for i in range(0, len(paren_string), 2)))\n    # Map parentheses to a group key.\n    group_paren_keyword = group_keyword.replace('(', group_keyword.replace(' ', ')'))\n    # Construct the list of groups.\n    groups = []\n    # Iterate over all the groups.\n    for group in paren_string:\n        # If a group has no depth, skip it.\n        if group in group_keyword:\n            continue\n        # Get the depth of the group.\n        group_depth = group_paren_keyword.count(group) - 1\n        # Add the depth to the list of groups.\n        groups.append(group_depth)\n        # If the depth is 0, skip the group.\n        if group_depth == 0:\n            continue\n        # Increment the count of the group.\n        group_paren_keyword.count(group) += 1\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for paren_string in paren_string.split(' '):\n        paren = paren_string.strip().lower()\n        if paren.startswith('(') or paren.startswith('['):\n            nested_parens.append(paren.count(')') + 1)\n        elif paren.startswith(')'):\n            nested_parens.append(paren.count(']') + 1)\n        elif paren.startswith('['):\n            nested_parens.append(paren.count(']') + 1)\n        elif paren.startswith(']'):\n            nested_parens.append(paren.count(')') + 1)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def nesting(nested_parens: List[int]) -> List[int]:\n        \"\"\" Input to this function is a list of int representing the nesting depth of nested parentheses in a string.\n        The output is a list of length 3, where the first item is the depth of the first level and the second and third items are the depth of the second and third level.\n        The output for the two levels of nested parentheses is ((())()(),)())\n        \"\"\"\n        level_0 = nested_parens[0]\n        if level_0 > 1:\n            level_0 = level_0 - 1\n        level_1 = nested_parens[1]\n        if level_1 > 1:\n            level_1 = level_1 - 1\n        level_2 = nested_parens[2]\n        if level_2 > 1:\n            level_2 = level_2 - 1\n        level = level_0 + level_1 + level_2\n        return [level]\n\n    return nesting(parse_nested_parens(paren_string))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    group_count = 0\n    for char in paren_string:\n        if char == '(':\n            group_count += 1\n        if char == ')':\n            group_count -= 1\n        if group_count == 0:\n            break\n    return [int(n) for n in str(group_count)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    group_nesting_depth = 0\n\n    if paren_string[-1:] == '(':\n        group_nesting_depth += 1\n\n    if paren_string[-1] == ')':\n        group_nesting_depth -= 1\n\n    return [int(paren_string[-1:]) for paren_string in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    lvl = 0\n    stack = []\n    for pair in paren_string.split(\", \"):\n        if pair.startswith(\"(\"):\n            if lvl < 2:\n                lvl = 2\n            elif lvl == 2:\n                stack.append(-1)\n            else:\n                if pair.startswith(\")\"):\n                    if lvl > 0:\n                        parens.append(stack[-1] + 1)\n                    parens.append(stack.pop())\n                else:\n                    parens.append(stack[-1] + 1)\n        elif pair.startswith(\")\"):\n            if lvl > 0:\n                stack.append(-1)\n            else:\n                if pair.startswith(\"(\"):\n                    if lvl < 2:\n                        lvl = 2\n                    elif lvl == 2:\n                        parens.append(stack[-1] + 1)\n                    else:\n                        parens.append(stack.pop())\n                else:\n                    parens.append(stack[-1] + 1)\n        elif pair.startswith(\")\"):\n            if lvl > 0:\n                stack.append(-1)\n            else:\n                if pair.startswith(\"(\"):\n                    if lvl < 2:\n                        lvl = 2\n                    elif lvl == 2:\n                        parens.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = list()\n    i = 0\n    while paren_string[i]!= '(':\n        paren_groups.append(i)\n        paren_string[i] = ''\n        i += 1\n\n    last_group = len(paren_groups) - 1\n    for paren_group in paren_groups[:last_group]:\n        last_group = paren_group\n        i = paren_group\n        while paren_string[i]!= ')':\n            paren_groups.append(i)\n            i += 1\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren_string_line in paren_string.split('\\n'):\n        if paren_string_line.startswith('('):\n            paren_string_line = paren_string_line[2:]\n        if paren_string_line.startswith(')'):\n            paren_string_line = paren_string_line[-2:]\n        if paren_string_line.startswith('('):\n            result.append(paren_string_line[2:])\n        if paren_string_line.startswith(')'):\n            result.append(paren_string_line[-2:])\n        if result[-1] == '\\n':\n            result[-1] = ''\n\n    return sorted(result)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    list_of_parens = []\n    for paren in paren_string.split(' '):\n        if paren.isdigit():\n            list_of_parens.append(paren)\n        else:\n            list_of_parens.append(0)\n    return list_of_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for paren in paren_string.split():\n        if paren.startswith('('):\n            groups.append(1)\n        elif paren.startswith(')'):\n            groups.append(2)\n        elif paren.startswith(')'):\n            groups.append(3)\n        else:\n            groups.append(0)\n    return groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # This is a simplified version of the Parsing API. The normal API has these methods in it.\n    # First, find the last opening parentheses (|) in the string. It's the start of\n    # the group, so we can assume that there are no nested parentheses until that point.\n    parentheses = []\n    while len(paren_string) > 0:\n        cur_paren = paren_string.find('|')\n        if cur_paren == -1:\n            # This is a known problem, you can parse a string that doesn't contain a\n            # matching opening parentheses, so it's a known issue.\n            # https://github.com/pyparsing/pyparsing/issues/354\n            cur_paren = 0\n        elif cur_paren == len(paren_string) - 1:\n            # The string ends with an opening parentheses.\n            parentheses.append(cur_paren + 1)\n        else:\n            # Find the end of the closing parentheses in the string.\n            cur_paren = paren_string.find('|', cur_paren + 1)\n            if cur_paren == -1:\n                # No closing parentheses, so this is a problem.\n                raise ValueError('Invalid string.')\n            parentheses.append(cur_paren)\n        paren_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = [paren for paren in paren_string.split(' ') if paren]\n    return max(0, sum(int(x) for x in parens))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for paren in paren_string.split(' '):\n        parens.append(int(paren))\n    return parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_depth = 0\n    for paren_token in paren_string:\n        if paren_token not in '(' and not paren_token.isspace():\n            break\n        else:\n            max_depth = max(max_depth, int(paren_token))\n    return max_depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren_number in range(0, len(paren_string), 2):\n        paren_groups.append(paren_number)\n    paren_groups.append(len(paren_string) - 1)\n    # () and (())\n    # ( ()) and (())\n    # ( () and (()))\n    # ( () and ((())))\n    # ( () and (())))\n    # ( () and ((())))\n    # ( () and ((())))\n    paren_groups.append(len(paren_string) - 1)\n\n    deepest = 0\n    for paren_number in range(0, len(paren_groups), 2):\n        # The first group has maximum depth 2.\n        if paren_number == 0:\n            deepest = paren_number\n        elif paren_number == len(paren_groups) - 1:\n            deepest = paren_groups[0]\n        elif paren_number == len(paren_groups) - 1:\n            deepest = paren_groups[1]\n        elif paren_number == len(paren_groups) - 2:\n            deepest = paren_groups[2]\n\n    return paren_groups[deepest]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    nesting_start = 0\n    while paren_string[nesting_start] in ['(', '())']:\n        nesting_start += 1\n    while paren_string[nesting_start] in ['(', '(', '())', '(', '())', '()', '()', '()', '('] and paren_string[nesting_start]!= ')':\n        nesting_start += 1\n\n    nesting += 1\n    return [\n        nesting_start - 1,\n        nesting_start,\n        nesting_start - 1,\n        nesting_start,\n        nesting_start - 1,\n        nesting_start,\n    ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens: List[int] = []\n    current_level: int = 1\n    for paren_group in paren_string.split(')'):\n        if not paren_group.isdigit():\n            continue\n        current_level += 1\n        if current_level > max_level:\n            raise ValueError(\"Invalid group nesting depth: {0}\".format(current_level))\n        nested_parens.append(current_level)\n\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '').replace(')', '')\n    level = 0\n    level_count = 0\n    while level:\n        paren_string = paren_string.replace('(', '').replace(')', '').replace('(', '').replace(')', '')\n        if paren_string[level]:\n            level_count += 1\n            if level_count == 2:\n                return [level]\n        level = level + 1\n    return None", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups_by_level = {}\n\n    for level in range(1, len(paren_string) + 1):\n        groups_by_level[level] = {}\n\n        for pair in paren_string[level].split(' '):\n            groups_by_level[level].setdefault(pair, []).append(level)\n\n    return groups_by_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string:\n        if paren.startswith('(('):\n            result.append(parse_nested_parens(paren[1:]))\n        elif paren.startswith('('):\n            result.append(parse_nested_parens(paren[1:]))\n        else:\n            result.append(-1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for paren in paren_string.split(\" \"):\n        if paren.count(\"())\"):\n            groups.append(1)\n        elif paren.count(\"()\"):\n            groups.append(2)\n        elif paren.count(\"()\"):\n            groups.append(3)\n        elif paren.count(\"())\"):\n            groups.append(4)\n        elif paren.count(\"())\"):\n            groups.append(5)\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # group 1: () -> 1, group 2: () -> 2, group 3: () -> 3\n    groups = []\n    for paren in paren_string.split(' '):\n        # the depth of the nesting level is the number of ('s' followed by the type)\n        # of parens (e.g. 1 = ((),), (), 2 = ()()(), 3 = ()()(),)\n        depth = 0\n        # the output for each group is the depth of the next level of nesting\n        for colon in paren.split(':'):\n            if colon[0] =='s':\n                depth += 1\n                # the next level of nesting is the depth of the ',' between parens\n                # (e.g. 3 = ((),), 2 = ((),)(), 1 = ()(),)\n                groups.append(depth)\n        groups.append(depth)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = re.split(r'(?:\\([^()]+\\))?(?:\\)[^()]+\\)', paren_string)\n    return [i for i, group in enumerate(groups) if group]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret = []\n    for paren in paren_string:\n        if paren[0] == '(':\n            ret.append(len(paren))\n        elif paren[0] == ')':\n            ret.append(0)\n        else:\n            ret.append(paren[1:])\n\n    return ret\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # we need to split the paren string by spaces, since the\n    # parens are separated by spaces, so we get a list of strings\n    paren_string = paren_string.split()\n\n    # find the deepest level of nesting for the paren string\n    level = 0\n    # find the max depth for a single nested paren\n    max_depth = None\n\n    for paren_string_part in paren_string:\n        if paren_string_part!= '()':\n            if level >= max_depth:\n                # there is a max depth for a single nested paren\n                max_depth = level\n            if level == 0:\n                # there is no max depth\n                level = 1\n            else:\n                # check for the second paren\n                if paren_string_part!= '(' and paren_string_part!= ')':\n                    # there is a second paren\n                    level += 1\n                if level == max_depth - 1:\n                    # there is no max depth\n                    level = 1\n    return [level] * max_depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    group_list = []\n    nesting = 0\n\n    while paren_string:\n        if paren_string[0] == '(':\n            nesting += 1\n            if nesting == 2:\n                group_list.append(nesting)\n        else:\n            if nesting == 1:\n                group_list.append(nesting)\n            else:\n                break\n\n        paren_string = paren_string[1:]\n\n    return group_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    # For each of the group, output the deepest level of nesting of parentheses.\n    # E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    parens = []\n    for paren_group in paren_string:\n        if paren_group == ():\n            parens.append(0)\n        elif paren_group == ()():\n            parens.append(1)\n        elif paren_group == ()():\n            parens.append(2)\n        else:\n            parens.append(3)\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n        return []\n\n    group_list = []\n    i = 0\n    while i < len(paren_string):\n        if paren_string[i] == '(':\n            group_list.append(i)\n            i += 1\n        elif paren_string[i] == ')':\n            group_list.append(i)\n            i += 1\n        elif paren_string[i] == '(':\n            group_list.append(i)\n            i += 1\n        elif paren_string[i] == ')':\n            group_list.append(i)\n            i += 1\n        elif paren_string[i] == '(':\n            group_list.append(i)\n            i += 1\n        elif paren_string[i] == ')':\n            group_list.append(i)\n            i += 1\n        else:\n            break\n\n    return group_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parented_parens = []\n    for sub_string in paren_string:\n        for i, sub_string_pos in enumerate(sub_string.split('(')):\n            if i < len(sub_string) - 1:\n                parented_parens.append(i + 1)\n            else:\n                break\n    return parented_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Reverse the nesting order to find out where the parenthesis begins:\n    for group in reversed(paren_string.split(' ')):\n        if group.startswith('(') and group.endswith(')'):\n            group = group[2:]\n        yield group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def extract_group(paren_string: str) -> List[int]:\n        \"\"\" Extract one group of parentheses. For each group, output the level of nesting\n        \"\"\"\n        group = 0\n        for paren_string_part in paren_string.split(' '):\n            if paren_string_part in ('', ')', ')'):\n                group += 1\n            elif paren_string_part == '(' and group < 2:\n                group += 1\n            elif paren_string_part == '(' and group == 2:\n                group += 1\n            elif paren_string_part == '(' and group == 3:\n                group += 1\n        return group\n\n    def extract_paren(group: int) -> str:\n        \"\"\" Extract one paren from the group.\n        For each paren, output the name.\n        \"\"\"\n        paren_string_part = group / 2 + 1\n        name = paren_string_part.split(' ')[0]\n        group -= 1\n\n        if name not in ('(', ')'):\n            raise ValueError('Expected parenthesis to start with ( or (.)')\n\n        return name\n\n    return extract_group(paren_string) + parse_nested_parens(extract_paren(extract_group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups_in_string = []\n    for paren in paren_string.split(' '):\n        for group in paren.split('('):\n            if group:\n                groups_in_string.append(group)\n\n    return groups_in_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    for paren_group in paren_string.split(' '):\n        paren_group = paren_group.strip()\n        if paren_group.startswith('(') and paren_group.endswith(')'):\n            level += 1\n        elif paren_group.startswith('(('):\n            level += 1\n        elif paren_group.startswith('('):\n            level += 1\n            paren_group = paren_group[1:]\n        elif paren_group.endswith(')'):\n            level -= 1\n    return level\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')\n\n    output = []\n\n    for group in groups:\n        depth = group.count(' ') + 1\n        if depth >= 3:\n            output.append(depth)\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Note that we are using this regex to match the parenthesis grouping. This is different from\n    # regexes that expect to match nested parentheses.\n\n    outer_grouping_regex = r'(?:\\((.*)\\))'\n    inner_grouping_regex = r'(?:\\()(.*)\\))'\n\n    matches = outer_grouping_regex.match(paren_string)\n    if matches is None:\n        return []\n\n    nested_parens = []\n    for group in matches.groups:\n        for group_count in group.count('('):\n            nested_parens.append(int(group_count))\n        if group.count(')'):\n            if group_count > 1:\n                nested_parens.append(int(group_count - 1))\n            else:\n                nested_parens.append(0)\n        else:\n            nested_parens.append(0)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_level = 1\n    for paren in paren_string.split(' '):\n        if paren.startswith('('):\n            nesting_level += 1\n        elif paren.startswith(')'):\n            nesting_level -= 1\n        else:\n            break\n\n    return nesting_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Parens in nested parentheses are separated by spaces\n    nesting_levels = []\n    for nesting_group in paren_string.split(' '):\n        if nesting_group:\n            if nesting_group[0] == '(':\n                nesting_levels.append(1)\n            elif nesting_group[0] == ')':\n                nesting_levels.append(-1)\n            elif nesting_group[0] == '()':\n                nesting_levels.append(0)\n            else:\n                raise ValueError('Invalid group \"{}\"'.format(nesting_group))\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for paren_string_group in paren_string.split('('):\n        paren_groups.append(0)\n    for paren_string_group in paren_string_group.split(')'):\n        paren_groups.append(-1)\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    # # # # # # # # # # # # # # # #", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    if paren_string == '(':\n        result.append(0)\n    if paren_string == '(' and paren_string!= ')':\n        result.append(1)\n    if paren_string == '()':\n        result.append(2)\n    if paren_string == ')':\n        result.append(3)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    while True:\n        if paren_string.find('(') > 0:\n            paren_groups.append(0)\n        elif paren_string.find(')') > 0:\n            paren_groups.append(len(paren_string) - 1)\n        elif paren_string == '':\n            break\n        else:\n            paren_groups.append(len(paren_string))\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n    while paren_level < len(paren_string):\n        level = paren_string[paren_level]\n        if level in (')', '()'):\n            paren_level += 1\n        elif level in (' ',''):\n            paren_level += 1\n        else:\n            break\n    if paren_level == 1:\n        return [1, 2, 3]\n    return [1, 2, 3]"]]