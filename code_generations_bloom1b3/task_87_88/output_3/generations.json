[["def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Init list\n    lst = []\n    for i, v in enumerate(lst):\n        if not v:\n            lst.append([None])\n        else:\n            lst[i] = [None]\n    # Init dict\n    dict = {}\n    # loop through row of lst\n    for k, v in enumerate(lst):\n        # if row is None, it's not in dict\n        if k:\n            dict[k] = [None]\n        # if row has no elements, it's null\n        if k:\n            # Add element to dict\n            dict[k] = [None]\n            # print k, v\n        # else if row has 1 element, sort by columns\n        else:\n            for j, k in enumerate(v):\n                if k is not None:\n                    dict[k] = dict[k][1:]\n            # sort by columns\n            for i, j in enumerate(v):\n                if v[i] is not None:\n                    dict[j] = dict[j][1:]\n\n    # print dict\n    for k, v in dict.items():\n        # print k, v\n        if k:\n            lst.append(get_row(v, 1))\n        else:\n            lst.append([])\n\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i, j = 0, 0\n    #print 'get_row', lst\n    while i < len(lst):\n        if lst[i][0] < x and lst[i][1] < x and lst[i][2] < x:\n            return [(lst[i][0], lst[i][1]),\n                (lst[i+1][0], lst[i+1][1]),\n                (lst[i+1][0], lst[i+1][1])]\n    i += 1\n    while j < len(lst):\n        if lst[j][0] > x and lst[j][1] > x and lst[j][2] > x:\n            return [(lst[j][0], lst[j][2]),\n                (lst[j+1][0], lst[j+1][1]),\n                (lst[j+1][0], lst[j+1][1])]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # make a copy, to avoid memory leaks\n    lst = lst.copy()\n    if lst.count(0) == 0:\n        raise ValueError('cannot sort with empty list')\n    # sort by rows in ascending order\n    lst = sorted(lst, key=lambda x: x[0])\n    # sort by rows in descending order\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    # return list of tuples, [(x1, y1), (x2, y2)...]\n    return [(x[1], lst[x[0]][lst[x[0]].count(0)-1]]\n               for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0: return []\n    return sorted(lst, key=lambda x: x[1], reverse=True)[0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #create a random generator\n    x = random.randint(0, lst.shape[0] - 1)\n    lst = [(x, [list(lst[i]) for i in xrange(len(lst[i]))]) for i in xrange(lst.shape[0] - 1)]\n    lst.sort(key=lambda x: x[0])\n\n    #transform into a 2 dimensional list\n    return [(x[0], [get_row(i, x[1]) for i in xrange(1, lst.shape[0] - 1)]) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # not really sure about this, but its the best I can come up with\n    d = {}\n    i, j = 0, 0\n    rows = []\n    cols = []\n    while i < len(lst):\n        # find the next row in order\n        next_row = d.get(lst[i]) or d.setdefault(lst[i], [])\n        if len(next_row) < 2:\n            # not enough rows\n            rows.append(lst[i])\n            cols[j] = 0\n            continue\n        else:\n            # need to do something with this row\n            if next_row[0] == x:\n                # found it!\n                row = next_row[1:]\n                cols.append(cols[j])\n                break\n        i += 1\n    # sort by rows\n    rows.sort(key=lambda x: x[0])\n    # sort by columns\n    cols.sort(key=lambda x: x[1])\n    return [(row, col) for row, col in zip(rows, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) < 2:\n        raise TypeError(\"lst must contain at least one element\")\n    if len(lst) == 0:\n        return []\n    i = 1\n    y = 0\n    while i < len(lst):\n        y = lst[i][0]\n        if y < y:\n            i += 1\n        else:\n            break\n    return [(y, i) for (y, i) in zip(lst[i:]:x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise ValueError('get_row: lst must be 2 dimensional,'\n                        'is not')\n    if len(lst[0])!= len(lst[1]):\n        raise ValueError('get_row: lst[0] must be of length'\n                            'equal to len(lst[1])')\n    if lst[0][-1]!= lst[0][-1]:\n        raise ValueError('get_row: lst[0][-1] must'\n                                'be equal to'\n                                'lst[0][-1]')\n    if lst[1][-1]!= lst[1][-1]:\n        raise ValueError('get_row: lst[1][-1] must'\n                                'be equal to'\n                                'lst[1][-1]')\n    if lst[0][-1]!= lst[0][-1]:\n        raise ValueError('get_row: lst[0][-1] must'\n                                'be equal to'\n                                'lst[0][-1]')\n    if lst[1][-1]!= lst[1][-1]:\n        raise ValueError('get_row: lst[1][-1] must'\n                                'be equal to'\n                                'lst[1][-1]')\n    i = 0\n    for x in lst:\n        i += 1\n        for y in x:\n            yield (i, y)\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    for row in lst:\n        if row[0] == 1:\n            if row[1] == 1:\n                if row[2] == 1:\n                    if row[3] == 1:\n                        if row[4] == 1:\n                            if row[5] == 1:\n                                if row[6] == 1:\n                                    return row\n        else:\n            if row[0] == 1:\n                if row[1] == 1:\n                    if row[2] == 1:\n                        if row[3] == 1:\n                            if row[4] == 1:\n                                if row[5] == 1:\n                                    return row\n            else:\n                if row[0] == 1:\n                    if row[1] == 1:\n                        if row[2] == 1:\n                            if row[3] == 1:\n                                if row[4] == 1:\n                                    return row\n        for col in row:\n            if col[0] == 1:\n                if col[1] == 1:\n                    if col[2] == 1:\n                        if col[3] == 1:\n                            if col[4] == 1:\n                                if col[5] == 1:\n                                    return (col, col)\n            else:\n                if col[0] == 1:\n                    if col[1] == 1:\n                        if col[2] == 1:\n                            if col[3] == 1:\n                                if col[4] == 1:\n                                    return (col, col)\n        return None\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [(x, i) for i, x in enumerate(lst)]\n    lst = [(x[0], x[1]) for i, x in enumerate(lst)]\n    idx = 0\n    for i in xrange(len(lst)):\n        idx += 1\n        if idx == lst.count(i):\n            return [(x, i) for x in lst]\n        if idx < lst.count(i):\n            return [(x[0], idx) for x in lst]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0 or len(lst[0]) == 0:\n        return []\n    \n    cur_index = 1\n    cur_row, cur_columns = [], 0\n    cur_cols = []\n    for row in lst:\n        if cur_index == 1:\n            cur_row = row\n            cur_columns = 0\n        elif cur_index % 4 == 3:\n            cur_columns = cur_cols\n            cur_cols = [cur_cols]\n            cur_cols.extend(row)\n        else:\n            cur_rows.append(row)\n            cur_cols.append(cur_columns)\n            cur_columns = 0\n            cur_cols = []\n            cur_cols = [cur_cols]\n            cur_cols.extend(row)\n    cur_cols.sort()\n    return cur_rows, cur_cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    d = lst.copy()\n    d.sort(key=lambda x: x[0], reverse=False)\n    return [d[0] for d in d if d[0]!= x]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [x for x in lst]\n    # Flatten the list, which makes it easier to iterate over\n    lst = [list(lst)]\n    # Create a new 2-tuple, which contains the row and column\n    # coordinates\n    new_row = (0, 0)\n    new_cols = 0\n    # Build a list of tuples for each row\n    for i, v in enumerate(lst):\n        # If the new row is the same as the previous row, set new_row\n        # to the value of the previous row, which will be the column 1\n        if i == 0:\n            new_row = v[0]\n            new_cols += 1\n        # Else, store the new row in the new tuple\n        else:\n            new_row = v[0]\n            new_cols += 1\n    # Return a list of tuples\n    return new_row, new_cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Add a new row to the end of lst\n    # eg: [[1,2], [3,4]]\n    row = [lst]\n    row.append(x)\n    lst.append(row)\n    # Now we have our new row, and we can start checking\n    # for non zero coordinates\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] > 0:\n                return lst[i][j]\n    # So now we have all coordinates, and\n    # we can sort by rows\n    lst.sort(key=lambda x: x[0])\n    # Sort coordinates of the row by columns in descending order\n    # eg: [[1,2,3,4], [5,1,2,3]]\n    return sorted(lst)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst:\n        x = [x[0] for x in lst]\n        x = [x[0] for x in x]\n        x = [x[0] for x in x]\n        i = 0\n        i = 0\n        for y in xrange(len(x)):\n            i = i + 1\n            if x[i] == y:\n                i = i + 1\n                for k in xrange(i + 1, len(x)):\n                    yield (k, i)\n        for y in xrange(len(x)):\n            i = i + 1\n            for k in xrange(i + 1, len(x)):\n                yield (k, i)\n        for y in xrange(len(x)):\n            i = i + 1\n            for k in xrange(i + 1, len(x)):\n                yield (k, i)\n        for y in xrange(len(x)):\n            i = i + 1\n            for k in xrange(i + 1, len(x)):\n                yield (k, i)\n        for y in xrange(len(x)):\n            i = i + 1\n            for k in xrange(i + 1, len(x)):\n                yield (k, i)\n        for", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x1, y1), (x2, y2)...]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [get_row(l, i) for i, l in enumerate(lst)]\n    rows = [(r[0], r[1]) for r in lst]\n    if x == len(rows):\n        return rows\n    elif x == 0:\n        return rows\n    else:\n        return [(r[0], r[1]) for r in lst]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst is None:\n        raise ValueError(\"lst must be given\")\n    if len(lst) < 2:\n        raise ValueError(\"lst must contain at least one item\")\n    if len(lst) > 2:\n        raise ValueError(\"lst must contain exactly two items\")\n    if len(lst) > 3:\n        raise ValueError(\"lst must contain exactly three items\")\n    lst = [(x, y) for (x, y) in lst]\n    idx = 0\n    for l in lst:\n        if len(l) > 1:\n            idx += 1\n            if idx > len(l):\n                idx = len(l)\n    if idx!= len(lst):\n        raise ValueError(\"idx is %d, but list contains %d\" % (idx, len(lst)))\n    return lst[idx]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1 and len(lst[0]) == 1:\n        return lst[0]\n    if len(lst) == 0 and len(x) == 0:\n        return [(x, 0) for x in lst]\n    if len(lst) == 1 and len(lst[0]) == 2:\n        return [(x, y) for x, y in zip(lst[0], x)]\n    if len(lst) == 0 and len(x) == 1:\n        return [(x, y) for x, y in zip(lst[0], x)]\n    # Generate coordinates of row\n    x = x - 1\n    y = 0\n    for i in range(x):\n        y += 1\n        for j in range(y):\n            if lst[i][j] == x:\n                return (i, j)\n            x += 1\n            y -= 1\n    # Generate coordinates of column\n    x = x - 1\n    y = 0\n    for i in range(y):\n        x += 1\n        for j in range(x):\n            if lst[i][j] == x:\n                return (i, j)\n    # No row, so return a list of tuples\n    return [(0, 0), (1, 4), (1, 0), (", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 1:\n        d = 0\n    else:\n        d = 1\n    rows = [[row] for row in lst]\n    rows = sorted(rows, key=lambda x: d*x)\n    rows = [(row[0], row[1]) for row in rows]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [row for row in lst if row]\n    if len(lst)!= len(x):\n        return []\n    if x == 0:\n        return lst\n    if x == len(lst):\n        return None\n    if len(lst) == 1:\n        return get_row(lst, x - 1)\n    return get_row(lst[1:], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    cols = []\n    if len(lst) == 1:\n        return row, cols\n    else:\n        return get_row(lst, x)\n    # return [(x1, y1), (x2, y2)...] where y1 < y2 or\n    # y1 == y2\n    for x1, y1, x2, y2 in zip(lst[1:], lst[:-1], lst[:1], lst[:-1][1:]):\n        if len(lst) == 1 and y1 > y2:\n            if x1 < x2:\n                col = y2 - y1\n                row.append([col, x1])\n                cols.append([col, x2])\n            else:\n                col = x1 - x2\n                row.append([col, x1])\n                cols.append([col, x2])\n        else:\n            if y1 < x2:\n                col = y2 - y1\n                row.append([col, x1])\n                cols.append([col, x2])\n            else:\n                col = x1 - x2\n                row.append([col, x1])\n                cols.append([col, x2])\n    return row, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i = 0\n    for row in lst:\n        for col in row:\n            if i == 0:\n                return [x, y]\n            if i == len(row) - 1:\n                return [(x, y) for x in xrange(len(row)), y]\n            if i!= len(row) - 1:\n                i = 0\n        i += 1\n    \n    return [(x, i) for x, i in zip(lst, xrange(len(lst)))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i, j = 0, 0\n    # rows\n    rows = [get_row(lst[i], x) for i in xrange(len(lst))]\n    # columns\n    columns = [get_col(lst[i], x) for i in xrange(len(lst))]\n    # row\n    return [(i, j) for (i, j) in zip(rows, columns)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    start, end = 0, 0\n    for i in range(len(lst)):\n        if lst[i][1] == 0:\n            break\n        if lst[i][1] == x-1:\n            if lst[i][2] == x-1:\n                end = end + 1\n            start = start + 1\n        if lst[i][1] == x+1:\n            if lst[i][2] == x+1:\n                end = end + 1\n            start = start + 1\n        if lst[i][1] == x-1:\n            if lst[i][2] == x+1:\n                end = end + 1\n            start = start + 1\n    return [\n        (start, end),\n        (start, end+1),\n        (start+1, end),\n        (end, end+1),\n        (start, end+1),\n        (start+1, end),\n        (end, end+1),\n        (start, end+1),\n        (start+1, end),\n        (end, end+1)\n    ]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return lst[0]\n    if isinstance(lst[0], list):\n        return get_row(lst, x)\n    if len(lst[0]) == 0:\n        return lst\n    lst = tuple(lst)\n    row = 0\n    column = 0\n    first = True\n    x = 0\n    while x < len(lst):\n        if len(lst[x]) == 0:\n            first = False\n            break\n        if first:\n            column = 0\n            row = 0\n            x += 1\n        else:\n            column += 1\n            row += 1\n        if column == len(lst) and row:\n            return (row, column)\n        lst[x] = lst[x][1:]\n        x += 1\n    return (row, column)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # The key is the tuple's row\n    keys = [[x]]\n    key = None\n    for i, row in enumerate(lst):\n        keys = keys + row\n        key = keys[-1]\n        if not key:\n            break\n    # The value is the tuple's column\n    values = []\n    for i, x in enumerate(keys):\n        values.append(values[-1] + x)\n    # Here we have to sort the keys\n    keys.sort()\n    values.sort()\n    return keys, values", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.tolist()\n    x = int(x)\n    lst = sorted(lst, key=lambda row: row[0], reverse=True)\n    lst.append((0, 0))\n    lst.append((0, 0))\n    lst.append((0, 0))\n    lst.append((0, 0))\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    columns = []\n    for i in xrange(len(lst)):\n        row.append(lst[i])\n        columns.append(0)\n    x = 0\n    while x < len(lst):\n        for i in xrange(len(lst)):\n            if columns[x] == lst[x]:\n                return row, columns\n            elif columns[x] == lst[x + 1] and columns[x] == lst[x + 2]:\n                x += 1\n            else:\n                x += 1\n    return row, columns", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    res = []\n    x = 1 if x < len(lst) else x\n    for row, col, row_idx, col_idx in lst:\n        if row_idx == 1:\n            # if the row has only one column\n            if col_idx == 0:\n                # if the column is 0\n                if col_idx == len(lst) - 1:\n                    # if the row is the last column\n                    res.append((row, x))\n                else:\n                    # if the column is the last column\n                    res.append((row, x - 1))\n                x -= 1\n            else:\n                # if the column is more than one\n                if col_idx == len(lst) - 1:\n                    # if the row is the last column\n                    res.append((row, x))\n                else:\n                    # if the column is the last column\n                    res.append((row, x - 1))\n                x -= 1\n        else:\n            # if the column is more than one\n            if col_idx == len(lst) - 1:\n                # if the row is the last column\n                res.append((row, x))\n                x -= 1\n            else:\n                # if the column is the last column\n                res.append((row, x - 1))\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [\n        tuple([row[column]*col for row, column in lst]) for row, col in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return (x, x) for x in lst if x in x\n\n    def sort_rows(lst):\n        \"\"\"\n        Given a list of tuples, sort each tuple by its columns.\n        \"\"\"\n        return sorted(lst, key=lambda x, (y, c): (y, c))\n\n    def sort_cols(lst):\n        \"\"\"\n        Given a list of tuples, sort each tuple by its rows.\n        \"\"\"\n        return sorted(lst, key=lambda x, (y, c): (y, c))\n\n    def __str__(self):\n        return str(tuple(self))\n\n    def __repr__(self):\n        return self.__str__()", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    if len(lst) == 2:\n        lst = [(get_row(lst, x), get_row(lst, x)) for x in lst]\n    else:\n        lst = [(x, 0) for x in lst]\n    \n    if len(lst) == 1:\n        lst.insert(0, get_row(lst, 0))\n    else:\n        lst.sort(key=lambda x: x[1], reverse=True)\n    \n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [x for x in lst if x!= 0]\n    return [i for i in lst if x > 0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    lst.sort(key=lambda x: x[0])\n    for row, col in lst:\n        return [get_row(row, x) for x in col]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Each row must be non-empty\n    if len(lst) == 0:\n        return None\n    \n    # Get x in the list of x\n    x = lst[0]\n    \n    # Compute x coordinates\n    for i in range(1, len(lst)-1):\n        if x <= lst[i]:\n            x = lst[i]\n            break\n    \n    # Compute y coordinates\n    for i in range(1, len(lst)-1):\n        if x >= lst[i+1]:\n            y = lst[i+1]\n            break\n    \n    # Returns tuple of (x1, y1), (x2, y2) tuple, where\n    # x1 and y1 are the upper left corners of the cell,\n    # and x2 and y2 are the lower right corners of the cell.\n    return [(x, y), (x, y), (x, y)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    first = True\n    prev = None\n    coord = 0\n    for row in lst:\n        if first:\n            first = False\n            prev = None\n        else:\n            prev = coord\n            coord = 0\n        for col in row[:-1]:\n            if col == prev:\n                coord += 1\n                if coord > len(lst):\n                    coord = 0\n        if prev is not None:\n            coord = prev\n            prev = None\n        else:\n            prev = coord\n            coord = 0\n    \n    return coord", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 1:\n        x = 0\n        for row in lst:\n            for column in row:\n                if column < x:\n                    return row\n            x = column\n    return lst[x:x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) < 2:\n        return []\n    if len(lst) == 2:\n        lst = [get_row(lst, x) for x in range(x)]\n    else:\n        lst = [get_row(lst, x) for x in range(len(lst))]\n    return [(x[0], x[1]) for x in lst]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    for row in lst:\n        if row[0] > x:\n            if lst:\n                return get_row(lst, x)\n            return []\n        if row[0] < x:\n            if lst:\n                return get_row(lst, x)\n            return [(x, row[0])]\n    return [(x, row[0]) for x, row in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [lst]\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    x = int(x)\n    for i, elem in enumerate(lst):\n        lst[i] = [get_row(lst, x)] + elem\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return sorted([x[0] for x in lst], key=lambda x: x[1])[::-1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0 or lst[0] == []:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    if len(lst) == 2:\n        return [(x, 0) for x in lst]\n    if len(lst) == 3:\n        return [(x, x) for x in lst]\n    return [(0, 0)] + [(x, 0) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = np.array(x)\n    lst = np.array(lst)\n    cols = np.array(lst.shape[1])\n    rows = np.array(lst.shape[0])\n    return x, cols, rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def _check(self, lst, x):\n        \"\"\"\n        Check to see if lst and x are identical.\n        \"\"\"\n        \n        # If lst contains 2 elements, return True\n        if len(lst) == 2:\n            return True\n        \n        # If lst contains 1 element, return False\n        if len(lst) == 1:\n            return False\n        \n        # If lst contains 3 elements, return False\n        if len(lst) > 3:\n            return False\n        \n        # If lst contains 0 elements, return False\n        if len(lst) == 0:\n            return False\n        \n        # If lst contains more than 3 elements, return False\n        return False\n        \n        # If lst is empty, return False\n        if len(lst) == 0:\n            return False\n        \n        # If lst contains all the same elements, return False\n        if self._check(lst[0], x[0]) and self._check(lst[1], x[1]) and \\\n                self._check(lst[2], x[2]):\n            return False\n        \n        # If lst contains all different elements, return False\n        return True\n    \n    def _get_data(self, lst, x):\n        \"\"\"\n        Use data from lst to build a data dictionary.\n        \"\"\"\n        \n        # If x is equal to 1, return an empty dictionary\n        if x == 1:", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.copy()\n    lst.sort()\n    if len(lst) == 1:\n        return [(x[0], x[1]) for x in lst]\n    else:\n        return [(get_row(lst, x)) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Type check for x and lst\n    if x == 0:\n        raise ValueError('Invalid argument')\n    # Map lst into an iterable\n    lst = [x for x in lst if x!= 0]\n    # Calculate the coordinates of the x\n    lsc = [x for x in lst for _ in range(len(x))]\n    lsc.sort(key=lambda x: x[0])\n    # Sort the coordinates by rows in ascending order\n    lsc.sort(reverse=True)\n    # Sort coordinates of the x\n    lsc.sort(key=lambda x: x[-1])\n    # Calculate the coordinates of the y\n    lsc.append(0)\n    # Sort the coordinates of the y by columns in descending order\n    lsc.sort(reverse=True)\n    # Calculate the coordinates of the last y\n    lsc.append(len(lst))\n    # Return the coordinates\n    return lsc", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # one row = one column\n    ncols = len(lst[0])\n    if len(lst) > 1:\n        # one row = multiple columns\n        ncols = len(lst[1])\n        return map(lambda x, y: [(x, y), x], lst)\n\n    # x (row, columns) must exist in lst\n    if len(lst) < 2:\n        raise ValueError(\"incorrect number of columns: \"+str(lst))\n    if x not in lst:\n        raise ValueError(\"incorrect number of columns: \"+str(lst))\n    if len(lst) < 3:\n        raise ValueError(\"incorrect number of rows: \"+str(lst))\n    if len(lst) < 4:\n        raise ValueError(\"incorrect number of tuples: \"+str(lst))\n\n    # make it an int\n    x = int(x)\n    if x < 0:\n        raise ValueError(\"incorrect number of columns: \"+str(lst))\n\n    # sort coordinates by rows\n    lst.sort(key=lambda x: x[0])\n    # sort coordinates of each row by columns\n    lst.sort(key=lambda x: x[1])\n\n    # check to see if the row has been completed\n    # with a tuple\n    if len(lst) == 1:\n        if lst[0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if isinstance(lst, list):\n        lst = list(lst)\n    # The function can only do a single search.\n    # For example, it cannot search through an empty list\n    if len(lst) > 1:\n        lst = lst[1:]\n    lst = [(x1, y1), (x2, y2)...]\n    for row in lst:\n        if len(row) == 1:\n            return row\n        if len(row) < 2:\n            return None\n        if row[0] == x:\n            return row\n    return None", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.items()\n    x = x.items()\n    \n    # Determine initial rows.\n    rows = [_ for _ in x]\n    for i in xrange(len(lst)):\n        for j in xrange(len(lst[i])):\n            if lst[i][j] > x[i-1][j] and lst[i][j] < x[j-1][j]:\n                rows.append(j)\n                break\n    rows.sort(key=lambda x: x[1])\n    \n    # Determine initial columns.\n    columns = [_ for _ in x]\n    for i in xrange(len(lst)):\n        for j in xrange(len(lst[i])):\n            if lst[i][j] > x[i-1][j] and lst[i][j] < x[j-1][j]:\n                columns.append(i)\n                break\n    columns.sort(key=lambda x: x[1])\n    \n    # Calculate tuple.\n    tuple = [[rows[i]], [columns[i]]]\n    \n    return tuple", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst == []:\n        return []\n    if isinstance(lst[0], str):\n        lst = [lst[0]]\n    rows = [get_row(lst[1:], x) for x in xrange(len(lst[0]))]\n    columns = [(max(x) - min(x), 0) for x in xrange(len(lst[0]))]\n    # sort coordinates first by rows, then by columns\n    return [(rows[i][1], columns[i][0]) for i in xrange(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= len(x):\n        raise ValueError(\"Lengths of lst and x are not the same\")\n    # values in each row may be a single value or a list\n    # elements in each column may be a single value or a list\n    if not lst:\n        return x\n    # the first coordinate of each tuple is the row\n    x = [int(i) for i in x]\n    # the second coordinate of each tuple is the column\n    x = [int(j) for j in x]\n    return x", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    lst = lst[:]\n    print(lst)\n    lst = [(x1, y1), (x2, y2)...]\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if x1 + j == x or x2 + j == x or y1 + j == x or y2 + j == x or x1 == x or x2 == x or y1 == x or y2 == x:\n                if col == x:\n                    return (x1, y1)\n                else:\n                    x1 = col\n                    y1 = i\n                    x2 = col\n                    y2 = j\n                    break\n        if x1 == x:\n            return (x1, y1)\n        x1 = x1 + 1\n    if y1 == x:\n        return (x1, y1)\n    y1 = y1 + 1\n    if y2 == x:\n        return (x1, y1)\n    y2 = y2 + 1\n    return (x1, y1)\n\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [(i, j) for i, j in lst]\n    # this is for future lines\n    # if len(rows) > 1:\n    #     rows = [(i, j) for i, j in rows]\n    \n    if len(rows)!= len(lst):\n        raise ValueError('got wrong number of rows')\n    \n    # this is for future lines\n    # if len(rows) == 1:\n    #     rows = [(i, j) for i, j in rows]\n    \n    # we need to sort coordinates by rows in ascending order\n    # so, we first sort coordinates by rows.\n    rows = sorted(rows, key=lambda x: x[1])\n    \n    # we need to sort coordinates of the row by columns in descending order\n    # so, we first sort coordinates by columns.\n    columns = sorted(columns, key=lambda x: x[0])\n    \n    # and now we return the result\n    return rows, columns\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = x\n    for i, x in enumerate(lst):\n        if x[0] < row[0]:\n            if x[0] > row[1]:\n                row = i\n            else:\n                break\n        else:\n            row = i\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def i_is(iterable):\n        for i, elem in enumerate(iterable):\n            if elem[0] == i:\n                return True\n        return False\n    \n    x = int(x)\n    if len(lst) < 2:\n        raise ValueError, \"Only one row is needed\"\n    row = [get_row(lst, x) for x in xrange(1, len(lst))]\n    y = [i for x, i in enumerate(row)]\n    return row, y", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    col = 0\n    for i in lst:\n        x = x + 1\n        x1 = 0\n        y1 = col\n        x2 = x1\n        y2 = col\n        while y2 >= len(lst):\n            x1 += 1\n            y2 -= 1\n        while x1 >= len(lst):\n            x2 -= 1\n            x1 -= 1\n        if y2 >= len(lst):\n            return (y1, x1, x2)\n        if x2 >= len(lst):\n            return (y1, x1, x2)\n        if y2 >= len(lst):\n            return (y1, x1, x2)\n        if y1 >= len(lst):\n            return (y1, x1, x2)\n        if x2 >= len(lst):\n            return (y1, x1, x2)\n        if y1 >= len(lst):\n            return (y1, x1, x2)\n        if y2 >= len(lst):\n            return (y1, x1, x2)\n        col = y1\n    return (col, col)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 1:\n        return [get_row(lst[1:], x) for x in xrange(len(lst) - 1)]\n\n    #create lists\n    t1 = [(x, y) for x, y in lst]\n    t2 = [(x, y) for x, y in lst if x!= y]\n    t3 = [(x, y) for x, y in lst if x == y]\n    #sort rows in ascending order\n    t1.sort()\n    t2.sort()\n    t3.sort()\n    #sort column in descending order\n    t1.reverse()\n    t2.reverse()\n    t3.reverse()\n    #create a list of tuples\n    return tuple([(x, y) for x, y in zip(t1, t2, t3)])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    try:\n        return _convert_row(lst, x)\n    except:\n        return [(x, 0) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    rows = [[] for i in range(len(lst))]\n    for row in lst:\n        rows[row].append(0)\n    return rows[len(lst) - 1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort rows in ascending order\n    cols_rows = [(x, lst[x][0]) for x in lst]\n    sorted_rows = [s for s in cols_rows if s]\n    # Sort columns in descending order\n    cols_cols = [(x, lst[x][1]) for x in lst]\n    sorted_cols = [s for s in cols_cols if s]\n    return sorted_rows, sorted_cols\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        print('Error: List has not two dimensions')\n        return lst\n    n = len(lst[0])\n    l = lst[1]\n    if n == 0:\n        return lst\n    if l[0] % 2 == 0:\n        return [(x1, y1), (x2, y2) for (x1, y1), (x2, y2) in get_row(l, x)]\n    else:\n        return [(x, y) for (x, y) in get_row(l, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [(x, x) for x in lst]\n    x = list(range(len(lst)))\n    x.sort()\n    return [(x, x) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    a = np.asarray(lst)\n    b = np.asarray([x for x in a])\n    if len(b) == 1:\n        return a[::-1, :]\n    if len(b) > 1:\n        if len(b[0]) == 1:\n            return a[::-1, 0, :]\n        elif len(b[0]) == 2:\n            return a[::-1, 0, 2, :]\n        elif len(b[0]) == 3:\n            return a[::-1, 0, 3, :]\n        elif len(b[0]) == 4:\n            return a[::-1, 0, 4, :]\n        else:\n            return a[::-1, 0, len(b[0]), :]\n    \n    return a[::-1, x, :]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = lst\n    r = [x for x in l]\n    t = []\n    for r in range(len(r)):\n        for c in range(len(r)):\n            if r == c:\n                t.append((r, c))\n    return t", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        return [(x, x) for x in lst]\n    sorted_lst = sort(lst)\n    # Order rows in ascending order\n    return [(row, col) for row, col in zip(sorted_lst, sort(x))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    ## This is a general algorithm, not meant to be used with any\n    ## specific data structure.\n    #\n    # This algorithm is a generalization of a basic\n    # coordinate sorting algorithm, which we now describe.\n    #\n    # For the remainder of this algorithm, let x be the\n    # parameter, and let x be an integer greater than or\n    # equal to zero.\n    #\n    # A partition of the indices is a list of tuples:\n    # (row, column)\n    #\n    # To sort a set of indices, we first find a partition of the\n    # indices, and then sort the set of tuples.\n    #\n    # We assume that all indices are positive integers.\n    #\n    # Given a partition P of the indices, find the maximum\n    # value of the tuple in P.\n    #\n    # Given a list of tuples, assume each tuple is a coordinate\n    # - (row, columns), starting with 0.\n    #\n    # The coordinates of a row in a partition P are the values\n    # of all tuples in P sorted by row.\n    #\n    # We have three cases:\n    #\n    # 1) The index is in the partition\n    #    - If the tuple has a row in the partition, return the row.\n    #    - Otherwise", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    lst = lst.strip().split()\n    if len(lst) == 0:\n        return []\n    lst = [(x, lst[i]) for i in range(len(lst))]\n    #sort the list by rows\n    lst.sort(lambda x, y: cmp(x[1], y[1]))\n    #sort by columns\n    lst.sort(lambda x, y: cmp(x[0], y[0]))\n    #sort the coordinates\n    return [x[1], x[0]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    n = len(lst)\n    if n == 0:\n        return lst\n    sorted_cols = [x for x in range(n - 1)]\n    sorted_rows = [x for x in range(n)]\n    if sorted_cols == []:\n        return lst\n    sorted_cols.sort()\n    sorted_rows.sort()\n    for row in sorted_rows:\n        for col in sorted_cols:\n            if row == col:\n                return tuple(sorted(lst[row:col]))\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    t = [(x1, y1), (x2, y2)]\n    for i in range(len(lst)):\n        if lst[i][0] < x1:\n            t.insert(0, t[0])\n        elif lst[i][1] < y1:\n            t.insert(0, t[1])\n        elif lst[i][2] < x2:\n            t.insert(0, t[2])\n        elif lst[i][3] < y2:\n            t.insert(0, t[3])\n    t.sort(key=lambda x: x[1], reverse=True)\n    return t", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def cmp_row(x1, y1, x2, y2):\n        \"\"\"\n        Compares 2 values and returns a tuple with the order of the\n        comparisons.\n        \"\"\"\n        if x1 > x2:\n            return 1\n        elif x1 < x2:\n            return -1\n        else:\n            return cmp(y1, y2)\n\n    def is_odd(x1, y1, x2, y2):\n        \"\"\"\n        Returns True if the first row is even and second odd.\n        \"\"\"\n        if x1 > x2:\n            return True\n        elif x1 < x2:\n            return False\n        else:\n            return is_odd(y1, y2, x2, x1)\n\n    def is_odd(x1, y1, x2, y2):\n        \"\"\"\n        Returns True if the first row is even and second odd.\n        \"\"\"\n        if x1 > x2:\n            return True\n        elif x1 < x2:\n            return False\n        else:\n            return is_odd(y1, y2, x1, x2)\n\n    def _get_x(lst, x):\n        \"\"\"\n        Returns the coordinate of the x, given in lst.\n        \"\"\"\n        if x < 0:\n            return (lst[0], -lst[1])\n        elif x > lst[1]:\n            return (lst[1], -lst[0])\n        else:\n            return x\n\n    def _get_y(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    left, right = list(lst), list(lst)\n    res = []\n    for i in range(len(left)):\n        for j in range(len(right)):\n            if right[i] > right[j]:\n                left[i], right[i] = right[j], left[i]\n        res.append((left[i], right[i]))\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    x = int(x)\n    assert len(lst) == len(x)\n    lst = [(row, col) for row, col in lst if col > x]\n    \n    if len(lst) == 0:\n        return []\n    \n    if len(lst) < 2:\n        return []\n    \n    if x > len(lst[0]):\n        return []\n    \n    return lst[1:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.append(lst)\n    x = x if isinstance(x, integer_types) else int(x)\n    if isinstance(lst[0], tuple):\n        return [get_row(lst[1:], x) for lst in lst[:-1]]\n    elif isinstance(lst[0], list):\n        return [_get_row(lst[1:], x) for lst in lst[:-1]]\n    elif isinstance(lst[0], int):\n        return [(x,) for x in lst]\n    else:\n        raise TypeError(\"List of tuples\")\n\n    # now sort by rows\n    lst.sort(key=lambda x: (x[0], x[1]))\n    # then sort by columns\n    lst.sort(key=lambda x: (x[1], x[0]))\n    # finally order rows and columns\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        return None\n    x = list(x)\n    row = 0\n    col = 0\n    return x, row, col", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst.count(x) == 0:\n        return [(x, x), (x, x)]\n    if lst.count(x) == 1:\n        return [(x, x), (x,)]\n    if x == 1:\n        return [(x, x), (x,)]\n    if x == 2:\n        return [(x, x), (x, x), (x, x)]\n    if x == 3:\n        return [(x, x), (x, x), (x, x), (x, x)]\n    if x == 4:\n        return [(x, x), (x, x), (x, x), (x, x)]\n    if x == 5:\n        return [(x, x), (x, x), (x, x), (x, x)]\n    if x == 6:\n        return [(x, x), (x, x), (x, x), (x, x), (x, x)]\n    if x == 7:\n        return [(x, x), (x, x), (x, x), (x, x), (x, x)]\n    if x == 8:\n        return [(x, x), (x, x), (x, x), (x, x), (x, x)]\n    if x == 9:", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get(lst, x):\n        y = 0\n        for i in range(len(lst)):\n            y += lst[i]\n            if x == y-1:\n                return y\n            if x == y:\n                break\n        return y\n\n    def col_sort(lst):\n        \"\"\"\n        Sort each column of a 2 dimensional data list in\n        ascending order, starting from the left column.\n        \"\"\"\n        return [x for x,y in lst.iterrows() if y > x]\n\n    def row_sort(lst):\n        \"\"\"\n        Sort each row of a 2 dimensional data list in\n        descending order, starting from the top row.\n        \"\"\"\n        return [x for x,y in lst.iterrows() if y < x]\n\n    return [col_sort(lst), row_sort(lst)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = [x for x in lst if x!= 0]\n    if len(l) == 0:\n        return []\n    d = list(zip(l, range(len(l), len(l)+1)))\n    for i,x in enumerate(d):\n        if d[i][0] < d[i+1][0]:\n            return [(d[i][0], d[i+1][1]), d[i]]\n    return []\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        row = [0 for i in range(len(lst[0]))]\n        column = [0 for i in range(len(lst[0]))]\n        return [(row[x], column[x]) for x in lst]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Build list of tuples\n    t = []\n    for row in lst:\n        t.append(tuple(row))\n    # Sort in ascending order\n    t.sort()\n    # Sort in descending order\n    t.reverse()\n    # Build tuples and return them\n    for i, (x1, y1) in enumerate(t):\n        return [(x1, y1), (x2, y2) for (x2, y2) in t[i+1]]\n    # No entry found\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = range(len(lst[0]))\n    x = x[x[0]]\n    for i in xrange(len(lst[0])):\n        l = range(len(lst[0][i]))\n        if i == x[0]:\n            return [(l[i], l[i+1]) for l in lst]\n        else:\n            return [(lst[0][i], lst[0][i+1]) for i in xrange(len(lst[0]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = 0\n    for t in lst:\n        row.append((t[0], t[1]))\n        for i, t in enumerate(t[1:]):\n            row[col].append(t[col])\n            col += 1\n    # sort by rows in ascending order\n    rows = sorted(row)\n    rows.reverse()\n    # sort by columns in descending order\n    cols = sorted(row)\n    cols.reverse()\n    # copy the values of the rows and columns to return tuple\n    return tuple(row[row.index(col)+1:])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #sort coordinates of the row by columns\n    x = [x[1] for x in x]\n    arr = []\n    #sort coordinates of the row by rows\n    for x in x:\n        arr.append((x, x))\n    #sort coordinates of the row by columns\n    return sorted(arr, key=lambda x: x[1]-x[0], reverse=False)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    m = len(lst)\n    r = []\n    l = []\n    n = 0\n    for i in range(m):\n        if len(lst[i]) == 0:\n            r.append((n, n))\n            n = n + 1\n            l.append([r[0]])\n        else:\n            x = lst[i][0]\n            x = x / m\n            l.append([(n, x)])\n            r.append((n, x))\n    return l, r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    columns = []\n    for i, row in enumerate(lst):\n        rows.append(row)\n        columns.append(len(row))\n    rows.sort()\n    columns.sort()\n    row_index = 0\n    for row in range(len(lst)):\n        if x in lst[row]:\n            row_index = row\n            break\n        elif row_index >= len(lst):\n            row_index = -1\n        else:\n            row_index += 1\n    return [(row_index, columns[row_index]) for (row_index, column) in zip(rows, columns)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [(x1, y1), (x2, y2)...]\n    for i in xrange(len(lst)):\n        if lst[i] == 1:\n            row = rows[i]\n            if lst[i] > 1:\n                row.append(lst[i])\n            if lst[i]!= 0:\n                row.append(lst[i])\n    return [(row[1], row[2])...]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 2:\n        return [get_row(lst, i) for i, lst in enumerate(lst)]\n\n    if len(lst) == 2:\n        return lst\n\n    if lst[0] is None:\n        return []\n\n    if len(lst) == 3:\n        return [get_row(lst, i) for i, lst in enumerate(lst)]\n\n    if lst[0] is not None and len(lst) == 2:\n        return [get_row(lst, i) for i, lst in enumerate(lst)]\n\n    if lst[0] is not None and len(lst) == 3:\n        return [get_row(lst, i) for i, lst in enumerate(lst)]\n\n    return get_row(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_rank(x):\n        return min(len(lst), len(x))\n    for i, row in enumerate(lst):\n        x = x[i]\n        for j in range(len(x)):\n            if x[j] < x[j - 1:]:\n                x[j] = x[j - 1:]\n        print i, row, x\n    return sorted(x, key=get_rank)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i = 0\n    d = lst\n    m = len(d)\n    if i == 0:\n        return lst\n    x = [i for i in xrange(m) if d[i] > d[i - 1]][0]\n    while i < len(d) - 1:\n        if d[i] == d[i - 1]:\n            x.append(d[i])\n            i += 1\n        else:\n            i += 1\n    return [x for x in xrange(len(x)) if x not in x[0]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def sort_rows(lst):\n        try:\n            x = sorted(lst[0], key=lambda x: x[1])\n        except IndexError:\n            raise ValueError(\"lst is not sorted.\")\n        return lst\n\n    def sort_cols(lst):\n        try:\n            x = sorted(lst[0], key=lambda x: x[0])\n        except IndexError:\n            raise ValueError(\"lst is not sorted.\")\n        return lst\n\n    def get_row(lst, x):\n        \"\"\"\n        You are given a 2 dimensional data, as a nested lists,\n        which is similar to matrix, however, unlike matrices,\n        each row may contain a different number of columns.\n        Given lst, and integer x, find integers x in the list,\n        and return list of tuples, [(x1, y1), (x2, y2)...] such that\n        each tuple is a coordinate - (row, columns), starting with 0.\n        Sort coordinates initially by rows in ascending order.\n        Also, sort coordinates of the row by columns in descending order.\n        \n        Examples:\n        get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) < 2:\n        raise ValueError(\"lst must be greater than or equal to 1\")\n    if len(lst[0]) < len(lst[1]):\n        raise ValueError(\"lst[0] must be greater than or equal to lst[1]\")\n    if len(lst[0])!= len(lst[1]):\n        raise ValueError(\"lst[0] and lst[1] must be the same length\")\n    # Find coordinates in lst[0]\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n    for i in range(len(lst[0])):\n        # Find coordinates in lst[i]\n        for j in range(len(lst)):\n            if lst[j][i]!= lst[i][j]:\n                continue\n            # Found coordinates, sort first by rows\n            x1 = lst[j][0]\n            y1 = lst[j][1]\n            x2 = lst[i][0]\n            y2 = lst[i][1]\n            lst[j][0] = x1\n            lst[j][1] = y1\n            lst[i][0] = x2\n            lst[i][1] = y2\n            # Compute distance in rows\n            d = abs(x1 - x2)\n            # Compute distance in columns\n            d = abs(y1 - y2)\n            # If we have to do sorting, sort first\n            if d < d_min:\n                lst[j][1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols = []\n    for row in lst:\n        if row[0] == x[0]:\n            rows.append(row[1:])\n        elif row[0] == x[1]:\n            cols.append(row[1:])\n    return [(row[0], row[1]) for row in rows]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [(x, y) for x, y in lst]\n    lst.sort()\n    lst = [(row, col) for (row, col) in lst]\n    row, col = lst[0]\n    for i, row in enumerate(lst[1:]):\n        for j, col in enumerate(lst[i+1:]):\n            if row == col:\n                lst.remove(i, 1)\n                lst.remove(j, 1)\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Find x in lst\n    return max([len(i) for i in lst if i[0] == x])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.tolist() \n    print(lst)\n    if len(lst) < 2:\n        print(\"lst is empty, cannot compute\")\n        return []\n    lst = lst[1:]\n    for i, j in enumerate(lst):\n        if j == x and i >= len(lst) - 1:\n            lst.pop(i)\n            lst.pop(i - 1)\n            lst.pop(i - 2)\n            lst.pop(i - 3)\n            lst.pop(i - 4)\n            lst.pop(i - 5)\n            lst.pop(i - 6)\n            lst.pop(i - 7)\n            lst.pop(i - 8)\n            lst.pop(i - 9)\n            lst.pop(i - 10)\n            lst.pop(i - 11)\n            lst.pop(i - 12)\n            lst.pop(i - 13)\n            lst.pop(i - 14)\n            lst.pop(i - 15)\n            lst.pop(i - 16)\n            lst.pop(i - 17)\n            lst.pop(i - 18)\n            lst.pop(i - 19)\n            lst.pop(i - 20)\n            lst.pop(i - 21)\n            lst.pop(i - 22)\n            lst.pop(i - 23)\n            lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [x[0] for x in lst]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Take the x and row indexes of lst and return the indexes\n    # in lst, that x corresponds to\n    lst = [x for x in lst if x in lst]\n    if len(lst)!= len(x):\n        raise TypeError('lst: {}, x: {}'.format(lst, x))\n    return lst[1:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    coordinates = []\n    def get_coordinate(x):\n        \"\"\"\n        Given integer x, return tuple of coordinates (row, columns).\n        \"\"\"\n        return coordinates.pop(0)\n    def sort_coordinates(x):\n        \"\"\"\n        Given coordinate x, return tuple of coordinates (row, columns).\n        \"\"\"\n        # Arrange coordinates by rows in ascending order.\n        for i in range(len(x) - 1, -1, -1):\n            coordinates.append((i+1, i))\n        # Arrange coordinates of the row by columns in descending order.\n        for j in range(len(x) - 1, -1, -1):\n            coordinates.append((j+1, j))\n    if len(lst) == 0:\n        return [(None, None)]\n    coordinates = sorted(coordinates, key=get_coordinate)\n    return [(x, i) for i, x in enumerate(coordinates)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    x = int(x)\n    \n    if len(lst) == 0:\n        return [(x, None)]\n        \n    rows = []\n    column = 0\n    for row in lst:\n        rows.append([column, 0])\n        \n        if row[0] == x and row[1] == x and row[2] == x and row[3] == x:\n            column += 1\n    \n    if len(lst) > 1:\n        return rows\n    \n    return [(x, column) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    ret = []\n    n = len(lst)\n    for row in range(0, n):\n        col = 0\n        for row in lst:\n            for col in range(0, len(row)):\n                if row[col] == x:\n                    ret.append([col, row[col]])\n            col += 1\n        if col == n:\n            ret.append([-1, -1])\n    return ret", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if lst is None:\n        return []\n    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    start = 0\n    for row in lst:\n        for col in row[0]:\n            if col == x:\n                return [(row[1], row[0])]\n    if len(lst) > 1:\n        return [(0, 0), (1, 1), (2, 2), (3, 3)]\n    return [(0, 0)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def sort_rows(row):\n        \"\"\"\n        Sort coordinates by rows in ascending order.\n        Also, sort coordinates of the row by columns in descending order.\n        \"\"\"\n        \n        col = 0\n        row_map = {}\n        for x in row:\n            col += 1\n            row_map[col] = row[0]\n            for x in row:\n                row_map[x[0]] = x[0] + x[1]\n        \n        if len(row_map)!= 2:\n            raise ValueError(\"Colours not equal, must be two.\")\n        \n        sort_cols(row_map)\n        \n        return row_map\n    \n    \n    def sort_cols(col_map):\n        \"\"\"\n        Sort coordinates by columns in ascending order.\n        Also, sort coordinates of the row by rows in descending order.\n        \"\"\"\n        \n        col = 0\n        row_map = {}\n        for x in col_map:\n            col += 1\n            row_map[col] = col_map[x[0]]\n            for y in col_map[x[0]][x[1]]:\n                row_map[col] = row_map[col] + y\n                for x in col_map[x[0]][x[1]][x[2]]:\n                    row_map[col] = row_map[col] + x[0]\n        if len(row_map)!= 2:\n            raise ValueError(\"Colours not equal, must", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not isinstance(lst, (list, tuple)):\n        raise TypeError('get_row expects list as argument')\n\n    x1, y1 = None, None\n    x2, y2 = None, None\n    for i, t in enumerate(lst):\n        if isinstance(t, tuple):\n            x = tuple(get_row(t, i))\n            x2, y2 = x\n            x1, y1 = i, 0\n        else:\n            x = t\n            x2, y2 = x\n            x1, y1 = i, t\n\n    return (x1, y1), x2, y2", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        print('get_row(2,1) failed')\n        raise ValueError('list length is incorrect')\n\n    first = lst[0]\n    last = lst[-1]\n    rows = [first[1] for _ in range(first[1])]\n    columns = [last[1] for _ in range(last[1])]\n    \n    #find x in the first row\n    first_row = int(first[0])\n    for x in range(first_row, first[0] + columns[0]):\n        if first[0] + x + columns[0] == first[0]:\n            return rows + [(x, first[0] + x + columns[0])]\n    \n    #find x in the last row\n    last_row = int(last[0])\n    for x in range(last_row, last[0] + columns[0]):\n        if last[0] + x + columns[0] == last[0]:\n            return rows + [(x, last[0] + x + columns[0])]\n    \n    #now sort rows by columns in descending order\n    rows.sort(key=lambda x: x[0])\n\n    #and sort columns by rows in ascending order\n    columns.sort(key=lambda x: x[1])\n\n    return rows + columns", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    rows = sorted(lst, key=lambda x: x[1])\n    columns = sorted(lst, key=lambda x: x[0], reverse=True)\n    rows_ind = [i[0] for i in rows]\n    columns = [i[1] for i in columns]\n    for i in range(len(lst)):\n        if x < lst[i][0] or x > lst[i][1]:\n            print('Wrong Index: ', i, lst)\n            break\n        else:\n            row = get_row(lst, lst[i][0])\n            columns.append(row[0])\n            row = get_row(lst, lst[i][1])\n            columns.append(row[1])\n\n    return columns, rows_ind", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x + 1, y) for (x, y) in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # we use the row iterator to iterate over the entire list\n    # and build a list of tuples, [(x1, y1), (x2, y2)...]\n    # and then sort the tuples by rows in ascending order.\n    lst = lst.copy()\n    if len(lst) > 0:\n        row = []\n        for i, row in enumerate(lst):\n            if len(row)!= 1:\n                raise Exception('Error, row list must have 1 entry, but there is '\n                                 'row list with size %d' % len(row))\n            row[0] = i\n            row = row[1:]\n        \n        lst = sorted(lst, key=lambda x: x[0]);\n        return lst\n        \n    # if row is the same for all rows, use the iterator's next method to\n    # get the next row and return it.\n    return next(lst)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(get_row(lst, i) + x) for i in range(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get the row\n    row = [x[0] for x in lst]\n    # get the column\n    column = [x[1] for x in lst]\n    \n    # sort in ascending order\n    for x in row:\n        if x[0] > column[0]:\n            return [(x[0], x[1])]\n    # sort in descending order\n    for x in row:\n        if x[0] < column[0]:\n            return [(x[0], x[1])]\n    \n    # return tuple\n    return [(i, j) for i in range(len(row)) and j in range(len(column))]\n    \n    # Example 1\n    lst = [\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ]\n    \n    x = 1\n    while x < len(lst):\n        get_row(lst, x)\n        x += 1\n    \n    return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    # Example 2\n    lst = [\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # We use a dictionary to store the row to coordinate tuple\n    row = dict(zip(lst[1:], lst))\n    x = int(x)\n    num_cols = len(row)\n    if x == 0:\n        return tuple(row)\n    if num_cols > 1:\n        if x < len(lst) - 1:\n            y, x = get_row(lst, x - 1)\n        else:\n            y, x = get_row(lst[:-1], x - 1)\n        return tuple([y, x])\n    if x < len(lst):\n        y, x = get_row(lst, x)\n    else:\n        y, x = tuple([lst[0]])\n    return tuple([row[x] for x in y])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    keys = set(lst)\n    while keys:\n        #take key that is the most common value in keys\n        keys.remove(keys.pop(0))\n        #set up column tuple\n        col = dict((k, v) for k, v in keys)\n        #create row tuple\n        row = [(col[x], col[y]) for x, y in col.items()]\n        #sort coordinates initially by rows in ascending order\n        rows = sorted(row, key=lambda x: x[0])\n        #sort coordinates of the row by columns in descending order\n        cols = sorted(row, key=lambda x: x[1])\n        #add column and row tuples\n        lst.append(row + cols)\n        #return tuple of coordinates of each row\n        return (tuple(row), tuple(cols))\n    #raise an exception with an error message\n    raise ValueError(\"Can't find a row for value \" + str(x) + \" in list \" + lst)\n\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [get_row(lst, x) for x in lst]\n    rows.sort()\n    return rows[x:x+len(lst)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #list of tuples, [(x1, y1), (x2, y2)...]\n    #sorted coordinates of the row by columns in descending order\n    n = len(lst)\n    tmp = []\n    for i in range(0, n):\n        if i == 0 or i == len(lst)-1:\n            continue\n        tmp.append((lst[i-1][-1], lst[i-1][-1]))\n    #sort coordinates of the row by rows in ascending order\n    if i == 0:\n        tmp.reverse()\n    #sort coordinates of the row by columns in descending order\n    if i == len(lst)-1:\n        tmp.reverse()\n    return tmp", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    cols = x - 0\n    rows = x + 1\n    return [(col, row) for col, row in zip(cols, rows)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    cols = 0\n    rows = []\n    for row in lst:\n        for col in row.keys():\n            if col < len(lst):\n                if col in cols:\n                    cols += 1\n                else:\n                    rows.append([row, col])\n    # sort first by rows\n    if cols:\n        rows.sort(key=lambda row: row[0])\n        rows = sorted(rows, key=lambda row: -row[1])\n    # sort second by columns\n    if cols:\n        rows.sort(key=lambda row: -row[0])\n        rows = sorted(rows, key=lambda row: -row[1])\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # print('get_row', lst, x)\n    # print('get_row', x, len(lst))\n    lst = lst[0:len(lst)]\n    x = x[:len(lst)]\n    # print(lst)\n    # print(x)\n    if len(lst) == 1:\n        return [(x[0], x[1])]\n    elif len(lst) > 1:\n        return [(get_row(lst[1:], x), get_row(lst[:-1], x)) for x in lst]\n    else:\n        # print('get_row', x, len(lst))\n        # print(lst)\n        return [(x, x) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # remove the leading empty element\n    lst = list(lst)[1:]\n    # assume that the first element is the current row\n    x = 1\n    # iterate through the row - from the left\n    row = 0\n    while row < len(lst):\n        # find the coordinates of the first column\n        if x == 1:\n            # find the coordinates of the first row\n            cols = 0\n        else:\n            cols = x - 1\n            # iterate through the remaining columns\n            for i in range(cols):\n                # find the coordinates of the next row\n                if x == x1:\n                    # find the coordinates of the last column\n                    cols = len(lst)\n                else:\n                    cols = x - 1\n                # iterate through the remaining rows\n                for j in range(cols):\n                    if i == j:\n                        # the current row is finished, return the coordinates\n                        return row, cols\n                # find the coordinates of the next row\n                if x == x1:\n                    # find the coordinates of the last column\n                    cols = len(lst)\n                else:\n                    cols = x - 1\n                # iterate through the remaining rows\n                for k in range(cols):\n                    if i == k:\n                        # the current row is finished, return the coordinates\n                        return row, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get the coordinates of the first row\n    rows = list(lst)\n    first = rows.pop(0)\n    for i, row in enumerate(lst):\n        if i == 0:\n            if row == first:\n                return row\n        elif i == len(lst) - 1:\n            return row\n    # get the coordinates of the second row\n    second = rows.pop(0)\n    for i, row in enumerate(lst):\n        if i == len(lst) - 1:\n            return row\n        elif row == second:\n            return row\n    # return None\n    raise IndexError('row not found')", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def _find_key(lst, key):\n        \"\"\"\n        Returns tuple of integers, which correspond to a given key.\n        \"\"\"\n        # Don't care about consecutive keys.\n        if len(lst) == 1:\n            return lst[0]\n        for i, element in enumerate(lst):\n            if element[0] == key:\n                return [element[1]]\n        return None\n\n    lst = []\n    for element in lst:\n        if _find_key(element, x):\n            lst.append([element])\n    lst.sort(key=lambda x: x[0])\n    lst = [(x[0], x[1]) for x in lst]\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return lst.copy()", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    #x = int(x)\n    #print(x)\n    #lst = []\n    #for i, x in enumerate(lst):\n        #print(lst,i,x)\n        #print(x.split(\",\"))\n        #print(x.split())\n        lst = [x[i:i+x] for i in x.split()]\n        #lst.sort()\n        #print(lst)\n        #lst.sort()\n        #print(lst)\n        return [(get_row(lst, x), get_row(lst[1:], x)) for x in lst]\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [(x, lst[x-1].pop()) for x in lst]\n    col = 0\n    for i in lst:\n        col += 1\n        while col < len(lst):\n            if lst[i][0] < lst[i-1][0]:\n                col += 1\n            if lst[i][1] < lst[i-1][1]:\n                col += 1\n            if lst[i][2] < lst[i-1][2]:\n                col += 1\n    return lst[col:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Set up variables\n    rows = []\n    columns = []\n    x = 0\n    # Loop through the list, in rows, until there are no more coordinates\n    while x < len(lst) and lst[x][0] > x + 1:\n        # If the next coordinates is greater than the previous coordinates,\n        # we need to add it to the list\n        if lst[x][1] > lst[x][0]:\n            rows.append(lst[x][1:])\n            columns.append(lst[x][1:])\n            x = lst[x][0]\n            lst[x] = lst[x][1:]\n        # Else, the coordinates are equal, and we can remove the coordinates\n        else:\n            rows.append(lst[x][1:])\n            columns.append(lst[x][1:])\n            x = lst[x][0]\n    # Now, sort the coordinates\n    rows.sort()\n    columns.sort()\n    return rows, columns", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [(len(x) - 1, x[1:]) for x in lst]\n    rows.sort(key=lambda x: x[0])\n    cols = [(len(x) - 1) for x in lst]\n    cols.sort(key=lambda x: x[0])\n    rows, cols = zip(rows, cols)\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    try:\n        return zip(*map(lambda x : int(x), lst))\n    except ValueError:\n        return None", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    n = len(lst)\n    if x < 0:\n        return lst\n    x = int(x)\n    if x == 0:\n        return lst\n\n    xlist = [get_row(lst, x) for x in xrange(n)]\n    return [x for i, x in enumerate(xlist)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def is_row(l):\n        return 0 < len(l) < 3\n    \n    def is_column(l):\n        return 0 < len(l) < 2\n    \n    def is_correct(l):\n        return 1 <= len(l) < 3\n    \n    def is_valid(l):\n        for row, column in zip(l, [row[0] for row in l]):\n            if column == 1 or column == 2:\n                return False\n        return True\n    \n    def solve(l, x):\n        if len(l)!= 3:\n            return False\n        if is_row(l):\n            return solve_row(l, x)\n        if is_column(l):\n            return solve_column(l, x)\n        if is_correct(l):\n            return solve_correct(l, x)\n        return False\n    \n    def solve_row(l, x):\n        if len(l)!= 2:\n            return False\n        if is_valid(l):\n            return solve(l, x[0])\n        if is_correct(l):\n            return solve(l, x[1])\n        return False\n    \n    def solve_column(l, x):\n        if len(l)!= 1:\n            return False\n        if is_valid(l)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def swap(lst, x):\n        if isinstance(x, list):\n            x = [swap(lst[x], x) for x in x]\n        else:\n            x = [swap(x, lst[x]) for x in x]\n        return x\n    \n    lst = list(lst)\n    lst = [(row, cols) for (row, cols) in lst]\n    lst = sorted(lst)\n    tmp = [(row, cols) for (row, cols) in lst]\n    tmp = sorted(tmp, key=lambda x: x[1], reverse=True)\n    tmp = [(row, cols) for (row, cols) in tmp]\n    tmp = sorted(tmp, key=lambda x: x[1], reverse=False)\n    if len(tmp) == 1:\n        tmp = tmp[0]\n    if len(tmp) > 1:\n        tmp = tmp[1]\n    return tmp\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = min(list(x))\n    x = max(list(x))\n    x = 1 if x == 0 else min(x, len(lst)-1)\n    if x == 0:\n        return []\n    lst = list(lst)\n    lst.append(x)\n    for i in range(len(lst)):\n        if i == x:\n            return lst[:i]\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise ValueError('Input must be a list')\n\n    x = int(x)\n    if x < 0:\n        return [(0, 0), (-1, 1), (-1, -1)]\n    if x > len(lst[0]):\n        return [(0, 0), (1, -1), (1, 1)]\n\n    # TODO: Calculate column totals\n    # See notes on column totals\n    cur = lst[0]\n    cur = [get_row(cur, x) for x in cur]\n    return cur", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(get_row(lst, x)[0], get_row(lst, x)[1]) for x in xrange(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # TODO: generate the correct indexes\n    \n    def get_index(lst, x):\n        \"\"\"\n        Given lst, and integer x, return the index in the\n        list, which is the index of the tuple, that contains x.\n        \"\"\"\n        return [row for row in lst if row[0] == x][0]\n    \n    def sort_rows(lst):\n        \"\"\"\n        Given a list of tuples, sort the coordinates in the list\n        in ascending order.\n        \"\"\"\n        # print(\"sorting rows...\")\n        for row in lst:\n            row2 = []\n            for col in row:\n                row2.append(col)\n                if col not in row2:\n                    row2.append(row[0])\n                    row2.append(row[1])\n            lst = tuple(row2)        \n        return lst\n    \n    def sort_cols(lst):\n        \"\"\"\n        Given a list of tuples, sort the coordinates in the list\n        in descending order.\n        \"\"\"\n        # print(\"sorting columns...\")\n        for row in lst:\n            row2 = []\n            for col in row:\n                row2.append(col)\n                if col not in row2:\n                    row2.append(row[0])\n                    row2.append(row[1])\n            lst = tuple(row2)\n        return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # some logic to find the coordinates, at a given position in the list\n    y1, y2 = get_coordinate(lst, x)\n    return (y1, y2)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return _get_row(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Determine the left-most index of x which is in the list.\n    i = 0\n    for x in lst:\n        if i > x.index(x):\n            i = x.index(x)\n    # Return tuple of coordinates\n    return tuple(x[i:]) for i in range(0, len(lst), 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < len(lst):\n        y = x\n        for k in range(len(lst)):\n            if lst[k][1] == x:\n                y = lst[k][0]\n                break\n            if lst[k][0] == y:\n                y = lst[k][1]\n                break\n    return [(x, y) for x in lst if x > 0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # rows\n    lst = [x for x in lst if x > 0]\n    \n    # index of x in lst\n    indx = 0\n    \n    # coordinates\n    coordinates = []\n    \n    # sort coordinates by rows\n    # coordinates[0:1] are first coordinate of row\n    coordinates.sort(key=lambda x: x[0])\n    \n    # sort coordinates by columns\n    # coordinates[0:3] are first coordinate of column\n    coordinates.sort(key=lambda x: x[2])\n    \n    # sort coordinates by rows\n    # coordinates[0:1] are first coordinate of row\n    coordinates.sort(key=lambda x: x[1])\n    \n    # sort coordinates by columns\n    # coordinates[0:3] are first coordinate of column\n    coordinates.sort(key=lambda x: x[3])\n    \n    # find indices of x in lst\n    indx = 1\n    \n    # for each row, find coordinates\n    for row in lst:\n        indx = indx + 1\n        \n        for col in row[0:indx]:\n            coordinates.append(col)\n    \n    # return coordinates\n    return coordinates", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < len(lst):\n        return list(lst[x])\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 1:\n        lst = lst[1:]\n    if len(lst) == 1:\n        return [(0, 0)]\n    else:\n        # In this case, lst has a single row\n        return lst\n    \n    if not lst:\n        return []\n    \n    if isinstance(lst[0], tuple):\n        x = 0\n    elif len(lst[0]) == 1:\n        x = 0\n    else:\n        x = len(lst)\n    \n    if isinstance(lst[-1], tuple):\n        y = 0\n    elif len(lst[-1]) == 1:\n        y = 0\n    else:\n        y = len(lst)\n    \n    if x!= len(lst) and y!= len(lst[0]):\n        raise ValueError(\"Invalid number of columns\")\n        \n    return [(i * x, i * y) for i in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    try:\n        return [\n            (lst[x], lst[x] + lst[y]) for (x1, y1), (x2, y2) in zip(lst, x)]\n    except IndexError:\n        raise IndexError(\"Row not found in list\")", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    result = []\n    for i, row in enumerate(lst):\n        if x == len(row):\n            return result\n        for j, column in enumerate(row):\n            if i == j:\n                continue\n            if column < x and column >= 0:\n                result.append([(i, j)])\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    tmp = []\n    for i, row in enumerate(lst):\n        for j in range(len(row)):\n            tmp.append((i, j))\n    return tmp\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.tolist()\n    lst = [(x, lst[i]) for i in lst]\n    lst.sort(key=lambda x: x[1], reverse=True)\n    lst.sort(key=lambda x: x[1], reverse=True)\n    return [(x, lst[i]) for i in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(list(map(lambda x: x[0], lst)), list(map(lambda x: x[1], lst))), ]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return [(0, 0), (1, 0), (0, 1), (0, 0)]\n    y = [lst[0]]\n    x1 = y[0]\n    y1 = y[1]\n    x2 = y[1]\n    y2 = y[1]\n    x = x[0]\n    y = x[1:]\n    x = [y1, x1]\n    y = [y2, x2]\n    return [(x1, y1), (x2, y2)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) < 2 or len(lst) > 4:\n        raise ValueError(\"Invalid input, minimum input must be at least 2 rows and at most 4 rows.\")\n    lst = list(lst)\n    x = 0\n    for row in range(len(lst[0])):\n        if lst[0][row] == x:\n            x += 1\n            if x > len(lst[0]):\n                raise ValueError(\"Invalid input, input must be a valid row of length %d.\" % len(lst[0]))\n        else:\n            lst[0][row] = get_row(lst, lst[0][row])\n    lst[0] = tuple(lst[0])\n    lst[1] = tuple(lst[1])\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) > 1 and x > 0:\n        lst.sort(key=lambda x: x[0])\n        for i, r in enumerate(lst):\n            if x > 0:\n                lst[i+1] = [x[i-1]] + r\n            else:\n                lst[i+1] = r\n    else:\n        lst = lst[0]\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst[:]\n    if len(lst)!= 1:\n        raise ValueError(\"lst must be a list of at least 1 element!\")\n    if len(lst[0]) == 1:\n        return [(x, x) for x in lst]\n    x = lst[0][1]\n    return [x for i, x in enumerate(lst) if x == x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols = []\n    for i, row in enumerate(lst):\n        x = i - 1\n        for j in range(x, len(lst), 1):\n            cols.append(j)\n            rows.append(i)\n        cols.reverse()\n        rows.reverse()\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= len(x):\n        raise ValueError(\"Number of rows and number of columns is different.\")\n    return [(get_row(lst, x[i:i+1]) for i in xrange(len(lst)))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    assert isinstance(lst, list)\n    assert len(lst) == len(x)\n    column_pos = 0\n    row_pos = 0\n    for i in range(len(x)):\n        y = 0\n        for j in range(len(lst[i])):\n            if x[i] == x[j]:\n                y += 1\n            else:\n                row_pos += 1\n        if y == 1:\n            column_pos += 1\n        else:\n            row_pos += 1\n    if column_pos == 0:\n        raise ValueError(\"Invalid column position\")\n    if row_pos == 0:\n        raise ValueError(\"Invalid row position\")\n    return [(row_pos, column_pos) for i, j in zip(lst, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    nrows = len(lst[0])\n    ncols = len(lst[1])\n    if ncols == 0:\n        ncols = 1\n    return [(tuple(i) for i in lst if i > 0) for i in xrange(nrows)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    coordinates = []\n    index = 0\n    column = 0\n    for row in lst:\n        column = row[0]\n        coordinates.append((column, index))\n        index += 1\n    return coordinates", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Make sure x is valid\n    assert x >= 0\n    assert x <= len(lst)\n    assert len(lst) == x + 1\n\n    idx = 0\n    assert len(lst) == x\n\n    for i in xrange(len(lst)):\n        assert idx < len(lst[idx])\n        if idx == len(lst[idx]):\n            return lst[idx]\n        idx += 1\n\n    return lst[:idx - 1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # the array we will be returning from this method\n    lst_arr = []\n    # the array of tuples we will be returning from this method\n    lst_tuples = []\n    \n    # the row and column indexes\n    lst_row = 0\n    lst_col = 0\n    \n    # the array of values to be compared\n    lst_arr_vals = []\n    \n    # the last row coordinate of the column\n    lst_last_row = 0\n    \n    # the last column coordinate of the row\n    lst_last_col = 0\n    \n    # the index of the last value in the array\n    lst_last_idx = 0\n    \n    # the index of the first value in the array\n    lst_first_idx = 0\n    \n    # the indices of the first coordinate of the last value in the array\n    lst_first_val_idx = lst_last_idx + lst_last_col + 1\n    lst_first_val_idx = lst_first_val_idx - lst_last_col - 1\n    \n    # the indices of the last coordinate of the first value in the array\n    lst_last_val_idx = lst_first_val_idx + lst_first_col - 1\n    lst_last_val_idx = lst_last_val_idx + 1\n    \n    # the indices of the first coordinate of the last value in the array\n    lst_first_val_idx = lst_first_val_idx - lst_first_col - 1\n    \n    # the indices", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = list(lst)\n    if len(lst) == 0:\n        return [(0, 0)]\n    coord = []\n    i = 0\n    num_cols = len(lst) - 1\n    if num_cols == 0:\n        return [(0, 0)]\n    for row in range(i, num_cols):\n        if i + 1 == num_cols:\n            i = 0\n            coord.append(lst[i])\n            i = 1\n    return coord", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get values\n    vals = lst\n    if len(vals) > 1:\n        vals = vals[1:]\n    if len(vals) < 1:\n        raise ValueError('Empty list passed to get_row()')\n    if len(vals) == 0:\n        return []\n    if type(vals) is tuple:\n        return [get_row(val, x) for x in vals]\n    if type(vals) is list:\n        return [(get_row(val, x), get_row(val[::-1], x)) for x in vals]\n    if type(vals) is dict:\n        keys = vals.keys()\n        vals = vals.values()\n        if len(keys)!= len(vals):\n            raise ValueError('Incorrect keys provided to get_row()')\n        return [(get_row(key, val[x]), get_row(val[::-1], val[x]))\n                       for key, val in zip(keys, vals)]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    results = []\n    # Create a list of tuples (row, column), each containing a column\n    # of coordinates, and row of coordinates.\n    for i, row in enumerate(lst):\n        row = list(row)\n        column = x - i\n        for j, c in enumerate(column):\n            if j!= 0:\n                row[j] = c\n            else:\n                results.append((row, column))\n\n    # If the row coordinates are sorted in ascending order, sort\n    # the coordinates of the column.\n    if type(row) == list:\n        for row2, col2 in zip(row, column):\n            results2 = []\n            for row1, col1 in zip(row, column):\n                results2.append((row1, col1))\n            for row1, col1 in zip(row, column):\n                results.append(results2)\n\n    # If the row coordinates are sorted in descending order, sort\n    # the coordinates of the column.\n    if type(row) == list:\n        for row2, col2 in zip(row, column):\n            results2 = []\n            for row1, col1 in zip(row, column):\n                results2.append((row2, col1))\n            for", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # make sure the numbers in lst are integers\n    lst = [int(n) for n in lst]\n    \n    # zero the input, so we can work with it later\n    lst = [(0,0) for n in lst]\n    \n    # loop over lst and make sure that each row contains exactly x rows\n    for row,column in enumerate(lst):\n        if len(column) < x:\n            raise ValueError(\"Number of columns must be greater than number of row\")\n        for k in range(len(column)):\n            if column[k] < x:\n                raise ValueError(\"Column has smaller number of rows\")\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # This assumes that the columns are already sorted\n    if len(lst)!= 2:\n        raise ValueError('Argument lst is not a list')\n    # This is the variable for the variable x\n    x = lst[0]\n    # List of tuples of ints\n    lst1 = [(i, j) for i, j in enumerate(x)]\n    # We need to do the same for the list lst\n    lst2 = [(x1, y1), (x2, y2)...]\n    # We need to do the same for the list lst1\n    lst3 = [(x1, y1), (x2, y2)...]\n    # For the first coordinate, we want to return the index of the row\n    idx = lst1[0][1]\n    # For the second coordinate, we want to return the index of the column\n    idx = lst2[0][2]\n    # For the third coordinate, we want to return the row and the columns\n    idx = lst3[0][3]\n    return [(idx, lst1[idx:idx + x]), (idx, lst2[idx:idx + x])]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # print(\"before get_row\")\n    # print(len(lst))\n    # print(len(x))\n    # print(len(lst[0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0][0]))\n    # print(len(x))\n    # print(len(x[0]))\n    # print(len(x[0][0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0][0]))\n    # print(len(lst))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0]))\n    # print(len(lst[0]))\n    # print(len(lst[0][0]))\n    # print(len(x))\n    # print(len(x[0]))\n    # print(len(x[0][0]))\n    # print(len(x[0][0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0]))\n    # print(len(lst[0][0][0]))\n    # print(len(lst[0][0][0]))\n    # print(len(lst[0]))\n    # print(len", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)==2:\n        return []\n    if lst[0]==lst[1]:\n        return [(lst[0], lst[2]) for lst in lst]\n    sort=lambda x,y: cmp(x[1],y[1])\n    for i in range(len(lst)):\n        if lst[i][0]==lst[i][1]:\n            return [(sort(lst[i][0],lst[i][1]),sort(lst[i][2],lst[i][3])) for lst in lst]\n    return [(lst[0], lst[1]) for lst in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        print(\"Need at least 2 arguments\")\n        return\n\n    if len(lst[0])!= 2:\n        print(\"Need at least two arguments\")\n        return\n    try:\n        # If lst[0] is not a list of tuples, or a list of tuples\n        # with a different number of columns, then it's not a 2D data\n        # matrix.\n        if not isinstance(lst[0], tuple):\n            lst = [lst[0]]\n\n        # Get column length from each tuple\n        col = len(lst[0][1])\n        if col!= 2:\n            print(\"Column length not equal to 2\")\n            return\n\n        # Get row length from each tuple\n        row = len(lst[0][0])\n        if row!= 2:\n            print(\"Row length not equal to 2\")\n            return\n\n        # Convert tuple into a list of lists\n        lst = [get_row(lst, j) for j in range(row)]\n\n        # Sort rows by columns in descending order.\n        lst.sort(key=lambda tup: tup[0], reverse=True)\n        # Sort rows by columns in ascending order.\n        lst.sort(key=lambda tup: tup[0], reverse=False)\n\n        # Get index of each column.\n        col_index = [0] * col\n        for i", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= len(x):\n        raise ValueError(\"lst and x must be of the same size\")\n    if len(lst)!= len(x):\n        raise ValueError(\"lst and x must be of the same size\")\n    if len(lst) % 2!= 0:\n        raise ValueError(\"lst and x must be of the same size\")\n    if not lst:\n        return []\n    if len(lst)!= len(x):\n        raise ValueError(\"lst and x must be of the same size\")\n    return [(get_row(lst[1:], x[1:]), y[1:]) for x, y in zip(lst[1:], x[1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # create a list of tuples, which is similar to a matrix,\n    # and each row will contain a different number of columns\n    lst = []\n    for row in lst:\n        lst.extend(row)\n        lst.sort(key=lambda x: x[0], reverse=True)\n    # assume that each row has the same number of coordinates\n    lst.extend([(x[0], x[1]) for x in lst])\n\n    # start with rows sorted by row, in ascending order\n    for row, col in lst:\n        if row > 0:\n            lst.insert(row - 1, [col, 0])\n        else:\n            lst.insert(row, [col, 0])\n\n    # end with rows sorted by column, in descending order\n    for row in range(len(lst)):\n        if row > 0:\n            lst.insert(row - 1, [lst[row - 1][1]])\n        else:\n            lst.insert(row, [lst[row - 1][1]])\n\n    # return the list\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    result = []\n    for k in range(len(lst)):\n        temp = []\n        for l in lst[k]:\n            for i in range(len(l)):\n                if (i > 0) and (i <= len(l)):\n                    temp.append(get_row(l, i))\n        if len(temp) > 0:\n            result.append(temp)\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    t = []\n    num = len(lst[0])\n    for i in range(0, num):\n        for j in range(i, num):\n            if lst[i][j] > lst[j][j + 1:]:\n                t.append((lst[i][j], lst[j][j + 1]))\n    return t", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    def _sort_rows(lst):\n        \"\"\"\n        For each row in lst, sort by rows in ascending order.\n        \"\"\"\n        r = 0\n        for row in lst:\n            if r < len(row):\n                lst[r].sort(key=lambda x: x[1], reverse=True)\n            else:\n                lst[r] = row\n    return sorted(lst, key=_sort_rows, reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst)!= 2:\n        raise ValueError('len(lst)!= 2')\n\n    if len(lst) == 2:\n        return lst\n    if lst[0].count(x) < len(lst):\n        return lst[1:]\n    if len(lst[0])!= len(lst[0][x]):\n        return lst[1:]\n    if len(lst[0][x])!= len(lst[0][x][x]):\n        return lst[1:]\n    return [(i, x) for i in range(len(lst[0][x]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    return [(get_row(lst, x)[0][0], get_row(lst, x)[0][1]) for x in xrange(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Returns tuples of coordinates with an entry for each tuple, starting from 0\n    coord_tuples = []\n    for coord, row in lst:\n        # The row is sorted by columns in ascending order.\n        coord_tuples.append([int(row[0]), int(row[1])])\n    coord_tuples.sort(reverse=True)\n    # Sort coordinates of each row by their columns.\n    coord_tuples = coord_tuples[::-1]\n    return coord_tuples", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i = 1\n    r = 0\n    c = 0\n    while i < len(lst):\n        if lst[i][0] > x:\n            r = i\n            x = lst[i][0]\n        elif lst[i][0] == x:\n            c = i\n            i += 1\n        else:\n            return lst, [x, lst[i+1]]\n    return [(r, c) for (r, c) in zip(lst[r], lst[c:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.tolist()\n    x = x.tolist()\n    if len(lst) > len(x):\n        raise IndexError('Out of memory.')\n    rows = [(get_row(lst, i)) for i in range(len(lst))]\n    if not x[0] in rows[-1]:\n        return lst\n    columns = [(get_row(x, j)) for j in range(len(x))]\n    return rows + columns", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst.sort()\n    lst = [(x[0], x[1]) for x in lst]\n    if len(lst) == 1:\n        return lst\n    return [(x[0], x[1]) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # For a data structure with nested lists,\n    # row() may return a string containing multiple tuples.\n    # For example, row([1, 2, 3, 4, 5]) -> [\"(1,2,3,4,5)\"]\n    lst = [lst]\n    x = x - 1\n    if len(lst) > 1:\n        lst.pop(0)\n    # sort coordinates by rows in ascending order\n    rows = map(lambda x: x[0], lst)\n    rows.sort()\n    # sort coordinates by columns in descending order\n    cols = map(lambda x: x[1], lst)\n    cols.sort()\n    # Return list of tuples, [(x1, y1), (x2, y2)...]\n    return rows, cols", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def flatten(lst, x):\n        n = len(lst)\n        return [row for row in lst if row]\n\n    x = x\n    lst = lst\n    return flatten(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = [get_row(x, i) for i in lst]\n    if len(lst) == 0:\n        return lst\n    return sorted(lst, key=lambda x:x[0])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # The initial sort is by columns, in descending order.\n    # The sort of the rows, is by rows, in ascending order.\n    # Lastly, the sort of the coordinates is by rows, in descending order.\n    # Note that the tuples are sorted so that the first coordinate is 0.\n    return sorted(lst, key=lambda tup: tup[0], reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    cols = []\n    rows = [[] for _ in range(len(lst))]\n    for i, row in enumerate(lst):\n        cols.append(len(row))\n        for j, col in enumerate(row):\n            if j!= col:\n                rows[i][j] = col\n                row = row[:j]\n            else:\n                rows[i][j] = 0\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst[:]\n    x = int(x) - 1\n    for r in range(len(lst)):\n        for c in range(len(lst[r])):\n            if lst[r][c] == x:\n                return [(lst[r][c], lst[r][c])]\n    \n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [x[0] for x in lst]\n    cols = [len(x) for x in lst]\n    sorted_cols = [sorted(x, key=lambda x: x[0]) for x in lst]\n    rows_sorted = [sorted(row, key=lambda x: x[1]) for row in sorted_cols]\n    return [(row, col) for (row, col) in zip(rows_sorted, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst.split(',')\n    lst = [x for x in lst if x]\n    lst = [x for x in lst if not x]\n    lst = [(x[0], x[1]) for x in lst]\n    lst = [(x[0], 0) for x in lst]\n    lst = [(x[0], x[1]) for x in lst]\n    lst = [(x[0], x[1]) for x in lst]\n    x = 0\n    for t in lst:\n        x += t[0]\n        if x > len(lst):\n            break\n    return [(x, i) for i in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    L = list(lst) # ensure they are in list form\n\n    if not isinstance(x, int):\n        raise TypeError, \"x is not an integer\"\n\n    if len(L)!= len(x):\n        raise ValueError, 'length of L!= len(x)'\n\n    i = 0\n    for row in L:\n        for col in row[:-1]:\n            if i + 1 >= len(x):\n                break\n            else:\n                if x[i + 1] < col:\n                    return L[i + 1:] + [(i + 1, col)]\n        i += 1\n\n    return L + [(i + 1, col) for i, col in enumerate(x)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    \n    # define new variables: x = [(x1, y1), (x2, y2)...]\n    x = []\n    # define len(lst) and length(lst) of lst\n    lst_len = len(lst)\n    # if lst_len == 0:\n    #     return x\n    if len(lst) == 0:\n        return x\n    \n    if lst_len < 1:\n        return x\n    \n    # first x is the row number\n    x[0] = 0\n    # second x is the column number\n    x[1] = 0\n    # get coordinates from the first row, starting from 0\n    for y in lst:\n        # iterate through each column\n        for x in y:\n            # add x to x\n            x.append(x[0] + x[1] + 1)\n    \n    # sort the coordinates\n    x.sort(lambda x,y: cmp(x[0],y[0]))\n    x.sort(lambda x,y: cmp(x[1],y[1]))\n    # now sort the coordinates of the first row\n    x.reverse()\n    \n    # return x\n    \n    # define empty lists, to store the new coordinates: y = [(x1, y1), (x2, y2)...]\n    y = []\n    \n    # return empty list, because lst is already sorted", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    result = []\n    r = lst[0]\n    c = lst[1]\n    if x == 0:\n        result = [(r, c)]\n    elif len(lst) == 1:\n        result = [(r, c)]\n    elif len(lst) == 2:\n        result = [(r, c)]\n    elif len(lst) == 3:\n        result = [(r, c, lst[2])]\n    else:\n        result = []\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # map coordinates\n    y = []\n    x = []\n    for i in range(len(lst)):\n        x1 = lst[i][0]\n        y1 = lst[i][1]\n        if len(lst[i])==1:\n            y2 = i\n        else:\n            y2 = i+1\n            if y2>len(lst)-1:\n                y2 = len(lst)-1\n            x1 = x1+x1*y1\n            y1 = x1+y1*y1\n            y.append(x1)\n            x.append(y1)\n    # sort coordinates by rows first\n    y.sort()\n    x.sort()\n    # sort coordinates of the row by columns\n    y = sorted(y, key=lambda x: x[1], reverse=True)\n    x = sorted(x, key=lambda x: x[0], reverse=True)\n    return (y, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x1 = min(lst)\n    x2 = max(lst)\n    y1 = min(lst[x1:x2])\n    y2 = max(lst[x1:x2])\n    row = []\n    column = []\n    for i in range(len(lst)):\n        if y1 < lst[i] < y2:\n            row.append(i)\n            column.append(y1)\n            y1 = lst[i]\n        elif y2 < lst[i] < y2:\n            row.append(i)\n            column.append(y2)\n            y2 = lst[i]\n    return row, column", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get coordinates - (row, columns), starting with 0.\n    coord = [(row, col) for row, col in lst]\n    coord.sort()\n    return coord", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = lst + [(x, x) for x in x]\n    lst = sorted(lst, key=lambda x: x[0])\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    return [(i, j) for i, j in zip(lst, lst[1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    lst = [x for x in lst if x in x]\n    return [(get_row(lst, x), get_row(lst[1:], x)) for x in xrange(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 1:\n        if x == 1:\n            return lst[0]\n        else:\n            return [(get_row(lst, x - 1), get_row(lst, x + 1)),\n                           (get_row(lst, x - 1), get_row(lst, x + 2))]\n    elif len(lst) == 2:\n        if x == 2:\n            return [(get_row(lst, x - 1), get_row(lst, x + 1)),\n                           (get_row(lst, x - 1), get_row(lst, x + 2))]\n        else:\n            return [(get_row(lst, x - 1), get_row(lst, x + 1)),\n                           (get_row(lst, x - 1), get_row(lst, x + 2))]\n    else:\n        raise Exception('Invalid column range')\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    # Lists are sorted by row before columns\n    lst1 = sorted(lst, key=lambda x: x[0], reverse=True)\n    lst2 = sorted(lst1, key=lambda x: x[1], reverse=True)\n\n    # Split into smaller lists\n    lst1 = [get_row(lst1, x) for x in lst1[1:]]\n    lst2 = [get_row(lst2, x) for x in lst2[-1]]\n    # Group by row\n    lst1 = [(row, x) for row, x in lst1 if row]\n    lst2 = [(row, x) for row, x in lst2 if row]\n    \n    # Sort by row, then by column\n    lst1 = [(row, x) for row, x in lst1 if row]\n    lst2 = [(row, x) for row, x in lst2 if row]\n    \n    # Find indices of tuples in the list\n    # (row, columns) that are the same as x\n    # and return tuple of (x1, y1), (x2, y2)\n    lst3 = []\n    for row, tuple in lst1:\n        if tuple == x:\n            lst3.append((row, x))\n    for row, tuple in lst2:", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    print(\"[ ]\")\n    for i in range(len(lst)):\n        print(get_row(lst, x + i * len(lst)))\n    print(\"[ ]\")", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    for i in range(len(lst[0])):\n        x = lst[0][i]\n        if len(lst) > 1:\n            for j in range(len(lst)):\n                if lst[j][i] == x and lst[j+1][i] == y:\n                    return list(tuple(lst[j:j+1]))\n                \n    return None", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    i, j = 0, 0\n    r = {}\n    for i in lst:\n        i = i[0]\n        r[i] = r[i] + 1\n    for i in lst:\n        i = i[0]\n        r[r[i]] = i\n    for i in lst:\n        i = i[0]\n        r[r[i]] = i\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [get_row(lst, i) for i in xrange(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Create list of tuples\n    lst = []\n    for index, row in enumerate(lst):\n        lst.append(zip(row, range(index + 1, len(row))))\n\n    # Sort by rows in ascending order\n    lst.sort(key=lambda x: x[0], reverse=True)\n\n    # Sort by columns in descending order\n    lst.sort(key=lambda x: x[1], reverse=True)\n\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if isinstance(lst, collections.abc.Iterable):\n        lst = iter(lst)\n        if lst:\n            return [get_row(x, y) for x, y in zip(lst, lst[1:])]\n    else:\n        return [get_row(x, y) for x, y in zip(x, lst)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    t = []\n    k = 0\n    x = 0\n    while x:\n        k += 1\n        if k == len(lst) - 1:\n            t.append([(x, 0)])\n            x = 0\n        else:\n            x += 1\n            if x < len(lst):\n                if lst[k][0] == lst[k+1][0]:\n                    t.append([(x, lst[k][1])])\n                    x = lst[k][2]\n                else:\n                    t.append([(x, lst[k+1][1])])\n                    x = lst[k][2]\n        t.append([(x, 0)])\n        x = 0\n    return t", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    \n    lst = [lst]\n    x = x\n    columns_to_sort = []\n    columns_to_sort.append(0)\n    for i in range(len(lst)):\n        columns_to_sort.append(i+1)\n        \n    for row in range(len(lst)):\n        columns = columns_to_sort[row]\n        columns = sort_coordinates(columns)\n        if len(columns) < 1:\n            break\n        for column in columns:\n            # add x if it is not already there\n            if column not in lst:\n                lst.append(column)\n    return lst"]]