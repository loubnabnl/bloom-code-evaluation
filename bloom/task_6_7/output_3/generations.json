[["from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Init list to store parsed result\n    nested_parens = [0]\n\n    # Iterate over each character of the string\n    for char in paren_string:\n        if char == \"(\":\n            nested_parens.append(nested_parens[-1] + 1)\n\n        elif char == \")\":\n            nested_parens.pop()\n\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # There can be spaces around the parentheses.\n    # However, this will be caught in the next if statement.\n    if paren_string == \"\":\n        return []\n\n    # The first group can have spaces around the parentheses.\n    if paren_string[0] == \"(\" or paren_string[0] == \")\":\n        # Return the first group by itself.\n        return [int(paren_string)]\n\n    # Break the string into chunks, where each chunk is a single group surrounded by parentheses.\n    groups = paren_string.split()\n    # If there is a space between the first and second chunk, the first chunk will be returned by itself.\n    if groups[0].find(\" \")!= -1:\n        return [int(groups[0])]\n\n    # For each chunk, check if it is a valid nest of parentheses.\n    # If yes, add it to the list, else return the previous group.\n    result = []\n    for group in groups:\n        result += parse_nested_parens(group)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = []\n    for sub in paren_string.split():\n        if sub == '(':\n            nesting.append(nesting[-1] + 1)\n        elif sub == ')':\n            nesting.pop()\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Start from the inner most parenthesis and add the level of nesting each time we encounter a left paren.\n    nesting_levels = []\n    paren_string = paren_string.strip()\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            nesting_levels.append(i)\n        elif char == ')':\n            nesting_levels.pop()\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(','( ')\n    paren_string = paren_string.replace(')',') ')\n    paren_string = paren_string.replace('(','( ')\n    paren_string = paren_string.replace(')',') ')\n    parsed = paren_string.split(' ')\n    return [max([parse_nested_parens(paren) for paren in parsed]) for parsed in parsed]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string) == 0:\n        return []\n\n    return [max(parse_nested_parens(paren_string[i:]) + [paren_level]) for i, paren_level in enumerate(count_outer_plus_inner(paren_string))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [max([parse_nested_parens(paren) for paren in paren_string.split()]) for paren in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # For each nested group, the deepest level of nesting is the length\n    # of the longest sequence of closing parentheses following a sequence\n    # of opening parentheses. In the example above, this is 3, 1, 3 and 2 respectively.\n\n    parsed_list = []\n    stack = []\n    current_level = 0\n    for char in paren_string:\n        if char == '(':\n            stack.append(current_level)\n            current_level += 1\n        elif char == ')':\n            current_level -= 1\n            while current_level < 0:\n                current_level += stack.pop()\n        if current_level == 0:\n            parsed_list.append(len(stack))\n            stack = []\n\n    return parsed_list\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            paren_list.append(0)\n        elif char == ')':\n            paren_list.append(1)\n        else:\n            pass\n\n    if paren_list[-1]!= 0:\n        paren_list.append(paren_list[-1])\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for token in paren_string.split():\n        if len(token) > 0:\n            nested_parens.append(len(token) - len(token.lstrip('(')))\n        else:\n            nested_parens.append(0)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n    nests = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_count += 1\n        else:\n            paren_count -= 1\n            if paren_count < 0:\n                return nests\n            else:\n                if nests:\n                    nests[-1] += 1\n                else:\n                    nests.append(1)\n\n    return nests", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n\n    inner_paren_list = paren_string.split(' ')\n    paren_list = [int(paren) for paren in inner_paren_list if paren!= '()']\n\n    # combine the list of parens into a single string for check to see if all parens are matched.\n    if any('()' in inner_paren for inner_paren in paren_list):\n        # if there are unmatched parens, return the first level of nesting. unmatched parens are not considered\n        # part of the deepest level of nesting.\n        return [max(paren_list) + 1]\n    else:\n        # if there are no unmatched parens, then return the depth of the deepest level of nesting.\n        return [len(max(paren_list, key=len))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_groups = paren_string.split()\n\n    # Create the empty list for the output\n    out = []\n\n    # For each of the paren groups in the input\n    for paren_group in paren_groups:\n        # Start by assuming that the current paren group has no nesting\n        depth = 0\n\n        # For each character in the paren group\n        for char in paren_group:\n\n            # If the char is a ( it indicates that the current level of nesting is increased by 1.\n            if char == '(':\n                depth += 1\n\n            # If the char is a ), it indicates that the current level of nesting is decreased by 1.\n            elif char == ')':\n                depth -= 1\n\n            # If the current level of nesting is 0, add 1 to the list of max levels of nesting found in this group.\n            if depth == 0:\n                out.append(depth)\n\n    # Return the list of max levels of nesting found in each of the groups\n    return out", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_string = paren_string.replace(\" \", \"\")\n\n    if paren_string == \"\":\n        return []\n\n    paren_groups = paren_string.split(\" \")\n    result = []\n    for paren_group in paren_groups:\n        result.append(max(parse_nested_parens(paren_group)))\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n\n    paren_list = paren_list[1:]\n    result = []\n    for level in paren_list:\n        if level == \"\":\n            pass\n        else:\n            level = int(level)\n            if level > result[-1] + 1:\n                result.append(level)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_string = paren_string.replace(')', '')\n    paren_string = paren_string.replace('(', '')\n    paren_string = paren_string.replace(' ', '')\n\n    # Split the string into a list of numbers\n    num_list = list(paren_string)\n    num_list.reverse()\n\n    # Remove all parens from the num_list\n    paren_string = ''\n    for num in num_list:\n        paren_string += num\n        if num == '(':\n            num = 0\n        elif num == ')':\n            num = -1\n        else:\n            pass\n\n    # If the number of parenthesis in the paren_string is same as the input string,\n    # then there are no nested parentheses.\n    if paren_string == '':\n        return []\n\n    # Find the deepest level of nesting in the parentheses\n    max_paren_level = 0\n    for i in range(len(paren_string)):\n        if paren_string[i]!= 0:\n            if paren_string[i] > max_paren_level:\n                max_paren_level = paren_string[i]\n    return max_paren_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    paren_groups = paren_string.split()\n    deepest_nesting_levels = []\n    for paren_group in paren_groups:\n        nesting_count = 0\n        paren_groups = parse_nested_parens(paren_group)\n        for i, paren_group in enumerate(paren_groups):\n            if paren_group:\n                nesting_count += 1\n        deepest_nesting_levels.append(nesting_count)\n    return deepest_nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split(\" \")\n    stack = []\n    for paren in paren_list:\n        if paren == \"(\":\n            stack.append(0)\n        elif paren == \")\":\n            if len(stack) == 0:\n                raise ValueError(\"Found extra closing parenthesis for {} \".format(paren))\n            stack.pop()\n        elif paren == \")\":\n            if len(stack) == 0:\n                raise ValueError(\"Found extra closing parenthesis for {} \".format(paren))\n            stack.append(len(stack))\n        else:\n            if len(stack) == 0:\n                raise ValueError(\"Found extra opening parenthesis for {} \".format(paren))\n            stack.append(stack[-1]+len(paren))\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    for paren in paren_string.split():\n        paren_list.extend(parse_pars(paren))\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    string_list = paren_string.split(' ')\n    for paren in string_list:\n        result.append(1 + max(parse_nested_parens(paren)))\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # The string is split into tokens by parentheses\n    paren_string = paren_string.replace('(','(')\n    paren_string = paren_string.replace(')',')')\n    paren_tokens = paren_string.split()\n\n    # If we have an empty string, return an empty list\n    if len(paren_tokens) == 0:\n        return []\n\n    # Otherwise, we will have a list of tokens and we want to find out the deepest level of nesting.\n    # Let's assume for now that the first token is a valid nest.\n    # The rest of the tokens are sub-nests.\n    deepest_level = len(paren_tokens[0])\n    for token in paren_tokens[1:]:\n        level = len(token) - len(token.lstrip())\n        # We update the level of nesting if it is deeper\n        if deepest_level < level:\n            deepest_level = level\n\n    # Finally, we return a list of the deepest level of nesting\n    return list(range(deepest_level + 1))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_levels: List[int] = []\n    for i in paren_string.split():\n        nesting_levels.extend(list(map(int, i)))\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for paren_group in paren_string.split():\n        group = []\n        for paren in paren_group:\n            if paren == '(':\n                group.append(len(nested_parens))\n            elif paren == ')':\n                try:\n                    nested_parens.pop() - 1\n                except IndexError:\n                    # We are trying to pop from empty list.\n                    # Ignore this error.\n                    pass\n            else:\n                raise ValueError(f\"Unrecognized character in paren_string: '{paren}'\")\n        nested_parens.append(max(group))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split()\n    nested_parens = [x for x in nested_parens if x!= '']\n    nested_parens = map(int, nested_parens)\n    return list(map(max, zip(*nested_parens)))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_depth = 0\n    paren_list = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_depth += 1\n        elif paren == ')':\n            paren_depth -= 1\n        elif paren =='' and paren_depth > 0:\n            paren_list.append(paren_depth)\n            paren_depth = 0\n        else:\n            assert paren ==''\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    paren_groups = [paren_group.lstrip(' ') for paren_group in paren_groups]\n    return [len(group) for group in paren_groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    stack = []\n    result = []\n    for token in paren_string.split():\n        if token == '(':\n            stack.append(len(result))\n            result.append(0)\n        elif token == ')':\n            if len(result) == 0:\n                raise ValueError('() found, but no open parens found')\n            result[stack.pop()] = max(result[stack.pop()], len(stack))\n            if len(stack) == 0:\n                result.pop()\n        else:\n            raise ValueError('Unexpected token {}'.format(token))\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split()\n    nested_parens = [len(nested_parens[depth]) for depth in nested_parens]\n    return list(filter(lambda x: x > 0, nested_parens))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = paren_string.strip().split()\n    nested_parens = [parse_nested_parens(group) for group in parens]\n    max_nest = 0\n    for paren in nested_parens:\n        max_nest = max(max_nest, paren)\n    return max_nest", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string:\n        return parse_nested_parens(paren_string.split()[0]) + [len(paren_string.split())]\n\n    return [0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split(' ')\n    paren_list = [int(x) for x in paren_list]\n\n    nested_nested_parens = []\n    for paren in paren_list:\n        nested_nested_parens.append(max(nested_parens[paren]))\n    return nested_nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split()\n    nested = [0]\n    for i in range(len(nested_parens)):\n        nested.append(nested[-1] + len(nested_parens[i].split(\" \")) - 1)\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_levels = []\n    for paren_group in paren_string.split():\n        current_paren = []\n        for i in range(0, len(paren_group)):\n            if paren_group[i] == '(':\n                current_paren.append(i)\n            elif paren_group[i] == ')':\n                if len(current_paren) > 0:\n                    current_paren.pop()\n                else:\n                    paren_levels.append(len(current_paren))\n    return paren_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = [-1]  # type: List[int]\n    for element in paren_string.split():\n        result.append(1 + max([parse_nested_parens(x) for x in element.split()]))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = [0, 0]\n\n    for part in paren_string.split():\n        nesting[0] += 1 if '(' in part else 0\n        nesting[1] += 1 if ')' in part else 0\n\n    return [max(nesting)] * len(paren_string.split())", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_groups.append(i)\n        elif char == ')':\n            if paren_groups.pop() < i:\n                paren_groups.append(i)\n            else:\n                paren_groups.pop()\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for group in paren_string.split(' '):\n        nested_parens += parse_nested_parens(group)\n    return max(nested_parens)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # the outer most level is represented by 0\n    levels = []\n    for i in paren_string.split():\n        levels.append(len(i))\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            result.append(len(result))\n        elif char == ')':\n            if len(result) > 0:\n                result.pop(-1)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n    if paren_string == '':\n        return 0\n    groups = paren_string.split(' ')\n    paren_nest = []\n    for group in groups:\n        group = group.strip()\n        if len(group) == 0:\n            paren_nest.append(paren_count)\n            paren_count = 0\n        elif group[0] == '(':\n            paren_count += 1\n        elif group[-1] == ')':\n            paren_count -= 1\n        paren_nest.append(paren_count)\n    return paren_nest\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # ensure that the string is a well-formed parenthesis string\n    for char in paren_string:\n        if char not in \"()\":\n            raise ValueError(\"Unrecognized character in the parens string\")\n\n    # strip all the leading and trailing spaces from the input string\n    paren_string = paren_string.strip()\n\n    if paren_string == \"\":\n        return []\n\n    # split the string into individual groups of parentheses\n    paren_groups = paren_string.split(\" \")\n\n    # get the deepest level of nesting for each of the group\n    return [len(paren_group) - 1 for paren_group in paren_groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n    paren_dict = {}\n    for p in paren_list:\n        paren_dict[p] = 0\n\n    stack = []\n    result = []\n    for i in range(len(paren_list)):\n        if paren_list[i] == '(':\n            stack.append(0)\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            if len(stack) == 0:\n                if paren_list[i] == ')':\n                    paren_dict[paren_list[i]] = paren_dict[paren_list[i]] + 1\n                    result.append(paren_dict[paren_list[i]])\n                else:\n                    result.append(paren_dict[paren_list[i]])\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [\n        1 if paren_string[i] == '(' else 0\n        for i in range(len(paren_string))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def get_nesting_depth(paren_string: str, nesting_depth: int) -> int:\n        paren_string = paren_string.strip()\n        if paren_string.endswith(')'):\n            nesting_depth += 1\n            if paren_string.startswith('('):\n                nesting_depth += 1\n        return nesting_depth\n    paren_string = paren_string.strip()\n    paren_string = paren_string.replace('(','').replace(')','').replace('  ','')\n    paren_string =''.join(paren_string.split())\n    return [get_nesting_depth(paren_string, 0) for _ in range(len(paren_string.split()))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_group_list = []  # type: List[List[int]]\n    for paren_group in paren_string.split():\n        paren_group_list.append([parse_nested_parens_level(paren_group)])\n    return paren_group_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret_val = []\n    for group in paren_string.split(' '):\n        nest_level = 1\n        for ch in group:\n            if ch == '(':\n                nest_level += 1\n            elif ch == ')':\n                nest_level -= 1\n        ret_val.append(nest_level)\n    return ret_val", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    parens = paren_string.split()\n    for paren in parens:\n        paren = paren.strip()\n        if paren:\n            result.append(parse_nested_parens(paren))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n    level = 0\n    stack: List[int] = []\n\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if level == 0:\n                max_level += 1\n            level += 1\n            stack.append(0)\n        elif char == ')':\n            if level == 0:\n                max_level -= 1\n            level -= 1\n            stack.pop()\n        if level == max_level:\n            stack.pop()\n            level -= 1\n        if len(stack) == 0:\n            break\n    return [level] + stack if len(stack) > 0 else [level]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split(' ')\n    return [max(map(parse_nested_parens, paren_group)) for paren_group in paren_groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_dict = {}\n    for index, paren_group in enumerate(paren_string.split()):\n        paren_group = paren_group.strip()\n        paren_dict[index] = len(paren_group.split('(')[0])\n    return paren_dict.values()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split(' ')\n\n    result = []\n    for paren in nested_parens:\n        if len(paren) == 0:\n            continue\n\n        if paren[0] == '(':\n            result.append(len(paren) - 1)\n        elif paren[0] == ')':\n            if len(paren) == 1:\n                continue\n\n            result[-1] -= 1\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return []\n            while stack[-1]!= i:\n                stack.pop()\n            stack.pop()\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # List to store the nesting of parentheses\n    nested_parens = []\n\n    # Split the string to get list of groups of parentheses\n    groups = paren_string.split(' ')\n\n    # Iterate over the groups and append their nesting to the list\n    for group in groups:\n        nested_parens.append(len([group_char for group_char in group if group_char in '()']))\n\n    # Convert the list to integer\n    nested_parens = [int(i) for i in nested_parens]\n\n    # Return the list\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split(\" \")\n    max_nesting_level = 1\n    paren_list = paren_list[1:]\n\n    out_list = []\n\n    for i in paren_list:\n        nesting = 0\n        inner_list = i.split(\"(\")\n        for j in inner_list:\n            if j.endswith(\")\"):\n                nesting += 1\n        out_list.append(nesting)\n        max_nesting_level = max(nesting, max_nesting_level)\n\n    return out_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n\n    for paren in paren_string.split(' '):\n        if paren == '()':\n            result.append(1)\n        else:\n            result[-1] += 1\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    if not paren_string:\n        return []\n    return max(\n        parse_nested_parens(paren_string[::-1])  # use reversed to parse right to left\n        for paren_string in paren_string.split()\n    )[1:]  # remove max because it's not needed for the output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(len(stack))\n        elif char == ')':\n            if not stack:\n                raise Exception('invalid paren string')\n            return [max(stack.pop(), paren[0]) for paren in stack]\n    raise Exception('invalid paren string')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [i for i, c in enumerate(paren_string) if c == '(']", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # TODO: This should be changed as soon as the course is updated. I will do it later this week.\n    # TODO: This is a copy-pasted piece from a different exercise. This should be changed.\n\n    if not paren_string:\n        return []\n\n    paren_list = []\n    current_depth = 0\n\n    # Iterate over the string\n    for paren in paren_string.split():\n        # If we encounter an opening paren, increase the depth\n        if paren == '(':\n            current_depth += 1\n        # If we encounter a closing paren, decrease the depth\n        elif paren == ')':\n            current_depth -= 1\n        # If we encounter a space, get the maximum depth of the strings in the list\n        elif paren =='':\n            paren_list.append(max(paren_list))\n            current_depth = 0\n        # If the current depth is 0, append the current string to the list of strings to process\n        elif current_depth == 0:\n            paren_list.append(paren)\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = paren_string.split()\n\n    result = []\n    for paren in nested_parens:\n        if paren.startswith('('):\n            result.append(1)\n        elif paren.startswith(')'):\n            result[-1] -= 1\n        else:\n            result.append(0)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    out = []\n    last_depth = 0\n    current_depth = 0\n    for p in paren_string.strip().split():\n        if p == '(':\n            current_depth += 1\n        elif p == ')':\n            current_depth -= 1\n        if current_depth > last_depth:\n            last_depth = current_depth\n        if current_depth < last_depth:\n            out.append(last_depth)\n            last_depth = current_depth\n    out.append(last_depth)\n    return out", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.replace('(','').replace(')','').split()\n\n    if len(nested_parens) == 1:\n        return [len(nested_parens[0].split())]\n\n    return [[len(nested_parens[i].split())] for i in range(len(nested_parens))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for i in paren_string.split():\n        try:\n            result.append(len(next(parse_nested_parens(i))))\n        except StopIteration:\n            result.append(1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    # initialise with maximum value\n    group_nesting: List[int] = []\n    for i, group in enumerate(groups):\n        group_nesting.append(len(group.split('(')) + 1)\n    # remove outer groups\n    for i, group in enumerate(groups):\n        while group_nesting[i] == 0:\n            del group_nesting[i]\n            del groups[i]\n    return group_nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    for parenthesis in paren_string.split(' '):\n        if parenthesis == '()':\n            parens.append(1)\n        else:\n            parens.append(max(parse_nested_parens(parenthesis)) + 1)\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '( ')\n    paren_string = paren_string.replace(')',')')\n\n    paren_groups = paren_string.split(' ')\n\n    # map to make nested groups\n    group_nested_parens = []\n    for group in paren_groups:\n        group_nested_parens.append(len(reversed([int(i) for i in group.split('(')])))\n\n    return group_nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    max_level = 0\n    nesting = []\n    for paren_group in paren_string.split():\n        level = len(paren_group)\n        if level > max_level:\n            max_level = level\n        if level < max_level:\n            nesting.append(level)\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [max([parse_nested_parens(sub) for sub in paren_string.split()]) for paren_string in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for level in paren_string.split():\n        if level == '(':\n            paren_stack.append(0)\n        elif level == ')':\n            paren_stack.pop()\n        else:\n            paren_stack.append(max(paren_stack))\n\n    return paren_stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # We only need to look at the first and last two characters to determine the nesting level\n    # The first character of each group is either an opening paren or a space. The second character is either\n    # a closing paren or a space\n    paren_indices = []\n    # The indices of the spaces in between the parens. This will be used to determine the nesting level\n    space_indices = []\n    # We keep track of the current nesting level\n    level = 0\n    for index, char in enumerate(paren_string):\n        if char == '(':\n            level += 1\n        elif char == ')':\n            if level > 0:\n                level -= 1\n        elif char =='':\n            space_indices.append(index)\n    # We want to iterate over the space_indices but the first and last indices are the first and last\n    # paren indices. We need to create a new list with the first and last indices excluded\n    new_space_indices = space_indices[1:-1]\n    # Sort the space_indices so that we get the deepest nesting level first\n    new_space_indices.sort(key=lambda index: level - index)\n    # Now we have to add the first and last indices of", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # first pass: split the input string by spaces and parse each\n    # individual group.\n    results = []\n    for group in paren_string.split():\n        results.append(max(parse_nested_parens(group), default=0))\n\n    # second pass: find the maximum value of the group.\n    return [max(result) for result in results]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string.split():\n        new_result = parse_nested_parens(paren)\n        result += [max(new_result)] if new_result else [0]\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    nested_parens.extend(paren_string.split())\n    nested_parens = [parse_nested_parens(paren) for paren in nested_parens]\n\n    return [paren for paren in nested_parens if paren!= 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Remove brackets\n    paren_string = paren_string.replace('()', '').replace('[]', '').replace('{}', '')\n    # Split string by space\n    paren_groups = paren_string.split(' ')\n    # Each group can contain one or more nesting levels\n    nested_level = []\n    for group in paren_groups:\n        nested_level += group.count('(') - group.count(')')\n    return nested_level\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    out_list = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            out_list.append(i)\n        elif char == ')':\n            out_list.append(i)\n        else:\n            out_list[-1] += 1\n    return out_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # this will be the output\n    result = []\n\n    # iterate over each char in string\n    for index, char in enumerate(paren_string):\n        if char == \" \":\n            continue\n        elif char == \"(\":\n            result.append(len(result))\n\n        elif char == \")\":\n            if len(result):\n                result.pop()\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Remove the unnecessary parentheses\n    paren_string = paren_string.replace('()', '(').replace('()()', '((')\n    # Create a list of group\n    paren_groups = paren_string.split()\n\n    result = []\n    # For each of the group, compute its deepest level of nesting\n    for paren_group in paren_groups:\n        if paren_group == '':\n            # There is no nesting for empty groups\n            result.append(0)\n        else:\n            result.append(max(parse_nested_parens(paren_group)))\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nesting_dict: Dict[int, int] = {}  # type: Dict[int, int]\n    for index, group in enumerate(paren_string.split()):\n        nesting_dict[len(group) - 1] = nesting_dict.get(len(group) - 1, 0) + 1\n        for i, character in enumerate(group):\n            if character == '(':\n                nesting_dict[i] += 1\n\n    return nesting_dict.keys()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens_list: List[int] = []\n    for paren_group in paren_string.split():\n        nested_parens_list.append(len(paren_group))\n    return nested_parens_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # first get the maximum depth\n    max_depth = 0\n    for group in paren_string.split(' '):\n        group = group.strip()\n        if group[0] == '(':\n            depth = len(group) - 1\n        else:\n            depth = 0\n        max_depth = max(max_depth, depth)\n\n    return [max_depth] + parse_nested_parens(paren_string[1:]) + [max_depth]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.replace('(', '(').replace(')', ')').split()\n    return [nested_parens.index(paren) + 1 for paren in paren_string]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [parse_nested_parens_level(paren_string, i) for i in range(len(paren_string))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    paren_string = paren_string.strip()\n    parsed_parens = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            if depth == 0:\n                depth += 1\n            else:\n                depth += 1\n        elif char == ')':\n            if depth == 0:\n                print(f\"Error in input at index {i} {paren_string}\")\n                return None\n            else:\n                depth -= 1\n        if depth < 0:\n            return None\n        parsed_parens.append(depth)\n    return parsed_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = [int(paren.count('(')) for paren in paren_string.split()]\n    max_nesting_level = paren_list[-1]\n\n    result = []\n    for i in range(len(paren_list) - 1, -1, -1):\n        if paren_list[i] >= max_nesting_level:\n            max_nesting_level = paren_list[i]\n        if paren_list[i]!= 0:\n            result.append(paren_list[i])\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    if not paren_groups:\n        return []\n    paren_max = paren_groups[0]\n    if not paren_max.endswith(')'):\n        paren_max += ')'\n    paren_max = paren_max[:-1]\n    nesting = [paren_max]\n    for paren_group in paren_groups[1:]:\n        paren = paren_group[:-1]\n        if not paren.endswith(')'):\n            paren += ')'\n        paren = paren[:-1]\n        if paren in nesting:\n            nesting.append(paren)\n        else:\n            nesting.append(paren_max)\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nesting = 0\n    last_balance = 0\n\n    result = []\n    for group in paren_string.split(' '):\n        if group == '':\n            pass\n        else:\n            # Get the number of matching parens in the group\n            balance = count_matching(group)\n\n            if balance!= 0:\n                nesting += balance - last_balance\n                last_balance = balance\n            else:\n                nesting += balance\n\n            result.append(nesting)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n    result = []\n    current_paren_count = 0\n\n    for item in paren_string.split():\n        if item == '(':\n            current_paren_count += 1\n            paren_count += 1\n\n        if item == ')':\n            if current_paren_count > 0:\n                current_paren_count -= 1\n\n            if current_paren_count == 0 and paren_count > 0:\n                paren_count -= 1\n\n            result.append(paren_count)\n\n        if current_paren_count == 0:\n            result.append(paren_count)\n\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(','( ').replace(')',') ').replace('(','( ').replace(')',') ').replace('(','( ').replace(')',') ')\n    return [len([\n        int(i) for i in paren_string.split(' ') if i.strip()!= ''\n        ]) for i in paren_string.split(' ') if i.strip()!= '']", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split(' ')\n    result = []\n    for paren_group in paren_groups:\n        parens = []\n        for paren in paren_group.split('('):\n            parens.append(len(paren.split(')')))\n        result.append(max(parens))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = paren_string.split()\n    parens_pairs = []\n    # walk through each group of parentheses\n    for i in range(len(parens) - 1):\n        current = parens[i]\n        next = parens[i + 1]\n        if next in (')', '('):\n            if current not in ('(', ')'):\n                parens_pairs.append(i)\n        elif current == '(':\n            # find the deepest level of nesting\n            parens_pairs.append(i)\n            parens_pairs.extend([i + 1 for i in range(len(parens) - 1) if parens[i + 1] == ')'])\n    # return the max level of nesting\n    return max(parens_pairs)\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Convert the string to a list of substrings, each substring is one level of nesting.\n    nested_parens_list = [paren_string[i:i + 1] for i in range(len(paren_string) - 1) if paren_string[i:i + 1] == '(' or paren_string[i:i + 1] == ')']\n    # A substring is a valid nesting level if there are no nested parentheses in it.\n    nested_parens_list = [paren_string for paren_string in nested_parens_list if not any(paren_string == ch for ch in '()')]\n    # Maximum number of nesting in the longest substring is the number of nesting in the input string.\n    nesting = len(max(nested_parens_list, key=len))\n    return [nesting]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # This is a dictionary that stores maximum number of nested parentheses for each group.\n    # Key is the group and value is the maximum nesting level of that group\n    max_dict = {}\n\n    # Iterate through the input string\n    for paren_group in paren_string.split():\n        # Iterate through the groups and find the maximum nesting level for each group\n        for paren_group_nesting in parse_nested_parens(paren_group):\n            if paren_group_nesting in max_dict:\n                # If current nesting level is already present, update it\n                max_dict[paren_group_nesting] = max(max_dict[paren_group_nesting], paren_group_nesting)\n            else:\n                # Else, add the current nesting level to the dictionary\n                max_dict[paren_group_nesting] = paren_group_nesting\n\n    return max_dict", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    levels = []\n    for i, char in enumerate(paren_string):\n        if char == ')':\n            if paren_string[i - 1] == '(':\n                levels.append(len(levels))\n            else:\n                levels.append(levels[-1])\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Preprocess the string\n    paren_string = paren_string.strip()\n    paren_string = paren_string.replace(' ', '')\n    paren_string = paren_string.replace(')', ') ')\n    paren_string = paren_string.replace('(', '( ')\n    paren_string = paren_string.replace(')', ') ')\n    paren_string = paren_string.replace('(', '( ')\n    # Now it is ready to be split into groups.\n    paren_groups = paren_string.split(' ')\n    # This will be a list of integers which will be largest nesting level\n    return [max([len(paren.split(' ')) for paren in paren_groups]) for paren_group in paren_groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Special case - the first character is a left parenthesis. All we need to do\n    # is push this character onto a stack\n    if paren_string[0] == '(':\n        return [parse_nested_parens(paren_string[1:])[0]]\n    # The first character is neither a left or right parenthesis. We need to\n    # determine if it is a left or right parenthesis by trying to match it\n    # against each character in the string. If we match it against a left\n    # parenthesis, push it on the stack, if we match it against a right\n    # parenthesis, pop the stack and return the number of levels of nesting\n    # remaining. If we match it against neither, throw an error.\n    stack = []\n    for i, character in enumerate(paren_string):\n        if character == '(':\n            stack.append(i)\n        elif character == ')':\n            if len(stack) == 0:\n                raise ValueError('Nesting of parentheses is not balanced')\n            deepest_level_of_nesting = len(stack)\n            stack.pop()\n            return [deepest_level_of_nesting] + parse_nested_parens(paren_string[i + 1:])\n    return None", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    results = []\n\n    # first find the number of parens\n    paren_count = 0\n    current_level = 0\n    for c in paren_string:\n        if c == '(':\n            current_level += 1\n        if c == ')':\n            current_level -= 1\n        if current_level == 0:\n            paren_count += 1\n    # now parse the string\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            if paren_count == current_level:\n                results.append(i)\n            current_level += 1\n        if c == ')':\n            if paren_count == current_level:\n                results.append(i)\n            current_level -= 1\n\n    return results", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = list(paren_string.split())\n    return [max(parse_nested_parens(group)) for group in groups if group]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = paren_string.split(\" \")\n    out_list = []\n    for nested_parens_string in nested_parens:\n        paren_count = 0\n        for paren in nested_parens_string:\n            if paren == \"(\":\n                paren_count += 1\n            elif paren == \")\":\n                paren_count -= 1\n        out_list.append(paren_count)\n    return out_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def is_valid_parens(parens: str) -> bool:\n        \"\"\" Checks if the string is valid parentheses.\n        E.g. (()()()) is valid while ((())()()) is not.\n        \"\"\"\n        return all(char in '()' for char in parens)\n\n    parens = paren_string.replace('(','').replace(')','')\n    parens = parens.split(' ')\n\n    if not all(is_valid_parens(parens_item) for parens_item in parens):\n        raise ValueError(f'Invalid characters in parentheses {paren_string}')\n\n    nested = [0] * len(parens)\n    for i, parens_item in enumerate(parens):\n        for j in range(len(parens_item)):\n            if parens_item[j] == '(':\n                nested[i] += 1\n            elif parens_item[j] == ')':\n                nested[i] -= 1\n            else:\n                raise ValueError(f'Unknown character {parens_item[j]}')\n\n    return nested\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Parse string to list of nested parens.\n    paren_list = paren_string.split(' ')\n    paren_collection = []\n    for paren_group in paren_list:\n        paren_group = paren_group.strip()\n        if paren_group!= '':\n            paren_collection.append(len(paren_group))\n\n    # Grouping items by length.\n    grouped = sorted(enumerate(paren_collection), key=lambda x: x[1])\n    nested_parens = []\n    for i, item in grouped:\n        if i == 0:\n            nested_parens.append(item)\n            continue\n        paren = []\n        for j, n in grouped[i-1]:\n            if j == 0:\n                paren.append(n)\n            else:\n                paren.append(n + paren[-1])\n        nested_parens.append(paren)\n\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string) == 0:\n        return []\n\n    paren_str_list = paren_string.split()\n\n    if len(paren_str_list) == 0:\n        return []\n\n    return [len([level for level in paren_str_list if level == '('])] + \\\n        parse_nested_parens(' '.join(paren_str_list[1:]))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    max_level = 0\n    nesting = []\n    for paren in paren_string.split():\n        if paren == '(':\n            nesting.append(0)\n        elif paren == ')':\n            nesting.append(1)\n        else:\n            nesting[-1] += 1\n        if max_level < nesting[-1]:\n            max_level = nesting[-1]\n    return [max_level] + nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    if not paren_string:\n        return []\n\n    result = []\n\n    for paren_group in paren_string.split(' '):\n        paren_count = 1\n        count = 0\n        for char in paren_group:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count == 0:\n                result.append(paren_count)\n                paren_count = 1\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    if len(paren_string) == 0:\n        return []\n    if paren_string[0]!= '(':\n        return [len(paren_string)]\n    paren_string = paren_string[1:]\n    if len(paren_string) == 0:\n        return []\n    result = []\n    cur_paren = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            cur_paren += 1\n        if paren_string[i] == ')':\n            cur_paren -= 1\n        if cur_paren == 0:\n            result.append(paren_string[i])\n    result.append(len(paren_string))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    paren_groups = paren_string.split()\n    for paren_group in paren_groups:\n        depth = 0\n        for i in range(len(paren_group)):\n            if paren_group[i] == '(':\n                depth += 1\n            elif paren_group[i] == ')':\n                depth -= 1\n        result.append(depth)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split()\n    paren_nest = 0\n    paren_list = []\n    for i in range(len(paren_groups)):\n        if paren_groups[i][0] == '(':\n            paren_nest += 1\n        elif paren_groups[i][0] == ')':\n            if paren_nest > 0:\n                paren_nest -= 1\n            else:\n                paren_list.append(paren_nest)\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n\n    for i in paren_string.split():\n        if not i:\n            nested_parens.append(-1)\n        else:\n            nested_parens.append(len(nested_parens))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for paren_group in paren_string.split(' '):\n        nested_parens.append(len(re.findall('^ *\\(.*\\) *$', paren_group, flags=re.M)))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    result = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            stack.pop()\n            if len(stack) == 0:\n                result.append(len(stack))\n            if len(stack) < 0:\n                result.append(len(stack) * -1)\n        else:\n            result.append(len(stack))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [parse_nested_parens(g) for g in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def parenthesis_finder(paren_string: str) -> int:\n        paren_finder = 0\n        for i in range(len(paren_string)):\n            if paren_string[i] == '(':\n                paren_finder += 1\n            elif paren_string[i] == ')':\n                paren_finder -= 1\n        return paren_finder\n    return [parenthessis_finder(paren_string) for paren_string in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_list: List[int] = []\n    i = 0\n    for nesting in paren_string.split(' '):\n        if '(' == nesting[:1]:\n            nested_list.append(len(nesting_parens(nesting)))\n        i += 1\n    return nested_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_groups: List[int] = []\n    current_level = 0\n\n    for i in paren_string.split(\" \"):\n        if not i:\n            continue\n        level = paren_groups.count(i)\n        if level > current_level:\n            current_level = level\n        elif level < current_level:\n            paren_groups.pop()\n\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for group in paren_string.split():\n        nested_parens.extend(max(parse_nested_parens(group), key=len) + 1)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = 0\n    stack = []\n    for s in paren_string.split():\n        if s:\n            if s[0] == '(':\n                stack.append(result)\n                result += 1\n            elif s[-1] == ')':\n                result = stack.pop()\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    nested_level = 0\n    for c in paren_string:\n        if c == '(':\n            nested_level += 1\n        elif c == ')':\n            nested_level -= 1\n            if nested_level == 0:\n                paren_list.append(nested_level)\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '( ').replace(')',')')\n    paren_string =''.join(paren_string.split())\n    level = 0\n    paren_groups = paren_string.split()\n    result = []\n    for paren_group in paren_groups:\n        # Find deepest level of nesting\n        level = max(level, len(paren_group))\n        if len(paren_group) > 1:\n            # Remove parentheses from group\n            paren_group = paren_group.replace('(', '').replace(')', '')\n            # Remove extra spaces\n            paren_group =''.join(paren_group.split())\n            # Remove spaces after parens\n            paren_group = paren_group.replace(' (', '(').replace(' )', ')')\n            # Replace space before first paren with nothing\n            paren_group = paren_group.replace(' (', '')\n            # Add parenthesis to group\n            paren_group = '({})'.format(paren_group)\n            # Add this to the list of levels\n            result.append(len(paren_group))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    paren_string = paren_string.strip()\n    paren_list = paren_string.split(\" \")\n    for paren in paren_list:\n        nesting = 0\n        while paren[-1] == \"(\":\n            nesting += 1\n            paren = paren[:-1]\n        result.append(nesting)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Regex to match a single parenthesis\n    single_parens = '\\((.*?)\\)'\n\n    # Regex to match a single paren group (i.e. (())) or nested paren group (i.e. (()()) etc)\n    group_parens = '\\((.*?)\\)\\((.*?)\\)'\n\n    nested_levels = []\n    paren_string = paren_string.strip()\n\n    # Remove extra spaces\n    paren_string = paren_string.replace(' ', '')\n\n    # Split paren_string into chunks using newlines as delimiters\n    chunks = paren_string.split('\\n')\n\n    # For each chunk in the string, get the levels of nesting\n    # If the chunk contains one or more parens, it is a group\n    # If the chunk contains only parens, it is a single paren\n    for chunk in chunks:\n        # Match parens in each chunk\n        match = re.match(group_parens, chunk)\n        if match:\n            # Get the nested level\n            nested_levels.append(len(match.groups()))\n            # Get the parens in each group\n            parens_in_group = match.groups()[0].strip()\n            # Parse the par", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    ret = []\n    paren_string = paren_string.replace('(', '').replace(')', '')\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            if len(ret) == 0:\n                ret.append(i)\n            else:\n                ret[-1] = max(ret[-1], i)\n    return ret", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for i in paren_string.split():\n        nested_parens.append(len(i))\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('()', '(_)')\n    max_level = 0\n    levels = []\n    for i in paren_string:\n        if i == '_':\n            levels.append(max_level)\n            max_level = 0\n        else:\n            max_level += 1\n    if max_level > 0:\n        levels.append(max_level)\n\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    # Each char is a member of a string group\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            if stack[-1] == 0:  # first level of nesting\n                stack.pop()\n            else:\n                stack[-1] += 1\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string == '':\n        return []\n\n    # Split the string at spaces\n    groups = paren_string.split(' ')\n\n    # Create a stack to store the deepest level of nesting for each group\n    stack = []\n\n    # We will keep adding to the stack as long as we are at the root of the nesting\n    # Once we reach a closed parenthesis we will start popping items from the stack\n    # Each time we do a pop we will check if we are at the deepest level of nesting\n    # If so we will return the current value of the stack, otherwise we will continue\n    # adding to the stack\n    for group in groups:\n\n        # Since there are no opening parentheses, just push the current depth\n        stack.append(len(group))\n\n        # The following loop will iterate over each character in the current group\n        # Note the use of a generator expression to only iterate over a single character at a time\n        # We use a while loop because we need to look ahead to see if we are at the deepest nesting level\n        # E.g. if the group was (()) we would only check the first opening parenthesis because\n        # the next characters in the group are closing parenthesis and", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for inner_group in paren_string.split():\n        deepest = 0\n        for index, char in enumerate(inner_group):\n            if char == '(':\n                if index == 0:\n                    deepest += 1\n                else:\n                    deepest += max(parse_nested_parens(inner_group[index:]))\n                inner_group = inner_group[:index] + ')' + inner_group[index + 1:]\n        result.append(deepest)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Input string is guaranteed to be well formed.\n    paren_count = 0\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_count += 1\n        if paren_string[i] == ')':\n            paren_count -= 1\n        if paren_count == 0:\n            result.append(i)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    for i in paren_string.split():\n        paren_list.append(parse_nested_parens(i))\n    return [len(paren_list) - len(sub_paren_list) for paren_list in paren_list for sub_paren_list in paren_list]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # This list keeps track of the level of nested parentheses\n    paren_level = []\n    # This list keeps track of the current character position\n    char_pos = 0\n    for i, char in enumerate(paren_string):\n        if char in '(':\n            paren_level.append(i)\n        if char in ')':\n            paren_level.pop()\n        if char =='':\n            if paren_level!= []:\n                if paren_level[-1] == 0:\n                    char_pos = i\n\n    # Remove the last index if it is a space\n    # if paren_level[-1] == 0:\n    #     char_pos = i - 1\n\n    return paren_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_groups = paren_string.replace('(','( ').replace(')',') ').split(' ')\n\n    return [\n        max([\n            len(parse_nested_parens(paren_group))\n            for paren_group in paren_groups\n        ])\n    ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace(' ', '')  # Remove spaces\n    paren_list = paren_string.split('(')  # List of strings separated by parentheses\n    paren_list = [p.strip() for p in paren_list]  # Strip the end parentheses\n    result_list = [len(p.split(')')) + 1 for p in paren_list]  # Convert string of length of depth to integer\n    return [max(r) for r in result_list]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [\n        max([parse_nested_parens(part) for part in paren_string.split(' ')])  # find the deepest level for each paren group\n    ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for i, group in enumerate(paren_string.split()):\n        nested_parens.append(max(parse_nested_parens(group)) + 1)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    current = ''\n    result = []\n    for char in paren_string:\n        if char == '(':\n            if current == '':\n                level += 1\n            else:\n                level += 1\n        elif char == ')':\n            if current == '':\n                level -= 1\n                if level == 0:\n                    result.append(level)\n        current += char\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    paren_string = paren_string.replace(\" \", \"\")\n    for i in paren_string:\n        if i == \"(\":\n            parens.append(len(parens))\n            paren_string = paren_string.replace(i, \"\")\n        else:\n            while i!= \"(\":\n                i = paren_string.find(i)\n                parens[-1] = parens[-1] - 1\n                if i == -1:\n                    break\n            paren_string = paren_string.replace(i, \"\")\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = list(map(lambda s: 0, paren_string.split()))\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            nested_parens[i] += 1\n        elif c == ')':\n            nested_parens[i] -= 1\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_levels = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            nesting_levels.append(len(nesting_levels))\n            if len(nesting_levels) == 1:\n                nesting_levels.append(0)\n        elif paren_string[i] == ')':\n            if len(nesting_levels) > 1:\n                nesting_levels.pop()\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    for i, paren in enumerate(paren_string.split(' ')):\n        if paren == '(':\n            result.append(len(result))\n            result.append(i + 1)\n        elif paren == ')':\n            j = result.pop()\n            if j > 0:\n                result[j] = max(result[j] - 1, 0)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    current_level = 0  # Number of nested parentheses of the current group\n    groups = paren_string.split()  # We will have a list of groups. Each group starts with () and has no trailing spaces\n    result = []\n    for group in groups:\n        result.append(current_level)\n        # If there are no parentheses, it is not a group. So we add 1 to current level to include the () in result.\n        if len(group) == 1 and group.strip() == \"\":\n            current_level += 1\n        else:\n            for i, paren in enumerate(group):\n                # If we find a ( ) in group, we go to next level of nesting of that group\n                if paren == \"(\":\n                    current_level += 1\n                # If we find a ) in group, we go to previous level of nesting of that group\n                elif paren == \")\":\n                    current_level -= 1\n        # If we are at the last group and current level is 0, it means there are no further levels of nesting and we are done.\n        if len(result) == len(groups) - 1 and current_level == 0:\n            break\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    return [max(parse_nested_parens(paren_group) for paren_group in paren_string.split())]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # This function is purposefully left unnamed to make its usage more intuitive (since it is a parameter for `reduce`)\n    result = []\n    current = 0\n    for character in paren_string:\n        if character == '(':\n            if current > 0:\n                result.append(current + 1)\n                current = 0\n        elif character == ')':\n            current += 1\n    result.append(current)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = 0\n    brackets = []\n    for ch in paren_string:\n        if ch == '(':\n            nested += 1\n            brackets.append(nested)\n        elif ch == ')':\n            nested -= 1\n            if nested == 0:\n                brackets.pop()\n        elif ch =='':\n            pass\n        else:\n            raise Exception('Unknown character: {}'.format(ch))\n    return brackets", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [len(list(reversed(list(grouper)))) for grouper in (re.split(r'\\s+', paren_string) if paren_string else [])]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(','').replace(')','')\n    levels = paren_string.count('(') - paren_string.count(')')\n\n    if levels < 0:\n        raise ValueError('Input must contain more left parentheses than right ones')\n\n    nested = []\n    for i, word in enumerate(paren_string.split()):\n        if word == '(':\n            nested.append(i)\n        elif word == ')':\n            if len(nested) > 0:\n                nested.pop()\n            else:\n                raise ValueError('Input string must contain a group of parenthesis.')\n    return levels + [len(nested)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # First we identify the groups of parentheses.\n    group_list = paren_string.split()\n\n    # We store the maximum depth for each of the group.\n    group_max_depth = []\n\n    # Iterate over the groups of parentheses and identify the deepest level of nesting.\n    for group in group_list:\n        group_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n            elif char == ')':\n                current_depth -= 1\n                if current_depth < 0:\n                    current_depth = 0\n            if current_depth > group_depth:\n                group_depth = current_depth\n        group_max_depth.append(group_depth)\n\n    # We return the maximum depth of nesting of all the groups of parentheses.\n    return group_max_depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    parens = []\n    for grouping in paren_string.split(\" \"):\n        parens.extend([len(list(group)) for group in list(zip(*[iter(grouping)] * 2))])\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    \"\"\"\n    Function to parse the string and return a nested list for each of the groups. The groups are separated by a space\n    \"\"\"\n    groups = []\n    for i in paren_string.split(' '):\n        cur_group = []\n        for j in i.replace('(', ')').replace(')', '(').split(')'):\n            if not j:\n                break\n            cur_group.append(len(j))\n        groups.append(cur_group)\n\n    max_level = [-1 for _ in groups]\n\n    \"\"\"\n    Function to find the deepest level of nesting for each of the groups\n    \"\"\"\n    for i in range(len(groups)):\n        if i == 0:\n            continue\n        for j in range(len(groups[i])):\n            if groups[i][j] == 0:\n                groups[i][j] = max_level[i] + 1\n                max_level[i] = max(max_level[i], groups[i][j])\n                break\n\n    return max_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for n_parens in paren_string.split():\n        nested_parens.append(len(n_parens))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    paren_groups = paren_string.split()\n    for i, group in enumerate(paren_groups):\n        if not group:\n            continue\n        nesting = 0\n        for j, character in enumerate(group):\n            if character == '(':\n                nesting += 1\n            if character == ')':\n                nesting -= 1\n                if nesting == 0:\n                    result.append(i)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = 0\n    stack = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            nested += 1\n        elif char == ')':\n            nested -= 1\n            if nested == 0:\n                stack.append(nested)\n        if char =='' and stack:\n            nested_parens = stack.pop(0)\n            if nested_parens < len(stack):\n                stack[stack.index(nested_parens)] = max(stack[stack.index(nested_parens)], nested_parens)\n            else:\n                stack[len(stack) - 1] = nested_parens\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = [int(paren) for paren in paren_string.split()]\n    if not all(paren_groups):\n        return []\n\n    max_depth = max(paren_groups)\n    if max_depth == 0:\n        return []\n    return [max_depth] + parse_nested_parens(' '.join([str(paren - 1) for paren in paren_groups]))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Get the number of groups\n    num_groups = len(paren_string.split())\n\n    # Output list that will store the level of nesting\n    output = []\n\n    # For each group\n    for i in range(num_groups):\n        # Separate the group by spaces\n        group = paren_string.split()[i]\n\n        # Separate each part by parentheses\n        part = group.split('(')[0].split(')')[-1]\n\n        # Append the level of nesting\n        output.append(len(part) - 1)\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n    for group in paren_string.split(' '):\n        nested_parens.append(max(parse_nested_parens(group), key=lambda x: len(x)))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    if not paren_string:\n        return []\n\n    paren_groups = []\n    current_depth = 0\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            current_group.append(current_depth)\n        elif char == ')':\n            current_depth -= 1\n            if current_depth == 0:\n                paren_groups.append(max(current_group))\n                current_group = []\n        else:\n            current_group.append(char)\n    if current_depth!= 0:\n        raise ValueError(f'Not matching parens: {paren_string}')\n    return paren_groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    for paren_group in paren_string.split(' '):\n        current_level = 0\n        for char in paren_group:\n            if char == '(':\n                current_level += 1\n            elif char == ')':\n                current_level -= 1\n\n            if current_level < 0:\n                current_level = 0\n            if current_level > 0:\n                current_level = 0\n\n        nested_parens.append(current_level)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    stack: List[int] = []\n    current_level: int = 0\n    for char in paren_string:\n        if char == '(':\n            current_level += 1\n            stack.append(current_level)\n        elif char == ')':\n            current_level -= 1\n            if current_level == 0:\n                stack.pop()\n                print(stack)\n    print(stack)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for i in range(len(paren_string) - 1):\n        if paren_string[i + 1] == '(':\n            paren_groups.append(0)\n            continue\n\n        if paren_string[i + 1] == ')':\n            paren_groups[-1] += 1\n            continue\n\n        # no change in paren_group\n        paren_groups.append(paren_groups[-1])\n\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    deepest_paren = 0\n    paren_string = paren_string.replace(' ', '')\n    try:\n        for paren in paren_string.split('('):\n            if ')' in paren:\n                deepest_paren = max(deepest_paren, len(paren.split(')')) + 1)\n    except Exception as ex:\n        raise ex\n    return [deepest_paren]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_list = []\n    nested_list = paren_string.split()\n    for item in nested_list:\n        parsed_list.append(get_max_nest(item))\n    return parsed_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.replace('(','').replace(')','').split()\n    paren_list = [int(x) for x in paren_list]\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for i, group in enumerate(paren_string.split(' ')):\n        if group[0] == '(':\n            level = 1\n        else:\n            level = 0\n        if group[-1] == ')':\n            level += 1\n        result.append(level)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = []\n    paren_list = paren_string.split(' ')\n    for item in paren_list:\n        nesting.append(paren_count(item))\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [sum(parse_nested_parens(part) for part in part.split(' ')) for part in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # first remove spaces from the string\n    paren_string = paren_string.replace(' ', '')\n\n    # split the string into individual groups for nesting\n    # e.g. ((())) -> ['(', '(', ')', ')', ')']\n    groups = paren_string.split(')')\n\n    # these will be used to determine which parenthesis is opened\n    last_opened_index = None\n    last_opened_char = None\n    last_opened_type = None\n\n    # let's start with opening parenthesis\n    for i, group in enumerate(groups):\n        # if it is a left parenthesis, it means that it is opened, so we record it\n        if group == '(':\n            last_opened_index = i\n            last_opened_char = group\n            last_opened_type = '('\n\n    # now we need to determine the last closed parenthesis\n    # first, let's sort the groups from left to right\n    # e.g. ((())) -> [(, (), ), )]\n    groups_sorted = sorted(groups)\n\n    # from right to left, we will find the first left parenthesis that is not opened\n    for i in range(len(groups_sorted) -", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_list = paren_string.split()\n    nesting_list = []\n\n    for paren in paren_list:\n        if paren in '()':\n            if paren not in nesting_list:\n                nesting_list.append(paren)\n            else:\n                nesting_list.remove(paren)\n                nesting_list.append(nesting_list[-1] + paren)\n\n    return nesting_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n        raise ValueError('Invalid string of parentheses')\n\n    paren_list = []\n    inner_paren_list = []\n    current_depth = 0\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n        elif char == ')':\n            current_depth -= 1\n            if current_depth < 0:\n                raise ValueError('Invalid string of parentheses')\n        elif char =='':\n            if current_depth > 0:\n                raise ValueError('Invalid string of parentheses')\n            paren_list.append(inner_paren_list)\n            inner_paren_list = []\n        else:\n            inner_paren_list.append(char)\n\n    return paren_list\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    paren_groups = paren_string.replace(' ', '').split('(')\n    for paren_group in paren_groups:\n        result.append(get_deepest_level(paren_group))\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(reversed(paren_string.split()))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string =''.join(paren_string.split())\n    min_nesting = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            min_nesting += 1\n        elif char == ')':\n            min_nesting -= 1\n    return [min_nesting, ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('()','( ')\n    paren_string = paren_string.replace('(','(')\n    paren_string = paren_string.replace(')',')')\n\n    return max(\n        parse_nested_parens(x) if x else 0\n        for x in paren_string.split(' ')\n    )", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nest = 0\n    parens = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            nest += 1\n        elif char == ')':\n            nest -= 1\n        if char == ')' and nest == 0:\n            parens.append(i)\n\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [max(map(parse_nested_parens, group.split())) for group in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n        return []\n    # the left-most parenthesis is the first element\n    depth_list = []\n    for paren in paren_string.split():\n        if paren == \"(\":\n            depth_list.append(1)\n        elif paren == \")\":\n            depth_list[-1] -= 1\n            if depth_list[-1] == 0:\n                depth_list.pop()\n        else:\n            depth_list.append(0)\n    return depth_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip().split()\n    paren_list = []\n    for group in paren_string:\n        group = [int(i) for i in group]\n        paren_list += group\n        group = [bool(i) for i in group]\n        paren_list += [len(set(j)) for j in group]\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = 0\n    nested_parens = paren_string.split(' ')\n    if len(nested_parens) == 0:\n        result = 0\n    else:\n        result = max(parse_nested_parens(nested_parens[0]), parse_nested_parens(' '.join(nested_parens[1:])))\n    return [result] + [parse_nested_parens(nested_parens[i]) for i in range(len(nested_parens))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for i, char in enumerate(paren_string):\n        if char == \"(\":\n            nested_parens.append(i)\n        elif char == \")\":\n            while len(nested_parens) > 0 and paren_string[nested_parens[-1]] == \"(\":\n                nested_parens.pop()\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def str_to_list(str: str) -> List[str]:\n        return [str.strip() for str in str.split(' ')]\n    return [parse_nested_parens(str_to_list(str)) for str in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    result = []\n\n    for group in paren_string.split():\n        stack.append(0 if group == '(' else 1)\n        if stack[-1] == 0:\n            if len(result) == 0:\n                result.append(0)\n            else:\n                result[-1] += 1\n        elif stack[-1] == 1:\n            if len(result) == 0:\n                result.append(1)\n            else:\n                result[-1] += 1\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    current_paren = 0\n    for char in paren_string:\n        if char == '(':\n            current_paren += 1\n        elif char == ')':\n            current_paren -= 1\n        if current_paren == 0:\n            result.append(paren_string.count('('))\n            current_paren = 0\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            output.append(i)\n        else:\n            if output:\n                output[-1] = max(output[-1], i)\n            else:\n                output = [i]\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Start from the end of string and check if there is a ')'\n    current = -1\n    paren = 0\n    paren_list = []\n\n    for i, c in enumerate(paren_string[::-1]):\n        if c == '(':\n            current += 1\n            if current > paren:\n                paren_list.append(paren)\n            paren += 1\n        elif c == ')':\n            if current == paren:\n                paren -= 1\n                if paren == 0:\n                    paren_list.append(paren)\n            current -= 1\n        elif c =='':\n            if current == paren:\n                paren_list.append(paren)\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    for c in paren_string:\n        if c == '(':\n            paren_list.append(len(paren_list))\n            continue\n        if c == ')':\n            paren_list.pop()\n            continue\n\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split(' ')\n    return [max(parse_nested_parens(p) or [0] for p in paren_groups)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for i, p in enumerate(paren_string.split()):\n        if p == '(':\n            nested_parens.append(1)\n        elif p == ')':\n            if nested_parens[-1]:\n                nested_parens[-1] -= 1\n            else:\n                raise ValueError('Nesting of'+ p +'outside of any parentheses.')\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    groups = paren_string.split(' ')\n    groups_count = len(groups)\n\n    for i in range(groups_count):\n        string = groups[i].strip('()').strip()\n        if string[0]!= '(':\n            result.append(len(string))\n        else:\n            result.append(max(parse_nested_parens(string)) + 1)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups = paren_string.split()\n\n    return [max(parse_nested_parens(x) for x in groups) for _ in groups]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    return [[len(paren_string[i:].split(' ')) - 1 for i in range(0, len(paren_string), 2)]\n            for _ in range(0, len(paren_string) // 2)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = paren_string.split(' ')\n    levels = []\n\n    for paren_group in paren_groups:\n        level = 0\n        for paren in paren_group:\n            if paren == '(':\n                level += 1\n            elif paren == ')':\n                level -= 1\n                if level < 0:\n                    return -1  # pragma: no cover\n        levels.append(level)\n\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    for sub_string in paren_string.split(' '):\n        nested_parens.append(max(parse_nested_parens(sub_string)))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def is_inside_parens(c: int) -> bool:\n        return c == '(' or c == ')'\n\n    paren_string = paren_string.strip()\n    paren_groups = paren_string.split(' ')\n    max_level = len(paren_groups)\n\n    results = []\n    for paren_group in paren_groups:\n        paren_group = paren_group.strip()\n        if not paren_group:\n            results.append(0)\n        elif not is_inside_parens(paren_group[0]):\n            results.append(0)\n        else:\n            results.append(1 + max(parse_nested_parens(paren_group)))\n\n    return results", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_count = 0\n    out_list = []\n    for group in paren_string.split(\" \"):\n        if group.strip().startswith(\"(\") and group.strip().endswith(\")\"):\n            nested_count += 1\n        out_list.append(nested_count)\n\n    return out_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split(' ')\n\n    nested_paren_list = []\n    for paren in paren_list:\n        paren_nest_count = 0\n        for i, char in enumerate(paren):\n            if char == '(':\n                paren_nest_count += 1\n            else:\n                paren_nest_count -= 1\n            if paren_nest_count < 0:\n                break\n        nested_paren_list.append(paren_nest_count)\n    return nested_paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_string = paren_string.strip()\n    # Check if the string has any parens at all\n    if not paren_string:\n        return []\n\n    groups = []\n    # Check if the string has any groups\n    if paren_string[0] == '(':\n        groups.append(0)\n\n    paren_index = 0\n    # Check if the string has multiple groups\n    while paren_string[paren_index] == '(':\n        paren_index += 1\n        groups.append(0)\n    # Check if the string has any groups\n    if paren_string[paren_index] == ')':\n        groups.append(0)\n\n    paren_depth = []\n    for i in range(len(groups)):\n        if groups[i] == 0:\n            # Check if the string has nesting\n            while paren_string[paren_index + i] == ')':\n                paren_depth.append(i)\n                paren_index += 1\n                # Check if the string has nesting\n                while paren_string[paren_index + i] == '(':\n                    paren_depth.append(i)\n                    paren_index += 1\n\n        else:\n            # Check if the string has nesting\n            while paren_string[paren_index + i] ==", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_groups = paren_string.split()\n    levels: List[int] = []\n    for group in paren_groups:\n        levels.append(1)\n        for char in group:\n            if char == '(':\n                levels[-1] += 1\n            elif char == ')':\n                levels[-1] -= 1\n                if levels[-1] < 0:\n                    levels[-1] = 0\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace(\" \", \"\")\n    paren_string = paren_string.replace(\"(\", \"\")\n    paren_string = paren_string.replace(\")\", \"\")\n\n    parsed_paren = []\n    for i in range(0, len(paren_string) - 1):\n        if paren_string[i] == '(' and paren_string[i + 1] == ')':\n            parsed_paren.append(-1)\n        elif paren_string[i] == '(':\n            parsed_paren.append(parsed_paren[-1] + 1)\n        elif paren_string[i] == ')':\n            parsed_paren.append(parsed_paren[-1] - 1)\n        else:\n            parsed_paren.append(parsed_paren[-1])\n    return parsed_paren", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            top = stack.pop()\n            if top == 0:\n                stack.append(0)\n            else:\n                stack[top - 1] = max(stack[top - 1], 1)\n    return [sum(stack) for stack in stack]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    level = []\n\n    for match in paren_string.split(' '):\n        level.append(len(match) - 1)\n\n    return level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = paren_string.split()\n    nested_parens = [int(i) for i in nested_parens]\n\n    nested_parens = [\n        max(nested_parens[:i] + nested_parens[i + 1:]) if i > 0 else 0 for i in range(len(nested_parens))\n    ]\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = paren_string.split()\n    return list(map(lambda x: len(x.split('(')) - 1, paren_list))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    result = []\n    for i in range(len(groups)):\n        result.append(parse_nested_parens(groups[i]))\n    return max(result)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(0)\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n\n    return [len(stack)] + stack"]]